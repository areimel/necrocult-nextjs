_N_E =
(window["webpackJsonp_N_E"] = window["webpackJsonp_N_E"] || []).push([["pages/FilmGrainFilter"],{

/***/ "./components/FilmGrainFilter/FilmGrainFilter.js":
/*!*******************************************************!*\
  !*** ./components/FilmGrainFilter/FilmGrainFilter.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return FilmGrainFilter; });
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var D_Dev_Personal_Sites_Necro_Cult_Zine_React_Git_Folder_1_necrocult_nextjs_node_modules_babel_runtime_helpers_esm_objectDestructuringEmpty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/objectDestructuringEmpty */ "./node_modules/@babel/runtime/helpers/esm/objectDestructuringEmpty.js");
/* harmony import */ var _FilmGrainFilter_module_scss__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./FilmGrainFilter.module.scss */ "./components/FilmGrainFilter/FilmGrainFilter.module.scss");
/* harmony import */ var _FilmGrainFilter_module_scss__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_FilmGrainFilter_module_scss__WEBPACK_IMPORTED_MODULE_2__);


var _jsxFileName = "D:\\Dev\\Personal Sites\\Necro Cult Zine React\\Git Folder 1\\necrocult-nextjs\\components\\FilmGrainFilter\\FilmGrainFilter.js";

function FilmGrainFilter(_ref) {
  Object(D_Dev_Personal_Sites_Necro_Cult_Zine_React_Git_Folder_1_necrocult_nextjs_node_modules_babel_runtime_helpers_esm_objectDestructuringEmpty__WEBPACK_IMPORTED_MODULE_1__["default"])(_ref);

  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
    className: _FilmGrainFilter_module_scss__WEBPACK_IMPORTED_MODULE_2___default.a.filmGrainFilter
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 7,
    columnNumber: 4
  }, this);
}
_c = FilmGrainFilter;

var _c;

$RefreshReg$(_c, "FilmGrainFilter");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module)))

/***/ }),

/***/ "./components/FilmGrainFilter/FilmGrainFilter.module.scss":
/*!****************************************************************!*\
  !*** ./components/FilmGrainFilter/FilmGrainFilter.module.scss ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(/*! ../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-3-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-3-2!../../node_modules/next/dist/compiled/resolve-url-loader??ref--5-oneOf-3-3!../../node_modules/next/dist/compiled/sass-loader/cjs.js??ref--5-oneOf-3-4!./FilmGrainFilter.module.scss */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./node_modules/next/dist/compiled/resolve-url-loader/index.js?!./node_modules/next/dist/compiled/sass-loader/cjs.js?!./components/FilmGrainFilter/FilmGrainFilter.module.scss");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = function(element){// These elements should always exist. If they do not,
// this code should fail.
var anchorElement=document.querySelector('#__next_css__DO_NOT_USE__');var parentNode=anchorElement.parentNode;// Normally <head>
// Each style tag should be placed right before our
// anchor. By inserting before and not after, we do not
// need to track the last inserted element.
parentNode.insertBefore(element,anchorElement);};
options.singleton = false;

var update = api(content, options);


if (true) {
  if (!content.locals || module.hot.invalidate) {
    var isEqualLocals = function isEqualLocals(a,b,isNamedExport){if(!a&&b||a&&!b){return false;}let p;for(p in a){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(a[p]!==b[p]){return false;}}for(p in b){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(!a[p]){return false;}}return true;};
    var oldLocals = content.locals;

    module.hot.accept(
      /*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-3-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-3-2!../../node_modules/next/dist/compiled/resolve-url-loader??ref--5-oneOf-3-3!../../node_modules/next/dist/compiled/sass-loader/cjs.js??ref--5-oneOf-3-4!./FilmGrainFilter.module.scss */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./node_modules/next/dist/compiled/resolve-url-loader/index.js?!./node_modules/next/dist/compiled/sass-loader/cjs.js?!./components/FilmGrainFilter/FilmGrainFilter.module.scss",
      function () {
        content = __webpack_require__(/*! !../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-3-1!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-3-2!../../node_modules/next/dist/compiled/resolve-url-loader??ref--5-oneOf-3-3!../../node_modules/next/dist/compiled/sass-loader/cjs.js??ref--5-oneOf-3-4!./FilmGrainFilter.module.scss */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./node_modules/next/dist/compiled/resolve-url-loader/index.js?!./node_modules/next/dist/compiled/sass-loader/cjs.js?!./components/FilmGrainFilter/FilmGrainFilter.module.scss");

              content = content.__esModule ? content.default : content;

              if (typeof content === 'string') {
                content = [[module.i, content, '']];
              }

              if (!isEqualLocals(oldLocals, content.locals)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = content.locals;

              update(content);
      }
    )
  }

  module.hot.dispose(function() {
    update();
  });
}

module.exports = content.locals || {};

/***/ }),

/***/ "./components/Layout/MasterCSS/MasterCSS.js":
/*!**************************************************!*\
  !*** ./components/Layout/MasterCSS/MasterCSS.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MasterCSS; });
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var D_Dev_Personal_Sites_Necro_Cult_Zine_React_Git_Folder_1_necrocult_nextjs_node_modules_babel_runtime_helpers_esm_objectDestructuringEmpty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/objectDestructuringEmpty */ "./node_modules/@babel/runtime/helpers/esm/objectDestructuringEmpty.js");



var _jsxFileName = "D:\\Dev\\Personal Sites\\Necro Cult Zine React\\Git Folder 1\\necrocult-nextjs\\components\\Layout\\MasterCSS\\MasterCSS.js";

/************************************

MasterCSS 	
	
	-	Link all JS files in desired order, 
		then add this component to the end of 
		your global layout, so all JS is loaded last.

************************************/
function MasterCSS(_ref) {
  Object(D_Dev_Personal_Sites_Necro_Cult_Zine_React_Git_Folder_1_necrocult_nextjs_node_modules_babel_runtime_helpers_esm_objectDestructuringEmpty__WEBPACK_IMPORTED_MODULE_1__["default"])(_ref);

  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["Fragment"], {
    children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("link", {
      rel: "stylesheet",
      href: "https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css",
      integrity: "sha512-iBBXm8fW90+nuLcSKlbmrPcLa0OT92xO1BIsZ+ywDWZCvqsWgccV3gFoRBv0z+8dLJgyAHIhR35VZc2oM/gI1w==",
      crossOrigin: "anonymous"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 16,
      columnNumber: 5
    }, this)
  }, void 0, false);
}
_c = MasterCSS;

var _c;

$RefreshReg$(_c, "MasterCSS");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module)))

/***/ }),

/***/ "./components/Layout/MasterJS/MasterJS.js":
/*!************************************************!*\
  !*** ./components/Layout/MasterJS/MasterJS.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MasterJS; });
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var D_Dev_Personal_Sites_Necro_Cult_Zine_React_Git_Folder_1_necrocult_nextjs_node_modules_babel_runtime_helpers_esm_objectDestructuringEmpty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/objectDestructuringEmpty */ "./node_modules/@babel/runtime/helpers/esm/objectDestructuringEmpty.js");



var _jsxFileName = "D:\\Dev\\Personal Sites\\Necro Cult Zine React\\Git Folder 1\\necrocult-nextjs\\components\\Layout\\MasterJS\\MasterJS.js";

/************************************

MasterJS 	
	
	-	Link all JS files in desired order, 
		then add this component to the end of 
		your global layout, so all JS is loaded last.

************************************/
function MasterJS(_ref) {
  Object(D_Dev_Personal_Sites_Necro_Cult_Zine_React_Git_Folder_1_necrocult_nextjs_node_modules_babel_runtime_helpers_esm_objectDestructuringEmpty__WEBPACK_IMPORTED_MODULE_1__["default"])(_ref);

  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["Fragment"], {
    children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("script", {
      src: "https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js",
      integrity: "sha512-894YE6QWD5I59HgZOGReFYm4dnWc1Qt5NtvYSaNcOP+u1T9qYdvdihz0PPSiiqn/+/3e7Jo4EaG7TubfWGUrMQ==",
      crossOrigin: "anonymous"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 16,
      columnNumber: 5
    }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("script", {
      src: "https://cdnjs.cloudflare.com/ajax/libs/headroom/0.12.0/headroom.min.js",
      integrity: "sha512-9UsrKTYzS9smDm2E58MLs0ACtOki+UC4bBq4iK5wi7lJycwqcaiHxr1bdEsIVoK0l5STEzLUdYyDdFQ5OEjczw==",
      crossOrigin: "anonymous"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 18,
      columnNumber: 5
    }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("script", {
      src: "https://cdnjs.cloudflare.com/ajax/libs/headroom/0.12.0/jQuery.headroom.min.js",
      integrity: "sha512-3zxNImEhQ2pnOSHdyGCCJhpMrU35j7UgnlycU/sLnbsdmcH+pXm9bR9htu6p6ggqx6b5VEKeinajKDpUW7LuTQ==",
      crossOrigin: "anonymous"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 19,
      columnNumber: 5
    }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("script", {
      src: "https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/js/solid.min.js",
      integrity: "sha512-Qc+cBMt/4/KXJ1F6nNQahXIsgPygHM4S2XWChoumV8qkpZ9oO+gBDBEpOxgbkQQ/6DlHx6cUxa5nBhEbuiR8xw==",
      crossOrigin: "anonymous"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 21,
      columnNumber: 5
    }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("script", {
      src: "/scripts/main.js"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 23,
      columnNumber: 5
    }, this)]
  }, void 0, true);
}
_c = MasterJS;

var _c;

$RefreshReg$(_c, "MasterJS");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module)))

/***/ }),

/***/ "./components/Template/ComponentMeta/ComponentMeta.js":
/*!************************************************************!*\
  !*** ./components/Template/ComponentMeta/ComponentMeta.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ComponentMeta; });
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _ComponentMeta_module_scss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ComponentMeta.module.scss */ "./components/Template/ComponentMeta/ComponentMeta.module.scss");
/* harmony import */ var _ComponentMeta_module_scss__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_ComponentMeta_module_scss__WEBPACK_IMPORTED_MODULE_1__);

var _jsxFileName = "D:\\Dev\\Personal Sites\\Necro Cult Zine React\\Git Folder 1\\necrocult-nextjs\\components\\Template\\ComponentMeta\\ComponentMeta.js";

function ComponentMeta(_ref) {
  var title = _ref.title,
      author = _ref.author,
      authorTeam = _ref.authorTeam,
      description = _ref.description,
      contentProps = _ref.contentProps,
      libraries = _ref.libraries;
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
    className: _ComponentMeta_module_scss__WEBPACK_IMPORTED_MODULE_1___default.a.descriptionWrapper,
    children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
      className: _ComponentMeta_module_scss__WEBPACK_IMPORTED_MODULE_1___default.a.row,
      children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
        className: _ComponentMeta_module_scss__WEBPACK_IMPORTED_MODULE_1___default.a.cell + ' ' + _ComponentMeta_module_scss__WEBPACK_IMPORTED_MODULE_1___default.a.title,
        children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("ul", {
          className: _ComponentMeta_module_scss__WEBPACK_IMPORTED_MODULE_1___default.a.inner,
          children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("li", {
            className: _ComponentMeta_module_scss__WEBPACK_IMPORTED_MODULE_1___default.a.title,
            children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("span", {
              children: "Component:"
            }, void 0, false, {
              fileName: _jsxFileName,
              lineNumber: 19,
              columnNumber: 6
            }, this), title]
          }, void 0, true, {
            fileName: _jsxFileName,
            lineNumber: 18,
            columnNumber: 5
          }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("li", {
            className: _ComponentMeta_module_scss__WEBPACK_IMPORTED_MODULE_1___default.a.author,
            children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("span", {
              children: "Developer:"
            }, void 0, false, {
              fileName: _jsxFileName,
              lineNumber: 23,
              columnNumber: 6
            }, this), author, /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("br", {}, void 0, false, {
              fileName: _jsxFileName,
              lineNumber: 24,
              columnNumber: 14
            }, this), authorTeam]
          }, void 0, true, {
            fileName: _jsxFileName,
            lineNumber: 22,
            columnNumber: 5
          }, this)]
        }, void 0, true, {
          fileName: _jsxFileName,
          lineNumber: 17,
          columnNumber: 4
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 16,
        columnNumber: 3
      }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
        className: _ComponentMeta_module_scss__WEBPACK_IMPORTED_MODULE_1___default.a.cell + ' ' + _ComponentMeta_module_scss__WEBPACK_IMPORTED_MODULE_1___default.a.description,
        children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("ul", {
          className: _ComponentMeta_module_scss__WEBPACK_IMPORTED_MODULE_1___default.a.inner,
          children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("li", {
            className: _ComponentMeta_module_scss__WEBPACK_IMPORTED_MODULE_1___default.a.description,
            children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("span", {
              children: "Description:"
            }, void 0, false, {
              fileName: _jsxFileName,
              lineNumber: 33,
              columnNumber: 6
            }, this), description]
          }, void 0, true, {
            fileName: _jsxFileName,
            lineNumber: 32,
            columnNumber: 5
          }, this)
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 31,
          columnNumber: 4
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 30,
        columnNumber: 3
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 15,
      columnNumber: 2
    }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
      className: _ComponentMeta_module_scss__WEBPACK_IMPORTED_MODULE_1___default.a.row,
      children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
        className: _ComponentMeta_module_scss__WEBPACK_IMPORTED_MODULE_1___default.a.cell + ' ' + _ComponentMeta_module_scss__WEBPACK_IMPORTED_MODULE_1___default.a.contentProps,
        children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("ul", {
          className: _ComponentMeta_module_scss__WEBPACK_IMPORTED_MODULE_1___default.a.inner,
          children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("li", {
            className: _ComponentMeta_module_scss__WEBPACK_IMPORTED_MODULE_1___default.a.props,
            children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("span", {
              children: "Available Props:"
            }, void 0, false, {
              fileName: _jsxFileName,
              lineNumber: 44,
              columnNumber: 6
            }, this)
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 43,
            columnNumber: 5
          }, this), contentProps]
        }, void 0, true, {
          fileName: _jsxFileName,
          lineNumber: 42,
          columnNumber: 4
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 41,
        columnNumber: 3
      }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
        className: _ComponentMeta_module_scss__WEBPACK_IMPORTED_MODULE_1___default.a.cell + ' ' + _ComponentMeta_module_scss__WEBPACK_IMPORTED_MODULE_1___default.a.libraries,
        children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("ul", {
          className: _ComponentMeta_module_scss__WEBPACK_IMPORTED_MODULE_1___default.a.inner,
          children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("li", {
            className: _ComponentMeta_module_scss__WEBPACK_IMPORTED_MODULE_1___default.a.libraries,
            children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("span", {
              children: "Libraries Used:"
            }, void 0, false, {
              fileName: _jsxFileName,
              lineNumber: 53,
              columnNumber: 6
            }, this)
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 52,
            columnNumber: 5
          }, this), libraries]
        }, void 0, true, {
          fileName: _jsxFileName,
          lineNumber: 51,
          columnNumber: 4
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 50,
        columnNumber: 3
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 40,
      columnNumber: 2
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 12,
    columnNumber: 3
  }, this);
}
_c = ComponentMeta;

var _c;

$RefreshReg$(_c, "ComponentMeta");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module)))

/***/ }),

/***/ "./components/Template/ComponentMeta/ComponentMeta.module.scss":
/*!*********************************************************************!*\
  !*** ./components/Template/ComponentMeta/ComponentMeta.module.scss ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(/*! ../../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !../../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-3-1!../../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-3-2!../../../node_modules/next/dist/compiled/resolve-url-loader??ref--5-oneOf-3-3!../../../node_modules/next/dist/compiled/sass-loader/cjs.js??ref--5-oneOf-3-4!./ComponentMeta.module.scss */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./node_modules/next/dist/compiled/resolve-url-loader/index.js?!./node_modules/next/dist/compiled/sass-loader/cjs.js?!./components/Template/ComponentMeta/ComponentMeta.module.scss");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = function(element){// These elements should always exist. If they do not,
// this code should fail.
var anchorElement=document.querySelector('#__next_css__DO_NOT_USE__');var parentNode=anchorElement.parentNode;// Normally <head>
// Each style tag should be placed right before our
// anchor. By inserting before and not after, we do not
// need to track the last inserted element.
parentNode.insertBefore(element,anchorElement);};
options.singleton = false;

var update = api(content, options);


if (true) {
  if (!content.locals || module.hot.invalidate) {
    var isEqualLocals = function isEqualLocals(a,b,isNamedExport){if(!a&&b||a&&!b){return false;}let p;for(p in a){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(a[p]!==b[p]){return false;}}for(p in b){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(!a[p]){return false;}}return true;};
    var oldLocals = content.locals;

    module.hot.accept(
      /*! !../../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-3-1!../../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-3-2!../../../node_modules/next/dist/compiled/resolve-url-loader??ref--5-oneOf-3-3!../../../node_modules/next/dist/compiled/sass-loader/cjs.js??ref--5-oneOf-3-4!./ComponentMeta.module.scss */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./node_modules/next/dist/compiled/resolve-url-loader/index.js?!./node_modules/next/dist/compiled/sass-loader/cjs.js?!./components/Template/ComponentMeta/ComponentMeta.module.scss",
      function () {
        content = __webpack_require__(/*! !../../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-3-1!../../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-3-2!../../../node_modules/next/dist/compiled/resolve-url-loader??ref--5-oneOf-3-3!../../../node_modules/next/dist/compiled/sass-loader/cjs.js??ref--5-oneOf-3-4!./ComponentMeta.module.scss */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./node_modules/next/dist/compiled/resolve-url-loader/index.js?!./node_modules/next/dist/compiled/sass-loader/cjs.js?!./components/Template/ComponentMeta/ComponentMeta.module.scss");

              content = content.__esModule ? content.default : content;

              if (typeof content === 'string') {
                content = [[module.i, content, '']];
              }

              if (!isEqualLocals(oldLocals, content.locals)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = content.locals;

              update(content);
      }
    )
  }

  module.hot.dispose(function() {
    update();
  });
}

module.exports = content.locals || {};

/***/ }),

/***/ "./components/Template/Container/Container.js":
/*!****************************************************!*\
  !*** ./components/Template/Container/Container.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Container; });
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Container_module_scss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Container.module.scss */ "./components/Template/Container/Container.module.scss");
/* harmony import */ var _Container_module_scss__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_Container_module_scss__WEBPACK_IMPORTED_MODULE_1__);

var _jsxFileName = "D:\\Dev\\Personal Sites\\Necro Cult Zine React\\Git Folder 1\\necrocult-nextjs\\components\\Template\\Container\\Container.js";

function Container(_ref) {
  var children = _ref.children,
      containerSize = _ref.containerSize,
      flex = _ref.flex;
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
    className: _Container_module_scss__WEBPACK_IMPORTED_MODULE_1___default.a.container + (flex ? ' ' + _Container_module_scss__WEBPACK_IMPORTED_MODULE_1___default.a.flex : ''),
    children: children
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 9,
    columnNumber: 7
  }, this);
}
_c = Container;

var _c;

$RefreshReg$(_c, "Container");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module)))

/***/ }),

/***/ "./components/Template/Container/Container.module.scss":
/*!*************************************************************!*\
  !*** ./components/Template/Container/Container.module.scss ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(/*! ../../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !../../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-3-1!../../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-3-2!../../../node_modules/next/dist/compiled/resolve-url-loader??ref--5-oneOf-3-3!../../../node_modules/next/dist/compiled/sass-loader/cjs.js??ref--5-oneOf-3-4!./Container.module.scss */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./node_modules/next/dist/compiled/resolve-url-loader/index.js?!./node_modules/next/dist/compiled/sass-loader/cjs.js?!./components/Template/Container/Container.module.scss");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = function(element){// These elements should always exist. If they do not,
// this code should fail.
var anchorElement=document.querySelector('#__next_css__DO_NOT_USE__');var parentNode=anchorElement.parentNode;// Normally <head>
// Each style tag should be placed right before our
// anchor. By inserting before and not after, we do not
// need to track the last inserted element.
parentNode.insertBefore(element,anchorElement);};
options.singleton = false;

var update = api(content, options);


if (true) {
  if (!content.locals || module.hot.invalidate) {
    var isEqualLocals = function isEqualLocals(a,b,isNamedExport){if(!a&&b||a&&!b){return false;}let p;for(p in a){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(a[p]!==b[p]){return false;}}for(p in b){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(!a[p]){return false;}}return true;};
    var oldLocals = content.locals;

    module.hot.accept(
      /*! !../../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-3-1!../../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-3-2!../../../node_modules/next/dist/compiled/resolve-url-loader??ref--5-oneOf-3-3!../../../node_modules/next/dist/compiled/sass-loader/cjs.js??ref--5-oneOf-3-4!./Container.module.scss */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./node_modules/next/dist/compiled/resolve-url-loader/index.js?!./node_modules/next/dist/compiled/sass-loader/cjs.js?!./components/Template/Container/Container.module.scss",
      function () {
        content = __webpack_require__(/*! !../../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-3-1!../../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-3-2!../../../node_modules/next/dist/compiled/resolve-url-loader??ref--5-oneOf-3-3!../../../node_modules/next/dist/compiled/sass-loader/cjs.js??ref--5-oneOf-3-4!./Container.module.scss */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./node_modules/next/dist/compiled/resolve-url-loader/index.js?!./node_modules/next/dist/compiled/sass-loader/cjs.js?!./components/Template/Container/Container.module.scss");

              content = content.__esModule ? content.default : content;

              if (typeof content === 'string') {
                content = [[module.i, content, '']];
              }

              if (!isEqualLocals(oldLocals, content.locals)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = content.locals;

              update(content);
      }
    )
  }

  module.hot.dispose(function() {
    update();
  });
}

module.exports = content.locals || {};

/***/ }),

/***/ "./components/Template/Footer/Footer.js":
/*!**********************************************!*\
  !*** ./components/Template/Footer/Footer.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Footer; });
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Footer_module_scss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Footer.module.scss */ "./components/Template/Footer/Footer.module.scss");
/* harmony import */ var _Footer_module_scss__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_Footer_module_scss__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _components_Layout_MasterJS_MasterJS__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @components/Layout/MasterJS/MasterJS */ "./components/Layout/MasterJS/MasterJS.js");


var _jsxFileName = "D:\\Dev\\Personal Sites\\Necro Cult Zine React\\Git Folder 1\\necrocult-nextjs\\components\\Template\\Footer\\Footer.js";


function Footer(_ref) {
  var footerMessage = _ref.footerMessage;
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["Fragment"], {
    children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("footer", {
      className: _Footer_module_scss__WEBPACK_IMPORTED_MODULE_1___default.a.footer,
      children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("p", {
        className: _Footer_module_scss__WEBPACK_IMPORTED_MODULE_1___default.a.footer_message,
        children: footerMessage
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 8,
        columnNumber: 8
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 7,
      columnNumber: 7
    }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_components_Layout_MasterJS_MasterJS__WEBPACK_IMPORTED_MODULE_2__["default"], {}, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 11,
      columnNumber: 7
    }, this)]
  }, void 0, true);
}
_c = Footer;

var _c;

$RefreshReg$(_c, "Footer");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module)))

/***/ }),

/***/ "./components/Template/Footer/Footer.module.scss":
/*!*******************************************************!*\
  !*** ./components/Template/Footer/Footer.module.scss ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(/*! ../../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !../../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-3-1!../../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-3-2!../../../node_modules/next/dist/compiled/resolve-url-loader??ref--5-oneOf-3-3!../../../node_modules/next/dist/compiled/sass-loader/cjs.js??ref--5-oneOf-3-4!./Footer.module.scss */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./node_modules/next/dist/compiled/resolve-url-loader/index.js?!./node_modules/next/dist/compiled/sass-loader/cjs.js?!./components/Template/Footer/Footer.module.scss");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = function(element){// These elements should always exist. If they do not,
// this code should fail.
var anchorElement=document.querySelector('#__next_css__DO_NOT_USE__');var parentNode=anchorElement.parentNode;// Normally <head>
// Each style tag should be placed right before our
// anchor. By inserting before and not after, we do not
// need to track the last inserted element.
parentNode.insertBefore(element,anchorElement);};
options.singleton = false;

var update = api(content, options);


if (true) {
  if (!content.locals || module.hot.invalidate) {
    var isEqualLocals = function isEqualLocals(a,b,isNamedExport){if(!a&&b||a&&!b){return false;}let p;for(p in a){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(a[p]!==b[p]){return false;}}for(p in b){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(!a[p]){return false;}}return true;};
    var oldLocals = content.locals;

    module.hot.accept(
      /*! !../../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-3-1!../../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-3-2!../../../node_modules/next/dist/compiled/resolve-url-loader??ref--5-oneOf-3-3!../../../node_modules/next/dist/compiled/sass-loader/cjs.js??ref--5-oneOf-3-4!./Footer.module.scss */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./node_modules/next/dist/compiled/resolve-url-loader/index.js?!./node_modules/next/dist/compiled/sass-loader/cjs.js?!./components/Template/Footer/Footer.module.scss",
      function () {
        content = __webpack_require__(/*! !../../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-3-1!../../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-3-2!../../../node_modules/next/dist/compiled/resolve-url-loader??ref--5-oneOf-3-3!../../../node_modules/next/dist/compiled/sass-loader/cjs.js??ref--5-oneOf-3-4!./Footer.module.scss */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./node_modules/next/dist/compiled/resolve-url-loader/index.js?!./node_modules/next/dist/compiled/sass-loader/cjs.js?!./components/Template/Footer/Footer.module.scss");

              content = content.__esModule ? content.default : content;

              if (typeof content === 'string') {
                content = [[module.i, content, '']];
              }

              if (!isEqualLocals(oldLocals, content.locals)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = content.locals;

              update(content);
      }
    )
  }

  module.hot.dispose(function() {
    update();
  });
}

module.exports = content.locals || {};

/***/ }),

/***/ "./components/Template/Header/Header.js":
/*!**********************************************!*\
  !*** ./components/Template/Header/Header.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Header; });
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Header_module_scss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Header.module.scss */ "./components/Template/Header/Header.module.scss");
/* harmony import */ var _Header_module_scss__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_Header_module_scss__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _components_Template_Container_Container__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @components/Template/Container/Container */ "./components/Template/Container/Container.js");
/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/image */ "./node_modules/next/image.js");
/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_image__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _components_Layout_MasterCSS_MasterCSS__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @components/Layout/MasterCSS/MasterCSS */ "./components/Layout/MasterCSS/MasterCSS.js");

var _jsxFileName = "D:\\Dev\\Personal Sites\\Necro Cult Zine React\\Git Folder 1\\necrocult-nextjs\\components\\Template\\Header\\Header.js";




function Header(_ref) {
  var title = _ref.title;
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("header", {
    className: _Header_module_scss__WEBPACK_IMPORTED_MODULE_1___default.a.header,
    children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_components_Layout_MasterCSS_MasterCSS__WEBPACK_IMPORTED_MODULE_4__["default"], {}, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 10,
      columnNumber: 6
    }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_components_Template_Container_Container__WEBPACK_IMPORTED_MODULE_2__["default"], {
      className: _Header_module_scss__WEBPACK_IMPORTED_MODULE_1___default.a.container,
      children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
        className: _Header_module_scss__WEBPACK_IMPORTED_MODULE_1___default.a.contentLeft,
        children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
          className: _Header_module_scss__WEBPACK_IMPORTED_MODULE_1___default.a.title,
          children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("h1", {
            className: "old_english",
            children: title
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 17,
            columnNumber: 17
          }, this)
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 16,
          columnNumber: 15
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 13,
        columnNumber: 8
      }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
        className: _Header_module_scss__WEBPACK_IMPORTED_MODULE_1___default.a.contentRight
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 21,
        columnNumber: 8
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 11,
      columnNumber: 6
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 9,
    columnNumber: 4
  }, this);
}
_c = Header;

var _c;

$RefreshReg$(_c, "Header");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module)))

/***/ }),

/***/ "./components/Template/Header/Header.module.scss":
/*!*******************************************************!*\
  !*** ./components/Template/Header/Header.module.scss ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(/*! ../../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !../../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-3-1!../../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-3-2!../../../node_modules/next/dist/compiled/resolve-url-loader??ref--5-oneOf-3-3!../../../node_modules/next/dist/compiled/sass-loader/cjs.js??ref--5-oneOf-3-4!./Header.module.scss */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./node_modules/next/dist/compiled/resolve-url-loader/index.js?!./node_modules/next/dist/compiled/sass-loader/cjs.js?!./components/Template/Header/Header.module.scss");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = function(element){// These elements should always exist. If they do not,
// this code should fail.
var anchorElement=document.querySelector('#__next_css__DO_NOT_USE__');var parentNode=anchorElement.parentNode;// Normally <head>
// Each style tag should be placed right before our
// anchor. By inserting before and not after, we do not
// need to track the last inserted element.
parentNode.insertBefore(element,anchorElement);};
options.singleton = false;

var update = api(content, options);


if (true) {
  if (!content.locals || module.hot.invalidate) {
    var isEqualLocals = function isEqualLocals(a,b,isNamedExport){if(!a&&b||a&&!b){return false;}let p;for(p in a){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(a[p]!==b[p]){return false;}}for(p in b){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(!a[p]){return false;}}return true;};
    var oldLocals = content.locals;

    module.hot.accept(
      /*! !../../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-3-1!../../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-3-2!../../../node_modules/next/dist/compiled/resolve-url-loader??ref--5-oneOf-3-3!../../../node_modules/next/dist/compiled/sass-loader/cjs.js??ref--5-oneOf-3-4!./Header.module.scss */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./node_modules/next/dist/compiled/resolve-url-loader/index.js?!./node_modules/next/dist/compiled/sass-loader/cjs.js?!./components/Template/Header/Header.module.scss",
      function () {
        content = __webpack_require__(/*! !../../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-3-1!../../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-3-2!../../../node_modules/next/dist/compiled/resolve-url-loader??ref--5-oneOf-3-3!../../../node_modules/next/dist/compiled/sass-loader/cjs.js??ref--5-oneOf-3-4!./Header.module.scss */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./node_modules/next/dist/compiled/resolve-url-loader/index.js?!./node_modules/next/dist/compiled/sass-loader/cjs.js?!./components/Template/Header/Header.module.scss");

              content = content.__esModule ? content.default : content;

              if (typeof content === 'string') {
                content = [[module.i, content, '']];
              }

              if (!isEqualLocals(oldLocals, content.locals)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = content.locals;

              update(content);
      }
    )
  }

  module.hot.dispose(function() {
    update();
  });
}

module.exports = content.locals || {};

/***/ }),

/***/ "./components/Template/Sandbox/Sandbox.js":
/*!************************************************!*\
  !*** ./components/Template/Sandbox/Sandbox.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Sandbox; });
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Sandbox_module_scss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Sandbox.module.scss */ "./components/Template/Sandbox/Sandbox.module.scss");
/* harmony import */ var _Sandbox_module_scss__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_Sandbox_module_scss__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _components_Template_Container_Container__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @components/Template/Container/Container */ "./components/Template/Container/Container.js");

var _jsxFileName = "D:\\Dev\\Personal Sites\\Necro Cult Zine React\\Git Folder 1\\necrocult-nextjs\\components\\Template\\Sandbox\\Sandbox.js";


function Sandbox(_ref) {
  var children = _ref.children;
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("section", {
    className: _Sandbox_module_scss__WEBPACK_IMPORTED_MODULE_1___default.a.sandbox,
    children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_components_Template_Container_Container__WEBPACK_IMPORTED_MODULE_2__["default"], {
      children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
        className: _Sandbox_module_scss__WEBPACK_IMPORTED_MODULE_1___default.a.content,
        children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("p", {
          className: _Sandbox_module_scss__WEBPACK_IMPORTED_MODULE_1___default.a.title,
          children: "Component Sandbox"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 12,
          columnNumber: 11
        }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
          className: _Sandbox_module_scss__WEBPACK_IMPORTED_MODULE_1___default.a.inner,
          children: children
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 13,
          columnNumber: 11
        }, this)]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 11,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 10,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 8,
    columnNumber: 5
  }, this);
}
_c = Sandbox;

var _c;

$RefreshReg$(_c, "Sandbox");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module)))

/***/ }),

/***/ "./components/Template/Sandbox/Sandbox.module.scss":
/*!*********************************************************!*\
  !*** ./components/Template/Sandbox/Sandbox.module.scss ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(/*! ../../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !../../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-3-1!../../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-3-2!../../../node_modules/next/dist/compiled/resolve-url-loader??ref--5-oneOf-3-3!../../../node_modules/next/dist/compiled/sass-loader/cjs.js??ref--5-oneOf-3-4!./Sandbox.module.scss */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./node_modules/next/dist/compiled/resolve-url-loader/index.js?!./node_modules/next/dist/compiled/sass-loader/cjs.js?!./components/Template/Sandbox/Sandbox.module.scss");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = function(element){// These elements should always exist. If they do not,
// this code should fail.
var anchorElement=document.querySelector('#__next_css__DO_NOT_USE__');var parentNode=anchorElement.parentNode;// Normally <head>
// Each style tag should be placed right before our
// anchor. By inserting before and not after, we do not
// need to track the last inserted element.
parentNode.insertBefore(element,anchorElement);};
options.singleton = false;

var update = api(content, options);


if (true) {
  if (!content.locals || module.hot.invalidate) {
    var isEqualLocals = function isEqualLocals(a,b,isNamedExport){if(!a&&b||a&&!b){return false;}let p;for(p in a){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(a[p]!==b[p]){return false;}}for(p in b){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(!a[p]){return false;}}return true;};
    var oldLocals = content.locals;

    module.hot.accept(
      /*! !../../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-3-1!../../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-3-2!../../../node_modules/next/dist/compiled/resolve-url-loader??ref--5-oneOf-3-3!../../../node_modules/next/dist/compiled/sass-loader/cjs.js??ref--5-oneOf-3-4!./Sandbox.module.scss */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./node_modules/next/dist/compiled/resolve-url-loader/index.js?!./node_modules/next/dist/compiled/sass-loader/cjs.js?!./components/Template/Sandbox/Sandbox.module.scss",
      function () {
        content = __webpack_require__(/*! !../../../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-3-1!../../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-3-2!../../../node_modules/next/dist/compiled/resolve-url-loader??ref--5-oneOf-3-3!../../../node_modules/next/dist/compiled/sass-loader/cjs.js??ref--5-oneOf-3-4!./Sandbox.module.scss */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./node_modules/next/dist/compiled/resolve-url-loader/index.js?!./node_modules/next/dist/compiled/sass-loader/cjs.js?!./components/Template/Sandbox/Sandbox.module.scss");

              content = content.__esModule ? content.default : content;

              if (typeof content === 'string') {
                content = [[module.i, content, '']];
              }

              if (!isEqualLocals(oldLocals, content.locals)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = content.locals;

              update(content);
      }
    )
  }

  module.hot.dispose(function() {
    update();
  });
}

module.exports = content.locals || {};

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayLikeToArray.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

module.exports = _arrayLikeToArray;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/arrayWithHoles.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayWithHoles.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

module.exports = _arrayWithHoles;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(/*! ./arrayLikeToArray */ "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js");

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return arrayLikeToArray(arr);
}

module.exports = _arrayWithoutHoles;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/assertThisInitialized.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/classCallCheck.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/classCallCheck.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/createClass.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/createClass.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/defineProperty.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/defineProperty.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/objectDestructuringEmpty.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/objectDestructuringEmpty.js ***!
  \*****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _objectDestructuringEmpty; });
function _objectDestructuringEmpty(obj) {
  if (obj == null) throw new TypeError("Cannot destructure undefined");
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/extends.js":
/*!********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/extends.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _extends() {
  module.exports = _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

module.exports = _extends;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/getPrototypeOf.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/inherits.js":
/*!*********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/inherits.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf */ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js");

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}

module.exports = _inherits;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/interopRequireDefault.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

module.exports = _interopRequireDefault;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/iterableToArray.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/iterableToArray.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

module.exports = _iterableToArray;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

module.exports = _iterableToArrayLimit;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/nonIterableRest.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/nonIterableRest.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableRest;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/nonIterableSpread.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/nonIterableSpread.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableSpread;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

module.exports = _objectWithoutPropertiesLoose;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js");

var assertThisInitialized = __webpack_require__(/*! ./assertThisInitialized */ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js");

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return assertThisInitialized(self);
}

module.exports = _possibleConstructorReturn;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/setPrototypeOf.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/slicedToArray.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/slicedToArray.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithHoles = __webpack_require__(/*! ./arrayWithHoles */ "./node_modules/@babel/runtime/helpers/arrayWithHoles.js");

var iterableToArrayLimit = __webpack_require__(/*! ./iterableToArrayLimit */ "./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js");

var unsupportedIterableToArray = __webpack_require__(/*! ./unsupportedIterableToArray */ "./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js");

var nonIterableRest = __webpack_require__(/*! ./nonIterableRest */ "./node_modules/@babel/runtime/helpers/nonIterableRest.js");

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
}

module.exports = _slicedToArray;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/toConsumableArray.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/toConsumableArray.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithoutHoles = __webpack_require__(/*! ./arrayWithoutHoles */ "./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js");

var iterableToArray = __webpack_require__(/*! ./iterableToArray */ "./node_modules/@babel/runtime/helpers/iterableToArray.js");

var unsupportedIterableToArray = __webpack_require__(/*! ./unsupportedIterableToArray */ "./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js");

var nonIterableSpread = __webpack_require__(/*! ./nonIterableSpread */ "./node_modules/@babel/runtime/helpers/nonIterableSpread.js");

function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
}

module.exports = _toConsumableArray;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/typeof.js":
/*!*******************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/typeof.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(/*! ./arrayLikeToArray */ "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js");

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}

module.exports = _unsupportedIterableToArray;

/***/ }),

/***/ "./node_modules/next/dist/build/polyfills/object-assign.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/object-assign.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var assign=Object.assign.bind(Object);module.exports=assign;module.exports.default=module.exports;
//# sourceMappingURL=object-assign.js.map

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2FFilmGrainFilter&absolutePagePath=D%3A%5CDev%5CPersonal%20Sites%5CNecro%20Cult%20Zine%20React%5CGit%20Folder%201%5Cnecrocult-nextjs%5Cpages%5CFilmGrainFilter.js!./":
/*!**********************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2FFilmGrainFilter&absolutePagePath=D%3A%5CDev%5CPersonal%20Sites%5CNecro%20Cult%20Zine%20React%5CGit%20Folder%201%5Cnecrocult-nextjs%5Cpages%5CFilmGrainFilter.js ***!
  \**********************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


    (window.__NEXT_P = window.__NEXT_P || []).push([
      "/FilmGrainFilter",
      function () {
        return __webpack_require__(/*! ./pages/FilmGrainFilter.js */ "./pages/FilmGrainFilter.js");
      }
    ]);
  

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
const isOldIE=function isOldIE(){let memo;return function memorize(){if(typeof memo==='undefined'){// Test for IE <= 9 as proposed by Browserhacks
// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
// Tests for existence of standard globals is to allow style-loader
// to operate correctly into non-standard environments
// @see https://github.com/webpack-contrib/style-loader/issues/177
memo=Boolean(window&&document&&document.all&&!window.atob);}return memo;};}();const getTarget=function getTarget(){const memo={};return function memorize(target){if(typeof memo[target]==='undefined'){let styleTarget=document.querySelector(target);// Special case to return head of iframe instead of iframe itself
if(window.HTMLIFrameElement&&styleTarget instanceof window.HTMLIFrameElement){try{// This will throw an exception if access to iframe is blocked
// due to cross-origin restrictions
styleTarget=styleTarget.contentDocument.head;}catch(e){// istanbul ignore next
styleTarget=null;}}memo[target]=styleTarget;}return memo[target];};}();const stylesInDom=[];function getIndexByIdentifier(identifier){let result=-1;for(let i=0;i<stylesInDom.length;i++){if(stylesInDom[i].identifier===identifier){result=i;break;}}return result;}function modulesToDom(list,options){const idCountMap={};const identifiers=[];for(let i=0;i<list.length;i++){const item=list[i];const id=options.base?item[0]+options.base:item[0];const count=idCountMap[id]||0;const identifier=`${id} ${count}`;idCountMap[id]=count+1;const index=getIndexByIdentifier(identifier);const obj={css:item[1],media:item[2],sourceMap:item[3]};if(index!==-1){stylesInDom[index].references++;stylesInDom[index].updater(obj);}else{stylesInDom.push({identifier,updater:addStyle(obj,options),references:1});}identifiers.push(identifier);}return identifiers;}function insertStyleElement(options){const style=document.createElement('style');const attributes=options.attributes||{};if(typeof attributes.nonce==='undefined'){const nonce=// eslint-disable-next-line no-undef
 true?__webpack_require__.nc:undefined;if(nonce){attributes.nonce=nonce;}}Object.keys(attributes).forEach(key=>{style.setAttribute(key,attributes[key]);});if(typeof options.insert==='function'){options.insert(style);}else{const target=getTarget(options.insert||'head');if(!target){throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");}target.appendChild(style);}return style;}function removeStyleElement(style){// istanbul ignore if
if(style.parentNode===null){return false;}style.parentNode.removeChild(style);}/* istanbul ignore next  */const replaceText=function replaceText(){const textStore=[];return function replace(index,replacement){textStore[index]=replacement;return textStore.filter(Boolean).join('\n');};}();function applyToSingletonTag(style,index,remove,obj){const css=remove?'':obj.media?`@media ${obj.media} {${obj.css}}`:obj.css;// For old IE
/* istanbul ignore if  */if(style.styleSheet){style.styleSheet.cssText=replaceText(index,css);}else{const cssNode=document.createTextNode(css);const childNodes=style.childNodes;if(childNodes[index]){style.removeChild(childNodes[index]);}if(childNodes.length){style.insertBefore(cssNode,childNodes[index]);}else{style.appendChild(cssNode);}}}function applyToTag(style,options,obj){let css=obj.css;const media=obj.media;const sourceMap=obj.sourceMap;if(media){style.setAttribute('media',media);}else{style.removeAttribute('media');}if(sourceMap&&typeof btoa!=='undefined'){css+=`\n/*# sourceMappingURL=data:application/json;base64,${btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))))} */`;}// For old IE
/* istanbul ignore if  */if(style.styleSheet){style.styleSheet.cssText=css;}else{while(style.firstChild){style.removeChild(style.firstChild);}style.appendChild(document.createTextNode(css));}}let singleton=null;let singletonCounter=0;function addStyle(obj,options){let style;let update;let remove;if(options.singleton){const styleIndex=singletonCounter++;style=singleton||(singleton=insertStyleElement(options));update=applyToSingletonTag.bind(null,style,styleIndex,false);remove=applyToSingletonTag.bind(null,style,styleIndex,true);}else{style=insertStyleElement(options);update=applyToTag.bind(null,style,options);remove=()=>{removeStyleElement(style);};}update(obj);return function updateStyle(newObj){if(newObj){if(newObj.css===obj.css&&newObj.media===obj.media&&newObj.sourceMap===obj.sourceMap){return;}update(obj=newObj);}else{remove();}};}module.exports=(list,options)=>{options=options||{};// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
// tags it will allow on a page
if(!options.singleton&&typeof options.singleton!=='boolean'){options.singleton=isOldIE();}list=list||[];let lastIdentifiers=modulesToDom(list,options);return function update(newList){newList=newList||[];if(Object.prototype.toString.call(newList)!=='[object Array]'){return;}for(let i=0;i<lastIdentifiers.length;i++){const identifier=lastIdentifiers[i];const index=getIndexByIdentifier(identifier);stylesInDom[index].references--;}const newLastIdentifiers=modulesToDom(newList,options);for(let i=0;i<lastIdentifiers.length;i++){const identifier=lastIdentifiers[i];const index=getIndexByIdentifier(identifier);if(stylesInDom[index].references===0){stylesInDom[index].updater();stylesInDom.splice(index,1);}}lastIdentifiers=newLastIdentifiers;};};
//# sourceMappingURL=injectStylesIntoStyleTag.js.map

/***/ }),

/***/ "./node_modules/next/dist/client/image.js":
/*!************************************************!*\
  !*** ./node_modules/next/dist/client/image.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _slicedToArray = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js");

var _toConsumableArray = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/toConsumableArray */ "./node_modules/@babel/runtime/helpers/toConsumableArray.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports["default"] = Image;

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/objectWithoutPropertiesLoose */ "./node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js"));

var _extends2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/extends */ "./node_modules/@babel/runtime/helpers/extends.js"));

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _head = _interopRequireDefault(__webpack_require__(/*! ../next-server/lib/head */ "./node_modules/next/dist/next-server/lib/head.js"));

var _toBase = __webpack_require__(/*! ../next-server/lib/to-base-64 */ "./node_modules/next/dist/next-server/lib/to-base-64.js");

var _imageConfig = __webpack_require__(/*! ../next-server/server/image-config */ "./node_modules/next/dist/next-server/server/image-config.js");

var _useIntersection = __webpack_require__(/*! ./use-intersection */ "./node_modules/next/dist/client/use-intersection.js");

if (false) {}

var VALID_LOADING_VALUES = ['lazy', 'eager', undefined];
var loaders = new Map([['imgix', imgixLoader], ['cloudinary', cloudinaryLoader], ['akamai', akamaiLoader], ['default', defaultLoader]]);
var VALID_LAYOUT_VALUES = ['fill', 'fixed', 'intrinsic', 'responsive', undefined];

var _ref2 = {"deviceSizes":[640,750,828,1080,1200,1920,2048,3840],"imageSizes":[16,32,48,64,96,128,256,384],"path":"/_next/image","loader":"default","domains":[]} || _imageConfig.imageConfigDefault,
    configDeviceSizes = _ref2.deviceSizes,
    configImageSizes = _ref2.imageSizes,
    configLoader = _ref2.loader,
    configPath = _ref2.path,
    configDomains = _ref2.domains; // sort smallest to largest


var allSizes = [].concat(_toConsumableArray(configDeviceSizes), _toConsumableArray(configImageSizes));
configDeviceSizes.sort(function (a, b) {
  return a - b;
});
allSizes.sort(function (a, b) {
  return a - b;
});

function getWidths(width, layout, sizes) {
  if (sizes && (layout === 'fill' || layout === 'responsive')) {
    // Find all the "vw" percent sizes used in the sizes prop
    var percentSizes = _toConsumableArray(sizes.matchAll(/(^|\s)(1?\d?\d)vw/g)).map(function (m) {
      return parseInt(m[2]);
    });

    if (percentSizes.length) {
      var smallestRatio = Math.min.apply(Math, _toConsumableArray(percentSizes)) * 0.01;
      return {
        widths: allSizes.filter(function (s) {
          return s >= configDeviceSizes[0] * smallestRatio;
        }),
        kind: 'w'
      };
    }

    return {
      widths: allSizes,
      kind: 'w'
    };
  }

  if (typeof width !== 'number' || layout === 'fill' || layout === 'responsive') {
    return {
      widths: configDeviceSizes,
      kind: 'w'
    };
  }

  var widths = _toConsumableArray(new Set( // > This means that most OLED screens that say they are 3x resolution,
  // > are actually 3x in the green color, but only 1.5x in the red and
  // > blue colors. Showing a 3x resolution image in the app vs a 2x
  // > resolution image will be visually the same, though the 3x image
  // > takes significantly more data. Even true 3x resolution screens are
  // > wasteful as the human eye cannot see that level of detail without
  // > something like a magnifying glass.
  // https://blog.twitter.com/engineering/en_us/topics/infrastructure/2019/capping-image-fidelity-on-ultra-high-resolution-devices.html
  [width, width * 2
  /*, width * 3*/
  ].map(function (w) {
    return allSizes.find(function (p) {
      return p >= w;
    }) || allSizes[allSizes.length - 1];
  })));

  return {
    widths: widths,
    kind: 'x'
  };
}

function generateImgAttrs(_ref3) {
  var src = _ref3.src,
      unoptimized = _ref3.unoptimized,
      layout = _ref3.layout,
      width = _ref3.width,
      quality = _ref3.quality,
      sizes = _ref3.sizes,
      loader = _ref3.loader;

  if (unoptimized) {
    return {
      src: src,
      srcSet: undefined,
      sizes: undefined
    };
  }

  var _getWidths = getWidths(width, layout, sizes),
      widths = _getWidths.widths,
      kind = _getWidths.kind;

  var last = widths.length - 1;
  return {
    sizes: !sizes && kind === 'w' ? '100vw' : sizes,
    srcSet: widths.map(function (w, i) {
      return "".concat(loader({
        src: src,
        quality: quality,
        width: w
      }), " ").concat(kind === 'w' ? w : i + 1).concat(kind);
    }).join(', '),
    // It's intended to keep `src` the last attribute because React updates
    // attributes in order. If we keep `src` the first one, Safari will
    // immediately start to fetch `src`, before `sizes` and `srcSet` are even
    // updated by React. That causes multiple unnecessary requests if `srcSet`
    // and `sizes` are defined.
    // This bug cannot be reproduced in Chrome or Firefox.
    src: loader({
      src: src,
      quality: quality,
      width: widths[last]
    })
  };
}

function getInt(x) {
  if (typeof x === 'number') {
    return x;
  }

  if (typeof x === 'string') {
    return parseInt(x, 10);
  }

  return undefined;
}

function defaultImageLoader(loaderProps) {
  var load = loaders.get(configLoader);

  if (load) {
    return load((0, _extends2["default"])({
      root: configPath
    }, loaderProps));
  }

  throw new Error("Unknown \"loader\" found in \"next.config.js\". Expected: ".concat(_imageConfig.VALID_LOADERS.join(', '), ". Received: ").concat(configLoader));
}

function Image(_ref) {
  var src = _ref.src,
      sizes = _ref.sizes,
      _ref$unoptimized = _ref.unoptimized,
      unoptimized = _ref$unoptimized === void 0 ? false : _ref$unoptimized,
      _ref$priority = _ref.priority,
      priority = _ref$priority === void 0 ? false : _ref$priority,
      loading = _ref.loading,
      className = _ref.className,
      quality = _ref.quality,
      width = _ref.width,
      height = _ref.height,
      objectFit = _ref.objectFit,
      objectPosition = _ref.objectPosition,
      _ref$loader = _ref.loader,
      loader = _ref$loader === void 0 ? defaultImageLoader : _ref$loader,
      all = (0, _objectWithoutPropertiesLoose2["default"])(_ref, ["src", "sizes", "unoptimized", "priority", "loading", "className", "quality", "width", "height", "objectFit", "objectPosition", "loader"]);
  var rest = all;
  var layout = sizes ? 'responsive' : 'intrinsic';
  var unsized = false;

  if ('unsized' in rest) {
    unsized = Boolean(rest.unsized); // Remove property so it's not spread into image:

    delete rest['unsized'];
  } else if ('layout' in rest) {
    // Override default layout if the user specified one:
    if (rest.layout) layout = rest.layout; // Remove property so it's not spread into image:

    delete rest['layout'];
  }

  if (true) {
    if (!src) {
      throw new Error("Image is missing required \"src\" property. Make sure you pass \"src\" in props to the `next/image` component. Received: ".concat(JSON.stringify({
        width: width,
        height: height,
        quality: quality
      })));
    }

    if (!VALID_LAYOUT_VALUES.includes(layout)) {
      throw new Error("Image with src \"".concat(src, "\" has invalid \"layout\" property. Provided \"").concat(layout, "\" should be one of ").concat(VALID_LAYOUT_VALUES.map(String).join(','), "."));
    }

    if (!VALID_LOADING_VALUES.includes(loading)) {
      throw new Error("Image with src \"".concat(src, "\" has invalid \"loading\" property. Provided \"").concat(loading, "\" should be one of ").concat(VALID_LOADING_VALUES.map(String).join(','), "."));
    }

    if (priority && loading === 'lazy') {
      throw new Error("Image with src \"".concat(src, "\" has both \"priority\" and \"loading='lazy'\" properties. Only one should be used."));
    }

    if (unsized) {
      throw new Error("Image with src \"".concat(src, "\" has deprecated \"unsized\" property, which was removed in favor of the \"layout='fill'\" property"));
    }
  }

  var isLazy = !priority && (loading === 'lazy' || typeof loading === 'undefined');

  if (src && src.startsWith('data:')) {
    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs
    unoptimized = true;
    isLazy = false;
  }

  var _ref4 = (0, _useIntersection.useIntersection)({
    rootMargin: '200px',
    disabled: !isLazy
  }),
      _ref5 = _slicedToArray(_ref4, 2),
      setRef = _ref5[0],
      isIntersected = _ref5[1];

  var isVisible = !isLazy || isIntersected;
  var widthInt = getInt(width);
  var heightInt = getInt(height);
  var qualityInt = getInt(quality);
  var wrapperStyle;
  var sizerStyle;
  var sizerSvg;
  var imgStyle = {
    visibility: isVisible ? 'inherit' : 'hidden',
    position: 'absolute',
    top: 0,
    left: 0,
    bottom: 0,
    right: 0,
    boxSizing: 'border-box',
    padding: 0,
    border: 'none',
    margin: 'auto',
    display: 'block',
    width: 0,
    height: 0,
    minWidth: '100%',
    maxWidth: '100%',
    minHeight: '100%',
    maxHeight: '100%',
    objectFit: objectFit,
    objectPosition: objectPosition
  };

  if (typeof widthInt !== 'undefined' && typeof heightInt !== 'undefined' && layout !== 'fill') {
    // <Image src="i.png" width="100" height="100" />
    var quotient = heightInt / widthInt;
    var paddingTop = isNaN(quotient) ? '100%' : "".concat(quotient * 100, "%");

    if (layout === 'responsive') {
      // <Image src="i.png" width="100" height="100" layout="responsive" />
      wrapperStyle = {
        display: 'block',
        overflow: 'hidden',
        position: 'relative',
        boxSizing: 'border-box',
        margin: 0
      };
      sizerStyle = {
        display: 'block',
        boxSizing: 'border-box',
        paddingTop: paddingTop
      };
    } else if (layout === 'intrinsic') {
      // <Image src="i.png" width="100" height="100" layout="intrinsic" />
      wrapperStyle = {
        display: 'inline-block',
        maxWidth: '100%',
        overflow: 'hidden',
        position: 'relative',
        boxSizing: 'border-box',
        margin: 0
      };
      sizerStyle = {
        boxSizing: 'border-box',
        display: 'block',
        maxWidth: '100%'
      };
      sizerSvg = "<svg width=\"".concat(widthInt, "\" height=\"").concat(heightInt, "\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"/>");
    } else if (layout === 'fixed') {
      // <Image src="i.png" width="100" height="100" layout="fixed" />
      wrapperStyle = {
        overflow: 'hidden',
        boxSizing: 'border-box',
        display: 'inline-block',
        position: 'relative',
        width: widthInt,
        height: heightInt
      };
    }
  } else if (typeof widthInt === 'undefined' && typeof heightInt === 'undefined' && layout === 'fill') {
    // <Image src="i.png" layout="fill" />
    wrapperStyle = {
      display: 'block',
      overflow: 'hidden',
      position: 'absolute',
      top: 0,
      left: 0,
      bottom: 0,
      right: 0,
      boxSizing: 'border-box',
      margin: 0
    };
  } else {
    // <Image src="i.png" />
    if (true) {
      throw new Error("Image with src \"".concat(src, "\" must use \"width\" and \"height\" properties or \"layout='fill'\" property."));
    }
  }

  var imgAttributes = {
    src: 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7',
    srcSet: undefined,
    sizes: undefined
  };

  if (isVisible) {
    imgAttributes = generateImgAttrs({
      src: src,
      unoptimized: unoptimized,
      layout: layout,
      width: widthInt,
      quality: qualityInt,
      sizes: sizes,
      loader: loader
    });
  }

  if (unsized) {
    wrapperStyle = undefined;
    sizerStyle = undefined;
    imgStyle = undefined;
  }

  return /*#__PURE__*/_react["default"].createElement("div", {
    style: wrapperStyle
  }, sizerStyle ? /*#__PURE__*/_react["default"].createElement("div", {
    style: sizerStyle
  }, sizerSvg ? /*#__PURE__*/_react["default"].createElement("img", {
    style: {
      maxWidth: '100%',
      display: 'block',
      margin: 0,
      border: 'none',
      padding: 0
    },
    alt: "",
    "aria-hidden": true,
    role: "presentation",
    src: "data:image/svg+xml;base64,".concat((0, _toBase.toBase64)(sizerSvg))
  }) : null) : null, /*#__PURE__*/_react["default"].createElement("img", Object.assign({}, rest, imgAttributes, {
    decoding: "async",
    className: className,
    ref: setRef,
    style: imgStyle
  })), priority ?
  /*#__PURE__*/
  // Note how we omit the `href` attribute, as it would only be relevant
  // for browsers that do not support `imagesrcset`, and in those cases
  // it would likely cause the incorrect image to be preloaded.
  //
  // https://html.spec.whatwg.org/multipage/semantics.html#attr-link-imagesrcset
  _react["default"].createElement(_head["default"], null, /*#__PURE__*/_react["default"].createElement("link", {
    key: '__nimg-' + imgAttributes.src + imgAttributes.srcSet + imgAttributes.sizes,
    rel: "preload",
    as: "image",
    href: imgAttributes.srcSet ? undefined : imgAttributes.src // @ts-ignore: imagesrcset is not yet in the link element type
    ,
    imagesrcset: imgAttributes.srcSet // @ts-ignore: imagesizes is not yet in the link element type
    ,
    imagesizes: imgAttributes.sizes
  })) : null);
} //BUILT IN LOADERS


_c = Image;

function normalizeSrc(src) {
  return src[0] === '/' ? src.slice(1) : src;
}

function imgixLoader(_ref6) {
  var root = _ref6.root,
      src = _ref6.src,
      width = _ref6.width,
      quality = _ref6.quality;
  // Demo: https://static.imgix.net/daisy.png?format=auto&fit=max&w=300
  var params = ['auto=format', 'fit=max', 'w=' + width];
  var paramsString = '';

  if (quality) {
    params.push('q=' + quality);
  }

  if (params.length) {
    paramsString = '?' + params.join('&');
  }

  return "".concat(root).concat(normalizeSrc(src)).concat(paramsString);
}

function akamaiLoader(_ref7) {
  var root = _ref7.root,
      src = _ref7.src,
      width = _ref7.width;
  return "".concat(root).concat(normalizeSrc(src), "?imwidth=").concat(width);
}

function cloudinaryLoader(_ref8) {
  var root = _ref8.root,
      src = _ref8.src,
      width = _ref8.width,
      quality = _ref8.quality;
  // Demo: https://res.cloudinary.com/demo/image/upload/w_300,c_limit,q_auto/turtles.jpg
  var params = ['f_auto', 'c_limit', 'w_' + width, 'q_' + (quality || 'auto')];
  var paramsString = params.join(',') + '/';
  return "".concat(root).concat(paramsString).concat(normalizeSrc(src));
}

function defaultLoader(_ref9) {
  var root = _ref9.root,
      src = _ref9.src,
      width = _ref9.width,
      quality = _ref9.quality;

  if (true) {
    var missingValues = []; // these should always be provided but make sure they are

    if (!src) missingValues.push('src');
    if (!width) missingValues.push('width');

    if (missingValues.length > 0) {
      throw new Error("Next Image Optimization requires ".concat(missingValues.join(', '), " to be provided. Make sure you pass them as props to the `next/image` component. Received: ").concat(JSON.stringify({
        src: src,
        width: width,
        quality: quality
      })));
    }

    if (src.startsWith('//')) {
      throw new Error("Failed to parse src \"".concat(src, "\" on `next/image`, protocol-relative URL (//) must be changed to an absolute URL (http:// or https://)"));
    }

    if (!src.startsWith('/') && configDomains) {
      var parsedSrc;

      try {
        parsedSrc = new URL(src);
      } catch (err) {
        console.error(err);
        throw new Error("Failed to parse src \"".concat(src, "\" on `next/image`, if using relative image it must start with a leading slash \"/\" or be an absolute URL (http:// or https://)"));
      }

      if (!configDomains.includes(parsedSrc.hostname)) {
        throw new Error("Invalid src prop (".concat(src, ") on `next/image`, hostname \"").concat(parsedSrc.hostname, "\" is not configured under images in your `next.config.js`\n") + "See more info: https://err.sh/next.js/next-image-unconfigured-host");
      }
    }
  }

  return "".concat(root, "?url=").concat(encodeURIComponent(src), "&w=").concat(width, "&q=").concat(quality || 75);
}

var _c;

$RefreshReg$(_c, "Image");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/request-idle-callback.js":
/*!****************************************************************!*\
  !*** ./node_modules/next/dist/client/request-idle-callback.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.cancelIdleCallback = exports.requestIdleCallback = void 0;

var requestIdleCallback = typeof self !== 'undefined' && self.requestIdleCallback || function (cb) {
  var start = Date.now();
  return setTimeout(function () {
    cb({
      didTimeout: false,
      timeRemaining: function timeRemaining() {
        return Math.max(0, 50 - (Date.now() - start));
      }
    });
  }, 1);
};

exports.requestIdleCallback = requestIdleCallback;

var cancelIdleCallback = typeof self !== 'undefined' && self.cancelIdleCallback || function (id) {
  return clearTimeout(id);
};

exports.cancelIdleCallback = cancelIdleCallback;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/use-intersection.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/client/use-intersection.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _slicedToArray = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js");

exports.__esModule = true;
exports.useIntersection = useIntersection;

var _react = __webpack_require__(/*! react */ "./node_modules/react/index.js");

var _requestIdleCallback = __webpack_require__(/*! ./request-idle-callback */ "./node_modules/next/dist/client/request-idle-callback.js");

var hasIntersectionObserver = typeof IntersectionObserver !== 'undefined';

function useIntersection(_ref) {
  var rootMargin = _ref.rootMargin,
      disabled = _ref.disabled;
  var isDisabled = disabled || !hasIntersectionObserver;
  var unobserve = (0, _react.useRef)();

  var _ref2 = (0, _react.useState)(false),
      _ref3 = _slicedToArray(_ref2, 2),
      visible = _ref3[0],
      setVisible = _ref3[1];

  var setRef = (0, _react.useCallback)(function (el) {
    if (unobserve.current) {
      unobserve.current();
      unobserve.current = undefined;
    }

    if (isDisabled || visible) return;

    if (el && el.tagName) {
      unobserve.current = observe(el, function (isVisible) {
        return isVisible && setVisible(isVisible);
      }, {
        rootMargin: rootMargin
      });
    }
  }, [isDisabled, rootMargin, visible]);
  (0, _react.useEffect)(function () {
    if (!hasIntersectionObserver) {
      if (!visible) {
        var idleCallback = (0, _requestIdleCallback.requestIdleCallback)(function () {
          return setVisible(true);
        });
        return function () {
          return (0, _requestIdleCallback.cancelIdleCallback)(idleCallback);
        };
      }
    }
  }, [visible]);
  return [setRef, visible];
}

function observe(element, callback, options) {
  var _createObserver = createObserver(options),
      id = _createObserver.id,
      observer = _createObserver.observer,
      elements = _createObserver.elements;

  elements.set(element, callback);
  observer.observe(element);
  return function unobserve() {
    elements["delete"](element);
    observer.unobserve(element); // Destroy observer when there's nothing left to watch:

    if (elements.size === 0) {
      observer.disconnect();
      observers["delete"](id);
    }
  };
}

var observers = new Map();

function createObserver(options) {
  var id = options.rootMargin || '';
  var instance = observers.get(id);

  if (instance) {
    return instance;
  }

  var elements = new Map();
  var observer = new IntersectionObserver(function (entries) {
    entries.forEach(function (entry) {
      var callback = elements.get(entry.target);
      var isVisible = entry.isIntersecting || entry.intersectionRatio > 0;

      if (callback && isVisible) {
        callback(isVisible);
      }
    });
  }, options);
  observers.set(id, instance = {
    id: id,
    observer: observer,
    elements: elements
  });
  return instance;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/compiled/css-loader/api.js":
/*!***********************************!*\
  !*** (webpack)/css-loader/api.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__dirname) {module.exports=function(){"use strict";var n={762:function(n){n.exports=function(n){var t=[];t.toString=function toString(){return this.map(function(t){var r=cssWithMappingToString(t,n);if(t[2]){return"@media ".concat(t[2]," {").concat(r,"}")}return r}).join("")};t.i=function(n,r,o){if(typeof n==="string"){n=[[null,n,""]]}var e={};if(o){for(var a=0;a<this.length;a++){var c=this[a][0];if(c!=null){e[c]=true}}}for(var i=0;i<n.length;i++){var u=[].concat(n[i]);if(o&&e[u[0]]){continue}if(r){if(!u[2]){u[2]=r}else{u[2]="".concat(r," and ").concat(u[2])}}t.push(u)}};return t};function cssWithMappingToString(n,t){var r=n[1]||"";var o=n[3];if(!o){return r}if(t&&typeof btoa==="function"){var e=toComment(o);var a=o.sources.map(function(n){return"/*# sourceURL=".concat(o.sourceRoot||"").concat(n," */")});return[r].concat(a).concat([e]).join("\n")}return[r].join("\n")}function toComment(n){var t=btoa(unescape(encodeURIComponent(JSON.stringify(n))));var r="sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(t);return"/*# ".concat(r," */")}}};var t={};function __nccwpck_require__(r){if(t[r]){return t[r].exports}var o=t[r]={exports:{}};var e=true;try{n[r](o,o.exports,__nccwpck_require__);e=false}finally{if(e)delete t[r]}return o.exports}__nccwpck_require__.ab=__dirname+"/";return __nccwpck_require__(762)}();
/* WEBPACK VAR INJECTION */}.call(this, "/"))

/***/ }),

/***/ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./node_modules/next/dist/compiled/resolve-url-loader/index.js?!./node_modules/next/dist/compiled/sass-loader/cjs.js?!./components/FilmGrainFilter/FilmGrainFilter.module.scss":
/*!**************************************************************************************************************************************************************************************************************************************************************!*\
  !*** (webpack)/css-loader/cjs.js??ref--5-oneOf-3-1!(webpack)/postcss-loader/cjs.js??ref--5-oneOf-3-2!(webpack)/resolve-url-loader??ref--5-oneOf-3-3!(webpack)/sass-loader/cjs.js??ref--5-oneOf-3-4!./components/FilmGrainFilter/FilmGrainFilter.module.scss ***!
  \**************************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../node_modules/next/dist/compiled/css-loader/api.js */ "./node_modules/next/dist/compiled/css-loader/api.js");
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);
// Module
___CSS_LOADER_EXPORT___.push([module.i, "/**************************************************\r\nVARS File\r\n\r\nDescription:\tStore SCSS vars here\r\n\r\n\r\n**************************************************/\n/***** Color Variables *****/\n/***** Named Colors *****/\n/***** Fonts *****/\n/***** Font Sizes *****/\n/***** Letter Spacing *****/\n/***** Content Widths *****/\n/***** Transition Timings *****/\n/***** Shadows *****/\n/* source: https://brumm.af/shadows */\n/**************************************************\r\nMIXINS File\r\n\r\nDescription:\tStore SCSS mixins here\r\n\r\nCall: @include backgroundStandard;\r\n\r\n**************************************************/\n/**************************************************\r\nNecro Cult Zine Component\r\n\r\n\r\nComponent Name: \tFilmGrainFilter\r\nDescription:\t\tVHS style grain filter that overlays it's parent element.\r\n\r\n\r\n**************************************************/\n/***** FILM GRAIN OVERLAY *****/\n.FilmGrainFilter_filmGrainFilter__fIjhy:after {\n  content: \"\";\n  display: block;\n  height: 400%;\n  left: -100%;\n  position: fixed;\n  top: -150%;\n  width: 400%;\n  z-index: 10000;\n  pointer-events: none;\n  background: url(\"data:image/png;base64,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\");\n  background-size: 6%;\n  animation: FilmGrainFilter_grain__3p6d_ 5s steps(10) infinite; }\n\n@keyframes FilmGrainFilter_grain__3p6d_ {\n  0%, 100% {\n    transform: translate(0, 0); }\n  10% {\n    transform: translate(-5%, -10%); }\n  20% {\n    transform: translate(-15%, 5%); }\n  30% {\n    transform: translate(7%, -25%); }\n  40% {\n    transform: translate(-5%, 25%); }\n  50% {\n    transform: translate(-15%, 10%); }\n  60% {\n    transform: translate(15%, 0%); }\n  70% {\n    transform: translate(0%, 15%); }\n  80% {\n    transform: translate(3%, 35%); }\n  90% {\n    transform: translate(-10%, 10%); } }\n", "",{"version":3,"sources":["webpack://../../styles/vars.scss","webpack://FilmGrainFilter.module.scss","webpack://../../styles/mixins.scss"],"names":[],"mappings":"AAAA;;;;;;kDCMkD;ADGlD,4BAAA;AAUC,yBAAA;AASD,kBAAA;AAKA,uBAAA;AAMA,2BAAA;AAIA,2BAAA;AAMA,+BAAA;AAMA,oBAAA;AAEC,qCAAA;AEzDD;;;;;;;kDDuBkD;AAnBlD;;;;;;;;kDA4BkD;AAlBlD,+BAAA;AAEC;EACC,WAAW;EACX,cAAc;EACd,YAAY;EACZ,WAAW;EACX,eAAe;EACf,UAAU;EACV,WAAW;EACX,cAAc;EACd,oBAAoB;EACpB,qv2EAAqv2E;EACrv2E,mBAAmB;EACnB,6DAAsC,EAAA;;AAGvC;EACC;IACC,0BAA0B,EAAA;EAE3B;IACC,+BAA+B,EAAA;EAEhC;IACC,8BAA8B,EAAA;EAE/B;IACC,8BAA8B,EAAA;EAE/B;IACC,8BAA8B,EAAA;EAE/B;IACC,+BAA+B,EAAA;EAEhC;IACC,6BAA6B,EAAA;EAE9B;IACC,6BAA6B,EAAA;EAE9B;IACC,6BAA6B,EAAA;EAE9B;IACC,+BAA+B,EAAA,EAAA","sourcesContent":["/**************************************************\r\nVARS File\r\n\r\nDescription:\tStore SCSS vars here\r\n\r\n\r\n**************************************************/\r\n\r\n\r\n/***** Color Variables *****/\r\n\t$black: \t\t#212121;\r\n\t$white: \t\t#fafafa;\r\n\t$grey_1:\t\t#ececec;\r\n\t$grey_2:\t\t#3e3e3e;\r\n\r\n\t$red: \t\t\t#fb0000;\r\n\t\r\n\t$nasa_grey:\t#D1D3D4;\r\n\r\n\t/***** Named Colors *****/\r\n\t\t$primary_color:\t\t$black;\r\n\t\t$secondary_color:\t\t$white;\r\n\r\n\t\t$background_color:\t$white;\r\n\t\t$text_color:\t\t\t$black;\r\n\t\t$accent_color:\t\t$grey_1;\r\n\r\n\r\n/***** Fonts *****/\r\n\t$font_body:\t\t\"MyUnderwood\";\r\n\t$font_display:\t\"AncientMedium\";\r\n\t$font_alt:\t\t\t\"ImpactLabel\";\r\n\r\n/***** Font Sizes *****/\r\n\t$font_size_heading:\t65px;\r\n\t$font_size_subhead:\t36px;\r\n\t$font_size_body:\t\t20px;\r\n\t$font_size_detail:\t16px;\r\n\r\n/***** Letter Spacing *****/\r\n\t$letterSpacingWide:\t\t0.035em;\r\n\t$letterSpacingNormal:\t0.035em;\r\n\r\n/***** Content Widths *****/\r\n\t$content_width_s: \t650px;\r\n\t$content_width_m: \t920px;\r\n\t$content_width_l: \t1450px;\r\n\r\n\r\n/***** Transition Timings *****/\r\n\t$transition_fast:\t\t0.1s ease-in-out;\r\n\t$transition_medium:\t0.25s ease-in-out;\r\n\t$transition_slow:\t\t0.5s ease-in-out;\r\n\r\n\r\n/***** Shadows *****/\r\n\r\n\t/* source: https://brumm.af/shadows */\r\n\t$nice_shadow:\r\n\t\t0 2.8px 2.2px rgba(0, 0, 0, 0.02),\r\n\t\t0 6.7px 5.3px rgba(0, 0, 0, 0.028),\r\n\t\t0 12.5px 10px rgba(0, 0, 0, 0.035),\r\n\t\t0 22.3px 17.9px rgba(0, 0, 0, 0.042),\r\n\t\t0 41.8px 33.4px rgba(0, 0, 0, 0.05),\r\n\t\t0 100px 80px rgba(0, 0, 0, 0.07);\r\n\r\n\r\n\t$text-shadow-red:\r\n\t\t1px 1px $red, \r\n\t\t2px 2px $red, \r\n\t\t3px 3px $red, \r\n\t\t4px 4px $red, \r\n\t\t5px 5px $red;\r\n\t  \r\n\t$text-glow-red:\r\n\t\t0 0 1vw $red, \r\n\t\t0 0 3vw $red, \r\n\t\t0 0 10vw $red, \r\n\t\t0 0 10vw $red, \r\n\t\t0 0 .4vw $red, \r\n\t\t.25vw .25vw .1vw #806914;\r\n","/**************************************************\r\nVARS File\r\n\r\nDescription:\tStore SCSS vars here\r\n\r\n\r\n**************************************************/\n/***** Color Variables *****/\n/***** Named Colors *****/\n/***** Fonts *****/\n/***** Font Sizes *****/\n/***** Letter Spacing *****/\n/***** Content Widths *****/\n/***** Transition Timings *****/\n/***** Shadows *****/\n/* source: https://brumm.af/shadows */\n/**************************************************\r\nMIXINS File\r\n\r\nDescription:\tStore SCSS mixins here\r\n\r\nCall: @include backgroundStandard;\r\n\r\n**************************************************/\n/**************************************************\r\nNecro Cult Zine Component\r\n\r\n\r\nComponent Name: \tFilmGrainFilter\r\nDescription:\t\tVHS style grain filter that overlays it's parent element.\r\n\r\n\r\n**************************************************/\n/***** FILM GRAIN OVERLAY *****/\n.filmGrainFilter:after {\n  content: \"\";\n  display: block;\n  height: 400%;\n  left: -100%;\n  position: fixed;\n  top: -150%;\n  width: 400%;\n  z-index: 10000;\n  pointer-events: none;\n  background: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAV4AAAFeBAMAAAA/BWopAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAwUExURQcHBwkJCQoKChERESEhIRMTEwkJCUdHRwgICI2NjQ8PDz09PQoKCi0tLeTk5AgICJ7lhQgAAAAQdFJOUw0KEgcRBgsEEAEOCRUNAxoEQZj/AAAgAElEQVR42hS7cVRa557vvQEFsk16QKIYkvbglhBmS0YQZSs0jiFUHdRTrTU0yTl5UVQsNBnIDuwAEy6ix/iinTbjsY7terM2GwS60cSIgRSqJyFOjq+lY07qSTra5KbXkzCpb13nZrrmntWbtfLu+z9rsfezn9/v+f6+388DLGRiITTsaRtbvr9iZCK7i8VqrArSMdhFqEER5pJ7l+hCRRw1ZDhfTBapn+rqHJB0hbH3BqOQEXx3s49nDqogaICd9zg1VbWnvr3LKk6T0aTeBQ1U4ZrBdoFf3xFnk0N+uW4WEwAMe6feVlRSqjyzfuwpy6EsnyTI2p4Nno1lT4yV5zV5E1qTwiERpXQigyUlPH2TodL2Lc3ZlxTYB/n08kQeMD8yuNvYHbGPrWoOvZu0jgjKUKdMu6chwXheCEIMQXOO/ta41mOFiAhKapA21la2db3s3L7OEq+xZBk7nSgmIAj3FzYu6D9Yjvyzl8PYUWlNk4K1v/yLN69e3XIMm+wEPvuqmwMP6WvfufV8Yd+ngzOH8+q2z3owbMufXoCMID1Y+FVu63CuQjAwxKzW2/zhk0Ld1qNNE6Yqcy2ngnP5WzrsF4dkUOxLwNxeUHFrr46Frmc8H2B007h/BMvTkgTruqcS14gUl1xQ6V4ydlN4USOqHwsc92MjQ5YNUpvEuGhU+qJFF+s20Tr2W68Wkr6Hxy6zoSgD6QglL2RASIhGNx3lSvKh8rMyjFi5EbIUL7f78ttGCv+qianBAqWGh1ckU5ZQE4Pr1gJwNap6TaV5DRxn2c0S3XEaPu51N2BY7n6y9F0tkDQvVb7WDbDtpBa85RMrwdVtH0YfTQ3hSijGVYULtqJFJ+HnihmJhDT2CHHLGQ3MjqE+hlGmvg9pNxFmzgxpsnCB3AlyDQnGI01zB6noh0ZI1jgNWchwmSNc88PJBAGVzaWOYb4+J2QA69GKBq6vg2TqFCmc0BHl98MCbbhkIGzVggPymPXDKCEuwFDFdcE9AMQXhOroa1vxxRvFoD99YzG+iKSA0D1o6dOf6X5IB6e8cYM0KzItwKftyEKzC/a4WJPnV7gkzvgft0vguhTO7d0OefmoWzJmMX847LEKL0K64i9svvqogUwTzebQoErjN5f/aLJ9qDk2yRaav5hCpRLhmdX2dGBnEuT4xLmK1d4U9qyWRI6QLY93f7UzFtUGXSKSHXtQoFqxZZfN0Al+5TDflqCVkNCfSqCIw49wPinjejaW6I/RYqBgbGVoC6pHdZoVTBU6eCDz0e3xg27Vbay4K4QN9BigffIOqbCY7OtZbsbeY/SUkoYRbjPa5agH+FvFj7pjhY2Fse24o3nx7Zca6Cg2Ip2O/Dmry18QBUInvvyVvfYALDcEzw1anrsdL1nCrZlVPWbg4MzaKknLoW2Y7873yMJ5fHkIVt/jcQ3RZgwFfdBBawBTSy3YydLPnHmQkfAje49NgnFzANjkxIj1FRLThTIMt48mj3ZPtx06j9I8dF2ofeVMKoPzr+zO1BPHftQZq1VRmB3VQgp4MenQVceeC9KEfyiYh+ycktU/6L61OFKEFr1nSu+VZoJzI0FFe0V5ByIzWf1BaxdjHCz5CTA+GeIWYTKcrX0r5Z8pTQDFaL67z3ST9WkmuJ1FJJvK4et9gBkybfM6uCRD3tFVks6QBuF8Aa5QFJO+DOB1bglabgsWdcyQJC58933BJjZzUKa37ZdKcKV0n9K3FvGoINhnxOzjft7MwTe92iYuJH2c8CMBLIpqpLfmYjlMJdzdOPmFnYulknaF1Z/waQHAhM2skDReescqAVg10+dWso3Xlk622gfbt0pVmlaFIYpLkDkyuLtssvvwP/58wrVmkuqwkGaY/6kwJ0P6YYSQ1LlWW16cLmSdb5q2zs5JoAww0PsJgs/hkB/i8nfnqx5AMCA4ivXAs447bm7B89AvbhMSvjuInRQvYJK6HDojlg1pq+dbtYQu8hkZYEPLZn5uobXsfONkKux0aDSQyb0059boANA3bFdB07vxfAHqXaPNNvnBKGDxJNLmGzR9nyJubrbh6HVwYOb2FuTthkFtPYDP6IdRoPa8EFx7fz5jXMgaQ6y3M4MjdpbctYwRx3p0AFxk7zC+m0+Hx7iv1SAlDAImlQ076/2ji39wKF5PsolgSrhfYXzuutudf52XbmsNU8+79I8iCJcyONXGlBQGIYNGFzzH4nZ/w5sLiVoik0lZerZi1CoNomYdcg0qBScG2GpIG+Ykyb64xRpQ4gjaVSwos/ppoO460FX4NV4yfTPD7+AC3ABmVsxthKReMtyZ6Av5jRV9YUsqYt9u7YfqFTFAi71/HPUtWXU+zqjTXsKv0sXbDuUaXEGi1cxt+a3qoBVDKo8KCtQ4sWrP28h7XALei7PO6aBmjeAw4mmT4oZXQ02kuJIv6kFC38iCf46MezmiZEU5trDJlkxfuQ9BEpQ1tQ2JcCQXKhEZU3zB4U0bLADF9KEVQvgjf3usETi5y0Hsw5RLhIwRStTOBOQVZVfsyA6RgmCsBwuFFcjWmt+HBAD+JBPZhhUFDqizhYVy2SGJ6fKhjyHNgJreTP8a2X3wnWHPmw+tUJy+UvGXwsfuLjrEcnvQxT6NsA2uX7KKbQGSd5N8MR+pPmm6+FBVXxMrWY3Wb/i0nzuM70L4a8+iedJBV1DQeK0Ma5fqhhLlMtp+NbsJyLg1yb3H+jW72sK17UhHHM3LgKwm66WSfGfFHbRlwJNSm/mLXr0KemgtPaWzNFnLSnCgGmU6VaJvqs+Lr3xQigIASERUQnXJqjRGD858jY1NW6Had5asXlBHtvxkRqizq6kA2eKKMAHVfaBgzbQDjnfOAaJHiKLkQ3WcEKvCcq1IqykaMqIS9X1tKypakAjdQCjywSDK7RHuT8RkEE0pUrFEnrkdQQHwwUHz+vvWiIuBFjf58mUA0aAfl0bG03NhLUI/sY7zSuCAndahgY2fvTUTBcjrXMwHNed805jKm6OzwicZGulraPCjVXMRGE1Ceo80cjIO1O0+dpxcD8p7J6hNdeKH1Zd6xB04NeKl56uyvYJh7nFWbqEJuvNE2uiAneeWNRASPJd8FXHpQjRtP+6vdWhn/0gKGFahPm1lrh1VwZ++z+ZjqBec/rOQ/O//VnXoHC3myY2V2b765cGpKqGtCGuDYKSS35enE8RAlg0hST7KC4GA2O0H8H5/wo8DvsiOCn85eRLCuwp23PW/+1yg2kfwp+iHZSTXc89WwPn2DQOWy5GsyX/4X5UvwRGS2HPszdItKcL20XCzpSRy4Pb3TH3Nyvu/y+D3G4pO8l55cQyTgVov38Ufa74JQVdVErAJ9GUYqPDjB1l/bWGm6URSFpLuqvzXy7wbAn0UgnkYxvvvP83cERRhSv7fXX3uSJ570RXAZK3f+oMoDwHI3Fh5O+nzs7VrOiNyMQAruoGYHEl6SNU0qco/TiLs4QQJbOpqyqMJXuvO+ThZpHjzD5++GsObfMiIRtz5Qa+3G5AA1SVv7S5V1U7SJchJ3f45kgnSCIihOB7lCYRYf21J8AOc/UAmgcKcIW5AQX65Cu99eO0nAqm2h3TIkW864tVKvSrG5HVivAW4+5Bq/5KM9U4szUG+yxqHeo+0fgusYJ05oAS79qvLXkI4r3sVVG2+0zhJhycBZIKSA+JuXRRSa2LfctPXo1qtBoYs9xuw368+oA9cbBh/OVOrJZHdPwNB10izCoTen1R5yQcEa4IuxMzh9qRs5EP8x0yt+dqq6ZN6mxhTg1C+m1SAeDrNtftiobfvJj+x7L71elh+ggjz4lsWORfjqnaNDx7YZ/dwnybVi41zzC+6qXYp8eGa4XSU7JCy5r4HCsEGeXzOD5uqNCNk+B9ud1W95XTt84FIyEJcF3/0ImmVqEw2Bh2x9OCxeSGjUOzQ6jXCHDRyokcDkEyiLDdDlZfWdFyNoKuVL52uJK0mxn5DFXSQ68JqzMFXksnqC0LBinS5z4cpsJZSmbcKBpl9ZpIpo8QvYtMM1c9ir295976iZ4cZHxRx+0s/k3hPY7m2XR/AoGjzgwycwuj5cptfhwH0qDgRNkNMExonMo/ygiMC0nJfmB3Zd1IXUuT/YuUb1QiOAHZuR1A1JxQUXS/wXj6MPWLz2MOIowk3WSEhtnvFMmdUpJOoPRN9pT/QIOkjoWMlYpR4RM7GEZQ+rDe+syInoTzIi7jT/UKOaF2H8+hwX5E5z0RnueeG8BALlYfC2Z6msFkzUJOBXbeKOsCCtoEojwM92C3U5dEEpdVub7YPCG1ABRK/SDFbh6myj1hPiQFqudZgHc/xMsY7ta6GmsBSVPjJF1Wr8kUJ0/N9DLfBmztvCjnhzUklE3FERca9Qk8OcTEeuoxEaUhekYFY94e0gOj6kKlyWHNwXsIDNyCJ84LQDcWSrhWsj9uj68O5FWVbJ4Zusgrf2kHxtKAM4/REzvTVoSmo9Hd3oubIVGF2pbipN6fSgRJLNyySwad7ImNSALbBIaooVVLTLEIAulkRbe8tSo8ab25ITT2zGpE0M/rmV1hV5IcX1T3S1XBbswEfa7ZfGx74QKh3g4kvqvzG0JmGzlkC3sARW8AHSEW3pjhY1cN4JSuMYY5SDcvhC9Ur0GurR7GP6p4I7cfQlfNCy+nvTN+fvqklzZ//P2HV461wnjuzh+0LmHkp/fa0zOiQw9Vq9Tp27HzrNqtH2ogp9GgT3y0FyAl4/xwQZ0O6IZwoWtwcipIWAX8TDWlDtSEzlCVED8/93Fl8b2MVBRabRKEBkpSKLW83jFbxWFtRQVgxh+9f/KZzr0gaNudfLvVxJCQTaePZPO09yQ2Lx5af50R9ZlFBPxTWdX5k6TMqy6pKPxUa0cSVVNgh7mY2qDMLnztiqbkVc9bMMOtdjDinc7QyAL6R60vbvv5RiyG7JZYkt3bLR9MvAiVo6AubCGp91AJCQ8mdnIyQuFdOb356GOjzeC97oTCIyTTeNyq1rIv5UzVDED6ikpBhNk5TTMbcUY7voUOH+Z32k81jZedKP/0LNevgPx5ryzycVJUvrkN88oTbbVrgQjpN42S/l/2tULH+oTSf6nb9uya7RWhwnpRuZtf30Qew6D3gFVqXcL6zAtD1Ovq0q9wuipd87YCK3PdLa+D+QQ+oieWA3bohMry/ZcktNZe1CR1efRtEq9kXVYn4rg9jT8qwKrjYpyVNbz6Yvix0QEy2xALw9z7EULaOlB471aWIKiyyYWfV4XafbmbVJhElrQUKrhzSbZphQ30n24s4OMEFCQ878/CKqpketMU1s8TMS1zbcklmwdJtRHZIlHnLQUYZWN5R4GSzMnKOzIzVAnwzh9H/10XNC/qA57kKAGBUE6MhRAC46RMB9Wrtjjwk3/epbwh/mANIYroJ1CBywrS1B5kvlY+VMdvBVClKFq4iHXSjgC8zGFF/XnjhqCLROxfEborbNY2f+DaGyD0p/5LKX8/xSTO6OX+oeapQx1GEHhDhRLXhAaJ8LdX760OpYfn8z6mREXysEY1dgDPVM/hRlaXlt2iDotoWEBy+/w0tj8k+m2in9MqCCO4PmNA50OvFShhdnnkhgJZIkk3s4Phm2p7cW/LVUz9qKHzRB4bZfawqlme+AeB3FH7e5yojGtQGn9jpqcw/2XqdniF/66rLcQpcIkXpzrxwfjnpajUw5g6ngUURBJFrUCbgDmtmb8hJeq0Gl2KaDBliJJLb1yvuOMrQrUtWMlIDlVXhPcGwszJOlCuljwv/dcKAKQidljWxX0OU3xjXQFowjKXXBysbNBKyt90jK5qDATdsIF4RfDTpUHy3DLByJZk14BamGlSJWJPSLhCJ76gYzhQBr2AYEbuJcKIx67QdqYRN78SYaee4Nss4cf7uP2ZgTe/NQXBh9f4Lwi92kc01rFwKor19CI0WXXupwRlEOshpH77nLivUlpXwzzf7AmrOtEPU/VhpSW2aSXY2K5GcpTdwwMhJP/SW1poJYqks+KF3vLUaeUef9bXC7MD3YkMLkDbQBC91xdWe89mKO/L9N2TesaIuZ2XZB+J2rkbX24mp8XiiKdFHOzFJnP0eUextBVlyvsvStV/akL7hJl4Fqi8Kq3C6dLqflVIJ118YeKO5Pp48vuPyg2v/1AaDMz8vCGsrwcYaTHMMDRaKojhz0TgS9yjUnnV2ZIvJ2dQV0CFfFjQd0YYAYw1OmlIbIxL+M6i7nCjOq81x5BlylvlHWo7eUAUEbZdyqmA3I/flq6FadygWn3JjG38ihiv+/nLW4q+z2DSD1sxPk8j4W26Sv4M538ElvXSgepJ+dm0zMWQgQV0fQox6xodw/IQb2K/Yc6ODiX176rEKc4U1sH737RkvayF/qnLoUBX23SV5zUDXgV+1NH5P8ifTz/hKAMxxgQ7tUr+5Vpps98xpvX0EawpthwJSlqOPKKUL502OBo1PrPNgHc4LDRMAA8FOFWCp/C1fEWbzF5ahwSO2v57JDImcEwbtYCo+L1SksaGUznKECZi2lFHtw5ORkG3f1MV6kHV+JRF1fvmHSfrV3HMsASM5OcgMdEj1qUDBzsSClqlDVOjofbF12OnA9XKzmWCRek/OhizbZhMF7lkUlPQWpklgKlFHcE8s7lT+yTYkYS7ijgLyv/3nKUUqKs3gI5D2r7+4W5lZnnKzm5/PKQAab47XvONWLMCYuprs8abNpgloD5SnU0Yc2QCd1HVh7XywpmHPPajgUfymCLr06Z24NYBQb8G/AKuC/etlHYDg3v7TW2OX0AQQVrLWpsyMoQAWoiTdoNI2dB2uZGHf5+cEvWPLTCiSMk2hrW2iPDivj8ahBQr3jEBFad6Yr8CD2JonxiS+13p6mpkX/jXHIaXL62Q9PXP7TRj0x6ZQYrMaTABnVJlqIWZry3rPSHe1PcjbfGKa+pfXosXamf90ZcGRoUPW2k+XA092LTwYi4XeSo1e++rCLQyUtgZ3chYFt3/X2mr/num/W5Y25j44aPXzuK4/zNiNczMvmMF3IemLuv4si4D4sxj2DCqagQmyfu0vO+656W7pLQJtxiZ8uCEk1VEiJ7u8lD8FYDPwtb85Eg2i/Gdctl9atjVz55xwiz9z+OkOZgdz9NU2wEy/oyLD4MxLGJDWAxsWezoVPM96lQqg9QK4R6zXV/Yq1mlKMoyyxa5fbXErNqUDqaEhkVprECWVFhmxWlhA/BZTlacDJ25GIyisjkaDebIMzHI1EOWKYqbihhWPMjoUc0P5bSwMHdOFenk5c+uN9jNL41HfUY4IkUVNXJnOiSLfUStRtXojjexghQM2SaAYkGaivMrbdKOdarDiE78uPw6MgEE62SVouUUUFWZhc8whXBddu5RVsVAiiF80YcfHdJfO47NA+Icg70n9jrLFGOXv1o3A1OEKWTjhEgTwJemD1VuhpsEcwUti+Otx31FNroD+2/HrEDNaZFcgbXheGcqMC1if8J/b8PYP7zGTRzaxtuWUkaSL5TjS5js752jFbvo1A515G15Lgq9Go0G3ZnA8TEDw/pmDbOOcCCCGWRemZYAk3i0SerYXIlVOFwSDZE+2vmXtb+UCU7f033F3bbtmGbr0ThO0ZJ7/28kUhIBh3oSz5AHBzOzrSfj8Wq/nSQahdS8rQJ+oL7R0sdbqd/Z7RdiJysM7qkx0JP+zpBm3LDSOC/6UC7vNaFSHPZ4n7jgWB/Zm1/6t3ezNv3gPFJlmQq1oNjMwQUC6JYIIZHmGtCEKYwpB4HVQV9sdo7emCRIW8NiA8UxKxHA+PV6ATAT0PdpSxS9+qm+bvf8TAV8MGLRHx71y3E3XSupSAJJT8jndh74TU1+uhisVhj9pNkehXhcENFeuCBo4El8DkMeQG/iu2z0HP4FS4oroQawawzS+4Whk2w5qj032lPykVesUhNCwvVK9Bgmj4TQ8DvQxDX3MZBu1l0Ewiy1CTeSruQKt61LKqCLu7qBsbcy1+shr1kLScD2AnbohAHrtspBJRQ1Zj2jmisyxSXdbBgpuUeOKL17Ujlcnoj7KD+fnOgU0ItiC83eQDgEENXRYQA4UYI+ExLu9/j4O5VRDDQYS4I+D8YLK5Scvsug0Wly3pZ3jNRVs6DlD3uRJgVbXDuvJEr/r1WOCSwSI+mzBI51Dwj9eICB7uzM8LZV8QFpqjNUq+N966ZA/vpMgw1bhKSa1g3UKEfB08rFKOiwfIvyQ9hvMsz3zUtu8k8MWhJjhhgNnw3a25tCWWaRFCi9hk9feCqgC42Fssa4QFmgPnRd2RPvqixPRMabwOAgNFlJmk7YVQc7t2taItiRejy0E5h/32jDtAhSOy2bKUOTH2PhgW/7vhO+9+nvmBHHiH15IVxOrn65QXwmH+fdX6nKDNnO0oQOCdKyLGh8Ey6jZRd/N5XncJKJIYk1ANKFde3mpCsKJDPnwx2M7roxOvNMtmq7xt0Ry1nyCjA4dxsxQwQbTTOOERJhLONU2vHVCjqE9B89TX2SJOgGs08ooAyUCSrEtSpoKfc1oHiT2eLYYT9PYByuJt2+RD9e1jZXS1SJPjjov1vadj8iI5oxLqLfia8I81iQaZVFPcKNq7W8mxQ6d6y0BTQDNhXTRtWYqvtifboGR+bt2Lv/XlzDAQGpevWQsAN4WGmBZWI2jGtiiP5Ax2aTScsX511RN/vpiI7nfoxpV+eVM+OmGN9fRlyhSYLnu0nm4M72jQLF2avQMI6ogxjupDdeelP6Ta1WOo5vpOUYx8uZqnyaD1/0meuld7dhBzyS244JO/Mtj0p3WmQNFOzeX70HBjg76LfmedZMsRPJiVaKOOQgHALIvD9TG9ApMvEi8fMNVXw0i86wtYBIEyXsgfxwWOTl9ZgKyUGXJ5fiv66USkZ9KDDjao3bu8JXcxDCG7/QHn7Qyz1/KQWEDTUEf7hephBhJhBlt++HFoz8curIFhGIKjERqyqdK3vtJa/2ZLm4L+/e926y+wWHYwZkg4i5CQ/swVytk+h4NtjdMHYi4liUl4lT24FPifWXd71cZKc3ofCYLKw7vdFOJnVmDCFWcVwU7PwpJ9IvJGuCz/iZR2nd2gomj4blMewUcVNZeuCU4ZoOG03iNdiTYA0TGdShtUmQiU5AovSHIrO0zYjdhajjlcWQ+GrgRsG/ge9J46qqDhx2Js3mwDC9mlTjECRlE1ivYmkbbYkVELvfMiJE2DYMOS8NhtqI+ymVVCtUEDWy5deGSSnO0uOC5tZXIwLE5iAxR0rdVUfJVjsQq6/4ox+C9gTPmYf2VQh+gUEHhdTjOszFRI0pypXjEZrywah60cbxJgwDyX7LGu2S6QvH+zTpzHiSK9YxAUr4R4xTP+JtipAA2k4A/fY+nOtwl2JT7EXM8j0aGdPRy0DGY0/r8NB77DMx1+xi8msHUKAb6YmbBGrQctYQ5iriAOHydPZoYGC8iQn+ik0aZiICkDYAgiOY1Cx7ES1ZlllN0/h/bFfkuEjaDYXWLENjlgJCxY6rSjwcwDLssCbfXm4dPAf79nlw0xiHJzl5U78q0jpWLnJMpGt0427P67KpVghdN9mejohV6qxIKQSsW55s/xZUaRBPTGJU0FWweqgfNkVxWp6H10balq1hdDePNn+1gWne81fkp7BMdhfg7k/K6A/+b+hfn/ilrtudz2Uc/3ZuehyHRcud+rPtXNouncGylmsjwxG1Q/o7DV09AIv9BIEJI8vcv2ckaqBTDZur1qiGNGEsZAGdNy6CGkcM8VnxWKoJgRfA3nDIHlaHyJqnewmzi0lewKhPbSxp8kt2H2kKw/kcoRt5AWa56c7ATQwmxpyaLFP61E9xe+yvqR+Id9w3+0CbNTH1sSVxBHFVfT7q7v5o88ke5f6uPhqkxBVuHVDICdEnkPCmqp7wLlfQWCJo416nh6sTk/nU4NahaBozakI6fU3aAPj/1Pf40tTsj2jyNqsmiUCgA8mX5O+li4wciXQhdyRsJyuKe56g+16NjaoSq/AmOgqugdAF84S5d9EfnNiEqcKu/qYL8rbXuGBH0HLg7UZKpprsryuyEKd3RF/XvSZXbgK6eb56Pt0HSoF5GRqYm28LwVhTpSKdZLq9eqWDKiTBHAxuM42EOFBxR1CkmmdqjnUwsT4juc4kA1CLwtXaOYYD3YllhgdN27QUZT045qD9dBDxK6S330s7zKmDzSE+GJnoGSYLOrelxqQhIC085XWW4Z2fHiIrckFb08EquJvOWdWhR1AJJ87/7idRX0yMu8UaQDkhqO6uGmYWRELNu/itsagrdwVBU9Or9cRJHMOfvmpmTM0n64+++ToWr9UrwDeLAv6oGcx7rMlXQZAfNc+V5SdnHrxxiQFEtCAI9D0y763e9Vy9jjAsJ7Yf3fVTtedyyikN95zPGwmGfjppR3QTUjDbY1QvikHfGePCHfFsMUQbAAIJt4TQeJjjTmpfho8/PQz+jWiVkjLLOtAnNo2/ewuJYqrzbd1umuPav1mXNC6xHLsRev67o0S6xh2A7Hy3mEsJf/wFN+Zj9rbQ6VRTn0ux9hJa/Xe5IC4JHxkSPoiIP+EUhooKiQazzJjkARLt6Z0Kldi033hGnj8AaZlBGHZ0J6aWQWRf181NNoXAf1V4eupvlilB+nm6MJ1YVtSexd8uImMfuysAMFa7c7Ll1nOxs9wn1Sm7eEoCMGR8QK/OHHaMKlEP4BguL5gcEzW+/iEsxdoA5F84T1UH7r7ePpgCBdEW1a1JnGMoL8BxACGDTsIVibbWdJ1eQyCnBSFyaNfbAuCJFAjyFQCPJBwDaXmF/5otUgBPbucn7Ixe99KboUdeiltZy8MruOyjKHt4aW1tm5UKgfwTnRff0ohBJHbY2+uOEwxRt0+oGfnnLeZGMnF/Biww5Uy6sSodTa8IzI5rIwoZE63QNDaeB/CvzX1M2cdOIp1dK7IIAACAASURBVGqFvz3Eo0wZfaIP13iPkAPOqYmIY4PYtfD2VxtysI/2OqZlbuaq7Uykz4lidAlsWxPOqqgkFILqJR7gRtSiwBaX6A1I9ckCUG+3/eqCKIGHU/wjkSvWsqpeu96dFaqbZbNRE6go8ZtjyqG1F+agvOR9K1/lR+y7xZ177+6wOYxOXIA4XQW6vf7DKUCrZaT8XdzqxPZHh7MP7RzGzIraHPVz8wJ6ZOp4ElOgH91Wsxy0Uw/gnMesAOL9LIdUXNzE1KqTmGNkBJ5Bmre8WMKJ0kXDCiJYVS/QQkZVay1wtuSqAzlSEH59iQOGmyyY4DXXUAHdKNcraYp2hgxGO1XZwYvLidn+14pR6lA3hpoqbhkJRuXfu0sL8/X6fl3yx5/iAvALt5ypCNqYnAAhykvO1Tu3dTR9bm5hTZxtdsqYHFidIHSAJlCNOSeRzwrUM2LBwKm+TmVDDvHaOXybhYNHu6Iswf549flVYuUjYbmdVAU7sCOgH6GHi+N5LRnTO0IW0NjWSugoNOTTpNQyMwLlE/wagZjA8ttBQgTLT6wRwm+zOvpLvtYqZnz8eQmT3+IPMSP/19U3/20LEp34GKaxG7AFCVeIhWyN3asn0M/+/QAEnZ2wOD9rTDnHfZDU64POcjuw2dx9fxM0WrLsxJzVrlbJ/+GAYJ3C/BBLM6ZstBxnxFTiVe2yMVTcmdsJf0XGWyTo/7yQtZNoE5JRVu7MdzBJQNNAtonKSwMCvD0Nq3rtxWR02ZTD+sGyKsqDyBL7tJUR1NgtGdzRT7Z7x2vpZEikahCUHr9Otu4QmUDlC9wnKrBK+uZEm5czQ+UTnNB0zdEDfzN1kt+dgQo88z5RkqAS5khbOl7xW6wLc5h4Tw2olvTXPW3Xjgi//C/nFXvB0xDOwOb2FBHe/bg66pMYsLmx4URXXCWl6U7YkJNZizlMjkWwvqYTgA+E8WKA+xIIUclvvMOiyi7F3YRoMxHSKchHycV+xv54MTg6943T5XUzivNgraZBDsvNXsr20sBmeGSkgWwneXLpQ0HFqOniCEmm3/rnSIcMmHm1fKPuPhm15B2jYhR1n2mm9HgXhlaTyHU3pOPybR0xeeuXt/WT1/ffhK6LnTkl5VRyRNYVSVceYp5VPGDHQWk4NG0PVMJMA5MzxEhY0pPAicuXlBgdf0WH+du4rrjushCDeiS3PvkGQpxT2Cl3UxTa2Dee0WRZlUEXrF8/1vOSqP6QjTPlPmYezrdrDEWcPd/qgUJuJrSELTZ1hBDxxzxfpLv7hdcpD4kpjTZdCBNLpMelkQq1Rno0OGW436rgpfBIjlTSGM9gu89rL8U8UxeFi83ai/DRTzKAKNkG02mSbzQ9ImxMWhs1YQ4mkR3d2QacT6PZhm5opbCB04c4MjrjIqLUQro+NlGuQr1sTDUCNaixzeq1hkfYkWCPl3skA2BEkw5F5DdOreMk5MdpMiok3vAqkHTfImUjYIJQExQ5zpYUhVh2/RYlUzQ6UNtVrDFAxhZWIRDZmRl0aPuQsYZ+gJAwqjuvoERt0qpFapAUdeBh2otHq1U6UVuwZ9DlfSbSQt4QF9hjxBK2proeYLL6wHKDKhNsm43qTruyOL6wtH10ryUBlPy8YRaR+ppRXyxFM+10a2JYGpkjvIajSqxHp7XtsyUvrq924xDJUBbcHxMNYBY6bNHw1CfaZxp8A3PmAoHI1F59BBTNNBQoRZ0BgiM6DbVFwXI1ybNltaaShpsdM6tQHCt2VsWHd1OAhyLMjg94ElURhVvTbOf1jy4EroNSCQOiSLv6dkwOKnyAjTF/FbO2MrY1/vWlbvhEN/SFMuJ2Xk6qtElB6Bs1/aw03S+6NI5GYwmWG/vF/9RELvATtCHB+22N583/dYE3Eubx0LXCl6ZFCII3pRDER37N0jRoDY+vHWvTQGPN9VVnkfPl45H3CFGy/tzqzLLP9AkuFeHoYG6yu/RVirX2W3fhS0hPnybCRMvLAox+VXD2XQS5QPOJQIqc0RUwT9uoCdSSictIIIA9eWPKJWGGtEIZ78B/nkd9vTga32IduOUG4Osgd2aXNEfEWY7c4HF2+QLv7TuCmVWw2RbGKJP+2irMDf32HS8DhayZ/LbpI3etD8ytAA6GxNYbqbAFJZOc/JIzwiK0Beb1SeNoIdwVArRQbUfLZv8shJ9Qv1NqICRAqSrNrcZdEfP51blbJwvGrk7UuQB/lHYzI+kyWxhuejaMzWSy+ceTDkCIzY9iqSYae5ikdRz4z6rYTZb/3ebLfzhXikpvOaBq+vtdz+nJhyqlGJU/IIBsObD7jpQxh3QA34qIJl8AqJYZ6gU8RT/fnJ8r+/ihenPMa5jNt1LIhKIDTKb1HMM3issZHT6W8dhGEtNV8DqMhVuWXOGMmZ8CSVTSguDE2UkMqrlKPS/Gf4cJU+pSQUCZD59pA3IdJt7a/ZKR0wKQLIDbAE2i4gXGPUMhGIV3c2ZL4qX1DcJXj741qZBJ7/5ZiPWcfT71nv8bKtHm7zyBFyG/hPNG1nEYgyI3Re9bqTX64dCPIyEq10OgvCRj23Kqq+LqubMT0dYfD1VOO8jyC2cbtpDLwgSRhZ2/vJMzql6sw2nIz9im0ZR9C7fmlMJuy0bI5AB8LZH7URGSE9i/2tJ27yo0Sw9vP8wJ/PYXO91lU9v1WO6X/+uj64APiFVP9tViJ07Clb+y7Dik0ymj+lv+O4OxZzqogW2gyqzNjy8YZ0ZVnv7pdnrzA1WQ7t9/8Wv1dRLAZAXpm2KzTGK5HsKbDNpUxIz6LacinD+/GGEL4wpEIOp1Q4G+7aMLEnomvhvm5TCRtT5NhQLNWOCZN3C8V5AXi24YnzZJvffqnkklfp4ysfuOTIwVx5UW0GQDQk64Y+bQp7Xu2iPd/3f3FiCKNmJTWCfKmh+tabCo1/u/uqlfWvjtPy/3Hq8Hb9EhafOjbrHedbZ78E2aKG4ovOogBlH89PYxF9LFqZYFF3tEXmsGVklCwmqz+epNeSzu7t1tzpAjxENVEO0pW4AY6sWjr9OqdN8O9PAs+vpPhpH2AqLZ468s41lN0W4xm9yzCA2FT2MoNTsPnqT94n+qwXzO2fEE3qWO4jccjFTfTOSzsjyaQtEBwGyY6ZmquedvQi9V9kFZLswbb6xqthMYOYJpIArP0pAFzsv7TlLz3lfzsGzfSWlkZ6IuZ9+bZOQWJIH0gihmlcLa+mKxJxfbSRXUdXsuZC79SwNQCLOFniOQ6PDzyTwdMkHvbbl0ERXdE6rqFTc8oGof/aNL7jxjyJzd738b1rwP7qCxj4XSYGHcTzL+v//sjlwmjd2IZlT3SeNk5cuGH14YC+ZNA0AmrVerlkMUjogg3T4prO8PQHW/9zKwhDmcG01vvvtWyyDGEQx4XWJl2Zdf5+Z8QsROnXw/ZsK/pXykCmGBbHhrSEc0tuuvnFp63j09rgB2r+z73fINLK+kjDJIGQXPbYpr5WbCr9v4EKBH4nZ6JtCD16tHmIYQfRnpgZA2hnyDDNgA47lbviaIoXcg49Js6U0+kkN5p+qfHWrzz7A++Mre7NJDgNaDGqJSUYaAI5Nyn7cIKxTB4/3C4htzpEU9qiy42EvwJ5vYzQU/CNW03StqTQPfscfYyX03E0h67MyZzG0XhSkx9h7rxDD1DqYsOnlCRpf0nvR/o+/BWcehbP5+BYj94i5E1BekRDSByWOnZyGRYfWMjtefeeBL4+u1H0fGW4RculhB9/tE/hg2dwI7QPHDJ/ioMvKxVxlkM+l639Jk82XeDABiJZk7n2hfjnSJJ5yq6aktIrN0/jH+SUYxLGdDUl0RBtjVOhlr510IToxBUMb0/B3Y7McpGzm3JAu6v/trVQMy/4asqU5e7cHsznF/7aSc0NA6SPZQ2WUyKoUBtg7IK4Dylo7n78VoHKcMl0NBVDr4IFWgffgOdLCGStrQtb+hTA156XvSMkdY3lIE0FtrMkjsAFz2aZjL8VKihuacTH42Mgf0cCt+Pvi74KtYLquBk20FG1FLX09sqNhMTudcL1qAwSk6jMgYKuQkVMCW6IJVMYUM8hL8KM2pqu9Sk+vif2BNnwtTwY8e3ZGDwfFYXhg58BLQk4UMNWXnx2UDDk3gFBvO+6LyD5UP8h3KgRKx/cS49Kp99yFqSlc052g/LKOHZcXh/uGOseVfXUA6d/NEgL7wloFmHpZTgsIFX4bqbEBB0s7EgL0jLcHe870Z9Y2et+86L8BQE4/wgtJDLjK4Y1tVAkFskeSXlM97S7xKKpDJr/InGOw+UBHC96cgvxnWhpr0XqU2Ot3Do8jdoaPVKIHzT0JhxQNw37YfrEdUQreGhuyGtMb5ryol5A0D7fWGEx9z6cewA+W4NYgyO/02f3HZhQZFj9A+IzZ2FwFnzNpAZ3ekhybnfx/Edmw6zPyNavgMzw7GAVwS2aESHNMFIda9a7JNB4lIEudID80Xl2JKhZN0xzxbBh9MQfXB3S8DxeuUhVzOdUWI2fsrcgiCpmekh9zs4D0rVECPvCcMBRmXKdjH+fFBwbbwdK76VIiERA+i8siXL+Foorlb0tK4/8m+y4fevHt+hW8jIej9KAXyVAt88Ouz6pBuycazijTQa3mCoyRYWzUsP/2Zdvhp0aJzcr3JZGU8JUIAKZdsUmSf3QeJjCj1BuoGgXTAM+aV6vzIZN5Zm0irIHmoj6VoD5P9R4vvi82EGLnwt7bD1jjoC6SopazPnnoUTokou97dRKytWED3yBeTIdocFGRMLkIaY8tRgTtIoWnZUc9cO6XwEbREpDvmypZ9b1RlvjDra1oNpK6T84g63HNOz/jYajwBeakZE21pOZT4LDObd3T/U4SQF+RKJ1E7MBcHR9IA2eHD18pqjo3jWL1BeswNzEEaseJUSzMqkfJInj7Bx7Ajflk98/7BBSHRLI9h+a5qjfeECufGFl5sP2Lr8iT7Z4IJ9iuNWE5pnw6QP6cJDLipjORPGh3Zd7TnrU+Hhe4uNLA346fKuEHBbhUllp5k3xdQTBg4q+uInwGKeQlTpy3UgNFJodIcwFrGDtG5xGaJRKIGWyf8cQaG2YFcw/NK6dH+oMv05U8alguWSWP9kS9P5/a23Lk81D/UxdG8P3n9w533wqwc22/wL5SGIr9/waoc3amEicjkehZmOZLnGw+IqzL8D/7qqaFmEOcPPwFjjVfcmwpgwx+FRNoW0YjwlPCHfSAdZjzBoYq/SvxN25nkzOppx1rj3opbQGCvBjob3bmylQHuVf1q7uQyJvHtD73RPcKgf+VqGPdnb+y++gT2T3UY+gFrcosrDXQiH8dUKwX5T8go1GBU4rznlVC5HVJlET8veTmoCBPNJ6erym3aDSoJkYo5Ut/dc1k/aYzX4H5g/9t/4cymfBkjGyBPPBPh9OWw4PMUya8ZaoJpyAzVAwPIjs13VACHxD+w0N//rCBJdvkOBfdNSOF4XC9oPPfqtlNWhG1JeB4HFWroSGKg4iU+Ao4kF4nWvGCx58uzdDjK8Kj8VP89EpjzejCZxHCsY/Y6G6Z+VBPhUkS6XFHvWlb4kT5Z2C5tCP9H6d5mG0hq6glRmOMj/vLnl6Pdo86JfukKMHbLTAZ6JCfc/RDfve4Fw2luPEXRnF7DGcpfgho0kZ1455CEIwoD/UHnM5yaj4FkesOv4fkrGnPO45Zu6e2pbQn/6VHPb0iCF09B0aZXywZmKkz1spDmag77DTY2UHLLPlcOMNS41j5SZxuRNLHe0+JgTOnDSB5XRuvdAnr/IzKnxA1hQjHzK/NxGsXQq6N+5LpAw7AJyl3Z8mdFOWyGcpQFb8xAA6Qzp3dX3K17svQUmWx2JYHT3Ul7B7M/Sbw2f2zbV/5xQd93jeMwwXc6ZJB/6Zl0k+rOQMUtV6Tz3F0Uqh3PsraPXbn2MtFSdkESrqCM0S1ubZWOsa5gdHBPoz2P3xO3+WNAR1+S8NiPk0RghBDPrfSaySFnWk0MpuouBHg59aP4Oo0zoo8WzBGtPCWTFERO9eUBe+YQ7n6FAUF7p2xFnagEUSp1DzjGUPq7Zm16R+X1tJ7EybOqZivJOh/Un4qSPoZ4EsPc1Tiy0BWZSCsUjxQz6aZYxyIPmqtNT6w7FdSVjJ6wwUT3sWZWzVIoO7oVJW8VCmVBLabSDbdz+/okcgDSAjWS2nmsujtQWVqSbc3p6lTaYWxbSUSOVAt4fqwGf5B3VDbEA9JUYzuh6KhHa+eKteHuzOm2wOS3DDTWQUlVyo22zbUy+8uJPyX6tM3pRa0xzSWikarVk1B+WwDroIqWRXpyCgQNYAv0ux3IlZ2ZhhkSRq5Y+T3RXjLXUyvzrXqqJKkIYL3UTy/tGXuBI19K/3rtD08GCSwlCb4HBUokskH2GaACiqhQiejEOz89+9+yXNzT3i1Mpw1Fyjo661n2j3RI13KrPU8L1E0EupH8cd7zyb5PYMnfvTiRksihkYK0T/pKZ/zh7yshv//7wTmFp2ehmY3N6eysKjAyD8tDJE0Omq4gTwLgVSvUVJBbhHwZf/Wp04WUo+FF9Fa/4aOvdXNerOLrhp3JHnCJtI4WnLuDgpDEZJdqNUtVl9iyo7jn/KtS2RkoonwOZIuP0UdVImO79vKqHJz1qLTS2Ya86uqdkkuu7FG7HykcTmg2gZngr2+n4LE3nrfh3RmJud7j0A5JaOyoSJr1iZhFxJG1n8dhMKwg8g4d4NEzAO7DzDhJhlqVNOVRD2alYRthdaqe4dZ1NKfAQZlWK81E0D5DgbLibsc9AKthERRn6NvUfVoGzixrmysD1Tu7tawcUXDdlRWyfsiuspPE1ZwVAJT1obtPhmGFuR1CiBgm0Er6JEMKHspJqnAaBuptPFW9Ha/4y9/9v7vht4O2EAyAtKXtuKKHHCkqhEGcRrSuqtNU1KRga3UkSeWxlBvH9uLIvAkkwq2LmnY4TjF4FCiIXDgafEYRPDWiQN5hcz1nU+lftKyLdKjf8MVENUHdmoO0DSov0Xo/AxPGPUuqR0lZJlS0MeYVW32SMNYTq1YB4z6d5cFJmvA4DtC/6HJStFxkIupPb+DB8b7Tn+nAo5jih6sOLwFpvyhstDaFqBzUyt9x+/JV+iaebPA8gswjImNOOLXd/Exrbn1guQ5OT025LuW0PcmmkqC84L7cS47DGmMfIaHv26mBRr+Plv4wwHxv1wQBt26T0oPzTD9JjR+jiH1LdF8hnofPOqIVL2alETRHFR7EFdoFIsqVWfpRq/U/BKxmaBqz7z1aJVR3CZpocobrrYlmjpoIGLFUQKaFlbMNnzBCD1GiPDdzyy3TSNLD11YBREnrpJdZ+44W5nsuhEFGylA7vhiZA0XexYiKm8QWN3h0iEZpsqMeVABroo0VEjFKyj0781mKvTDno/Jvher7001JeQJXE96Kac5Q+Dr3vpBNTn8miE21FQ6GVF48ebNpd5ksiGkMOiMmj0IMOgNYCJuN7n//snlBwkxWQTFBrFs83jjO3TsMIRd9I6LgDyIcjPoZHcRdlVmUZPdI0sstMMRCZfsKKRgfH4MfvpfhXScFg1xHRAaATXMxCrXqnKXDZqgLYrhx/ZQSJCVF16KwAqY0iK4FF+Ebwg5OgD5s5QO16I6Kzy7aHRgrT9CFIS+AU+ZoM8ZRYBqZHwinjN0HU9OuVqXoG72NIAa7uwDi9hV0pqwwpgxl1JjleWXeK+HEbye5J7WveAq6BjotC46/gBSQX5PJ1i18sXYSgs38ye4B3BqZcg3SQQ0EUwHfRaOmiWTZIAZKL/1gFwVEbdBFOl9SN4W5VjGPK9/43tlts/bFU3PLoXfgGHv22tfrLGvgKQ+bPIXZSJNz8jcV/7Y1dgxbDygWiezB8zBD2SIdmBx6FAe1G1+de0MlggacgpMZyAJoSlFsRmRSPsSOEIP8y33d2VESxBO474WMxOOFDSW7VJQkjsaYc02MRdOcEuB2N+zQVwbHI8+twZlM7ylhN4P1ZPh4s7xZBTVvqb3FUThlwkoCPihM+hEZpJtNg/kTnTGs+78uZ/3/dIFm4fRI/w/Rzd82Yh8/llNB1ZEvFvYbuP54urBx4ptKeDZRXQyq/SBCtHICqlmtJbW61/h6ckLghQqABNmlaCGRNIIdaRFilaMC0Z6m9YyaxJl9bMZOlY7NMIOWEYXCmEPAUACzXJcTyzc4AM5hpB0D3csIyphfSleTaFBNkiPl3+8n+T0Fi5un2AHpLUCVFZO+lWhkPnCCYvzeLaUgkoKZ8J4bdJGGh5RgR3CLailF/ydbyKjlV0pMqFkQOFKqAmI37AII6dodTJA+b3Xxo8dffvVDAGTYDV0QD5jcW7pXs+vd0o+BbDi9JV3miPMUs8Rp165PSk/xxx8p7rVUN+90OE82PL/S5oMB6rYHBfcjE7tf8rTfw5Y4x4+lluY/r6GxvQKYM2oVAX3OZ6J7mhVo7A82uS9LSQQly0YMLsoabU3mpJaezWiTLVGRpqxmcaiFHMWY/+NvP7h0Tjfc/9KDnmp8M6MZpR+zRaMVzV3XGp+/kxlrPL60s7vx/NoKd08i6vdQese0V05qFUzFTFmOq9Yw4iXhFBRWV2MyPzPUZPnNGgutm2g8DwNU1Rvy6pEQpSIYKuKlf2BSEHwGfWhgLOJInmpQ76iAj41LkAt8c7CfyEjZd9qLKiVQgJ59zQqQHyqW2tSBU5pZ9ojfszYCraokBaoGlHgD/P0f6DAH19t8sUKG85e327w+JqN/CP/Qmt33+NxQtn5oO7y29J0X4qtze4/ygSGLka3wrdhudwgetjE8shU0aqF276yx959XDRqo1wrx22eP371I+oK5x22zi7WC7Xpu2NwnwmmdPfB7Lyyaz1tYk2eqyih0bzloB03nYgGs5IxmwLYK0Dg4iBPZwwAQjVUjqep4wvDGs9CoO9uPiz/Rwo437MQoZyYi0IiNKNbW0N/bORN5AuNq6qpWF+5arm5V+V76PpzzZ6tnTL7eDlR5pgGoGtFAEnAk6jWEPR91lOVeUeqelaPPXCIrL3GPazE5dTsuNOL1LIbCqjvngj+a0v/xEumr2yrfMlPj5tiL5MzVCufU8eiY8Pob3Qy5cllAEa+yBx+8vy0VCcp63JAXXbtD4GprqTJ28aFzxwrF6IN/vko+P5mxOEuGpEiBJ0FZDd2fH19y26jJ8Z3lIs+2c4IdPnKULiGzEh8yiGJBlx9n66LvX9RQhNv1YlEIElc2+JrnJbTigfGKiFWXIUzSk0GBdsRiKABS4bCLNdNyZ6+wm9oqDTJp3c1pNO/hqeBNPLC3C+qVVt4WCKsekW90k9EwN67E+QvronqLbw1a5c3+kd785i0pVNuHYPFT60Hqsiiq8Fnsw88FzXrUPLy7QMcLMcHAyYYmE1Vla6agatm9pBjHIeWoubQmS0rrit5tYLkkIJTxCgwQYC7AOvz3YUblwNjX6RFai7Pu/uaFTAbPQVbY0CI04Hv8qUDxokn6XenMKhvXQg1dZp45v2PvsZ2ChN5kBUQ4/uYLf7BNTS0cpKWkBulr/MCvbQ30ZJcJ2jJW+NYkQblSsF2vNFE3L6b97Uh/8OaAkkY628hwT0gjCe9/IGk3QE1433pFUZlb2moElfiI2btRZvXKfUk0BOe7YAEsLT0QJIB2DUXOqd5wd3Hw9YaJ1ha0lJJeABiO0y5ITBeOjfs3UzBopq7Cd4Ezf3n3AVwn5yzRWTvtjBJkTIhZFMV5UNFxjdAOyjMErqX63Nqq4FfXIo463nxs0ArV6/s9uXVq56z0Q75DU0krlBVJTh+BuNLX1m6oJIIwG5Kc+FikCzgLK14i65GnvpjtBTt0q6SawodLOxAbi/t9BgEW662NVCp2thLgyQWQHvSAKKGjS2Kq4aoVUz+E4/zjbeXzSzmzgpAMq6Ab96QMmN1FagwrvH7oNdSdfOql1713Wz5qCxFlPaGMMPf/U/T+UWnd+b735odgt0kLEn8EMz24pYS7JRMQZUdoHIPU+KBOdYwhMTN5UAxYbDKQHdhBJlxEaxhib5vlTbm292RtNgh0Y1p/RTJQPSn1ZHwsfUwTm3TFSU9zbcJpXePq5PSZ1ZXjWXm+82fWyopZwv7uz/fzeb9eHypg+stKDabiLPggvVaEEe6WxNC/N3bOi9VLD7yO4tniFj2ZvmdO03Oi446H+GSD767aex3Pl42AWBOG1+zSZQR3fq1u7ulcllMiNY3IlpJdHOYLVeGesIJ/7b2V4T60yAYNfd8l7dBjeiUzZIQlZ2PaJrFVFvCzpmzPptKzPeiUTHJBdzeVdY2KMHVjfqMV8cW+/0DfIRtx2WJUwnrtxsUbOinqjqNbPagSc/dvddHUCFXR7pRlTFPXxyjx/u3+WZfdhU+KVAtw60nDd16eJbclZ8DhqhEMp+oFMKyrOQGOxS/zdd+0rM8dZ8zH8/AIsgrmEwHmxULQARTIG6/4lnob+QNQRd0PJh8qWPi12lOLK3u9K7isE2lFfINtq7FJZHh7sRoSp2VNteO//de2iq1ITSnaHsU+0OplsWDryRYVUrcRP945J1VEdw4cfg+Jeojvg3GY1ZYhvXueGyZwI7P/ufHlsX1WbKzlx6tyTu+EA460/H1ra/wKxX31phxF7uOevzZS+6byLlv66DrZ2kfEo+GQ4eqVYSr8ZIh8JGZMn2wTzSwfP5dZMXZT0KAbglsyeTmP06TIhzmKKFYqOfKNThPlRa30UM/KUY4z4w8pFaZ/9lIVbmxTO6KWsmwT1dkhO6p80H1NvFkOKZloqDDb8ms1c5+LUBfko4wxllq6Y/l2A2Evy8mQ3ZtissiGhN2USCEjJD2ZBOEA/c7We3wIijRPef59xdgoD1ijRmr3jvCeqH80VGczpGtmz/9yVOWT8gqsZVYano2XkX42ZFUNMQF7GqyZAtRpU1SZLpEvnz3M+Zyz6AAAIABJREFUwa1mbtU0t8u7qxnXInkbVJiYkXp52NwXAqHenx9zt1T0DnbROosvHV5l0ALWJ88zMauq2bHAbuaBAdbFD0AxyCaPb8Cz7EjtkSUy2u6vOyeSXFktiqkTbpZwhCnWfZMzgywPkhxAlZDQB7jHeJ7whV9lMr4R7EadiUh/98vJAj5SHG3SQGkk1qdqjJ+GDjR2CllbxOVMgCRPCkEG/KjOSKFW/zU5WgR6LTck+SVqqRhGCBIW3JigZJUOxckdTf7jn/z5zQabTHbYUdP2nFHkCk75jQJN0UY+Essxvr/6hx8JA4HPVr14eXWlMkhMfsF8+40qyxEuY0zbcHXL8XUCTIJo5gtbNm4E9oE3pcocYcA6KWtHXmexLh7yPip4XHEu8e1H8uS4UFnX08/E6qcjyCVNL+SUX/xLN8nn9FPiLzsVxQL4oflBPi28mQ/rTjEItdjqj4gpn6SG14dgAyJKSnKcJSmg81ggKbQoXyA32y376aHxcY9aSnkhmsFEXfAsnvJHSaww2nuImSFb8XlhdsIdmzvRipvfXOGUOK4wiB7Ej+Ku9XcrTtCg+OHKjTuNyH3Y88k3l8n+0hfpH16Rh6t2jzH46boOwi1w62oJdTor0dAQtvnrGcDYSXA4YIRMOKT5akwLlZV+KpTqijKGN1tvSGXLEXpvzvoAOTlQDpNM8TQ8j1isINXvm6hxnf3iwH8bAB1WomNKygw0+Szq5Zrhe/RscXybNeNdk+qiEToqU6we7mBE5J87rTJxvKJUWeQ5+DXyhYfQD4hwPyXuqWhn7oMjFh4xtW4vmC29SD+J5ZuNNYSwyHi/nft+ycBSLTGTiETnUeiPhMetaoRDVRNEn678XcS1CO6BGK9AOSqeXc00jT2lUOHbs0mnolx+/IcXmGWUPlRIN98I48k+q67WUOVtieFC/Yh9/60TJlWzbX2tQf3zE8T9iu15OAfNSbkDz43SbM/Po83VUuh0f/7FV5fplrDaUvR+ttUMg08jgiC3xkzE739qdFj76W/UCQ87JRW5tu4gCWrIbuhP9/ztfdK3VAtT2yAivQL6/VjardU1njsULFgL9U1cnTukEkFKRod/KnrvFy30Ei3o+egBQERZdkiA09eZd6Oj+3BmWCCn1ch63rFASAkzkh2AvGcniPtXVC0Z5cr5Rmc501e5lQ+KuiqpqGqIufoTlvIbqsVwbFMpZEn+103zDVAII9jRuzwo7Zcz3GykXm7BQRCfxOLg6g9EEgkAtyh58P0Dy8KWzEPMhj53jTHLIQhvpfmRpsYDYlW4V57BTvxlxS3KJ0Iqr02S/ADRR43B0fsp8nR9jcoX3qRzPWny9Zv2Uf3gHtFC08OQ2h/7K8LADLl+oazye+KqOiILi2YaikmdvJ44sI+KwtBPIBb6zk8EHDBYkXRrkrBjkFoG6nhwV7eM3S1WJYV6KJ13jixOuil0trTeG6yW1v72prKPlkb9pR/hhftaVtJ8tURGqJEKiLEpBr2fLnCXQ0Yi6psp3yEFHDj1QcMBaV8C/a6c4JFXMqaxyq2cIIWqz8TtPlLySYaO67xMqW7dAcUfNPzzbVobDrZkwMlAjPd45mTPqupDalPBwfA/N/ewPDPi+og3+aaeEsX3tjl0SMildlf8flt0cs0LBZwBff4+x2tHONwn/SXnaN0bgN4PCRF97Fd7u2J7EN++Rx/hAyvgUsvOSuALSLYVGsz1hNtjKXfDnFeDAfbP6yKwEyUX9DUtUgimF6/4A+m1+s756IOhmeUyolS3WrCydtcawiUdIBAXHKwOmV9faQpjNQfv+aJRghfawnlpKzn021j6YBFxEgcpWRAk/JlIoaXS+RdtBpsftfuOrmj48922Fax3H/gKD4299p23UNJZvKBsdo2fX4Elyt6G6hJ49wUkgOKLuVIwCc6guyQtvZI44P0Nv3nDnrBqkmqWO+koIgTElsEtcOpKtAy4WAIyuKJ76msMdTZbMYBwg84MQkaa6twJXJx8TEKdITdkXV2OYsTtkxuhPTfxJkbONItzmKLfS67NErM4FuQDUYv66Y2ASC7N5aUwO5zpRQGDE5TD7cj9H0CMlXkGL3HqCz8lbsTcljElj2EN51L69XayLKdl0Z0ePBKN5COHxsr3I7+21UA7hqos2X5hIA4qYnHyg4cq3SI17HWQvMZgirwHgzxLygu6U69nXtmA7wdx/XHfJpLIMZHRZ4TVN9j14ZuDCl/JeZbuNfXE2diFw6UfZDKieZkUsFlKohRZcnC3bA1MHbKKwiM4qlUtg+woZLg6o/TOknMVwbjUk3+mc7ytKS8XlLP0x6uQirFrmzBfvBbg+bD8F+UdHmHxPf0HjTV2iGq5OABw7KdQnRye1bYsd9Cy2Lf1KdkZ9xSW4tzjW4s0gHlSA0SD1GMzTV5rx7rGyKud1LNkX8JZPiWIaKOn69vL7ZFumCHUlVg2r31bkepdHfTK+aOi0zcHrqUk+ZBZpy6fpP4+41V2QjsySHZJlgmwNsx9gJr+ITZGTTj0fJJoRy/cbxfIBVerMl4rEJasRyefTrNZ7cdtEicdttW3h4qcqKzpmn4ekmYvYYTwKy0iCVp1zXg67ucS9p1R8Da988IWDidBBl8PJ5RTp6kAHgGqKe6OptrR2/z8M2cTbISGfPzK9671ibs51uS6cth+KQUCsE35mHbCnTyC/u6QQpyP0CMp6nOcg30/PCMWaw9pZajku0T+hwMsG4s5/MaGiOm199PzofxLM5iydxvWoZ271md3SHCzeRZTrxyULj6BFP3dpeLnFVU3H0MvpwL9LAcTFE/KnrDXtUkX0wz28xdc40Gl0nPwGyvnurPBDSCSWZC2YWbgJhTFBZ7c0fbPf/vGu5lM+9urFZf9/Dv3UNcMkvWaFwsRUT7AGHUl+BWI46YswpCHCue85w9ZQav2T+qO8PfQHkl9dYY7fnVMK3seTuNxpO6HIfW/DugyWlqLPOc85HQKE+5I7WVTThzx0+s6F6HZ6Afz5+cXz0k2oY4UIurESpX91sildtF7elDnKZHsW+NVbNCOwDRp7pwSoCuZEaLp5fTMkn3bHzovWQwqjq707A4qaHUmcx8QIdokwurJrFaGNDIT0eMTyZo4s06EMeLGrCSjFPWwNkhA9yoSZgJ0+K73PmyeLD/ItfsQJJHWohyDvUZ45qwus4pODiEqXdI+TMYTBJS2skFeQnLPzuDYuXMkM4OSgS3ovJ5ucr8mN+Qo3VtvfvZ+BvvNkgopCBFvym4Rcayrn1tdpFpvkZLtorqjkWZ7BmacfXr/BHj9BWqUNQqVLpGsLqACs8zmqQeyfdeBwc2IRBrekQZMF7QcEcELWBG+j3v69ulS1McT1xPMM3ZL9dpnb3onRR3wTpXIICOL2osIMrcmjWQZLYd5B1ZA+HvnCl+jn4WtQCWDnupaoWnWwXmfdy0QxaAjkiCAS6YS33eZdq1W4BT6l0NI9J5D0CFoC5k5/b5oUnHyiPhevnZo69+euXqVC15nFkMOuQYOl67eqtly8F4bGJTHRu0fnngk0hF96G+fZ3wSYTaEXbVzBHKZFPKBoenrz1+Mn6nySU6Dhg4VJ7WiCMBRlbELcdQV+CAE82t1T6KZb4euZHXQZCylRk6/cjY8F7virSl8lko8ucQUreX9DiU9VS/fhqrLr26s6vuvO7UQlR3KpWAxJwvg0Y5p13sjALkKFH5jfjfDBUdTAjv3eU6HL06bFMphFmjOK0orPJshmENl+kZ8qvBBmNViZnXEvTx/1JFJmUxd+hAuQy4pHbBMt3pGvCmA8wvgyY/4A9z5pFpgIxO41SuHMifoesVJehP0/hKd/VSo5yN8z9MooybdbwYvUd7SWkj4Ys++0zWcO2jdD984IPagw5HlpHMgxwaiKFs3Sm/Nyfb/mghO17Shynxp3pH7nLPbeTjfp0so0xu6tvDaK1dVfP7UsoCwhT1/BQ09SkwjJvA8oBwAZwXD4+56de296nq0EKnA1/Iv/oNQ64eTrf8nZt4V9jOHNPYyD4ajOB91NoVxOCNgR9cNkIoktHqWQ8gAleGOTL+V645O6XQ+Qf2OkLRk7kGZqmKgNeksICDqlh3yAspMjlHXSiXjLyHlO2TZ5HqQoBCp94S2VjOvCExmkRfflCLlYwVIPvL8FTf/gk4nPnNFVo+dWN1+tkkoKKxUp5v3Jzy42ePorTgXI9h6Oi49dWy3jTum3f/hwEV3+kaADu16sLvK39xLwIuyQ8KAmZ0u2DJicx2HbfO+QcXoLQhmqYZmwLAFa803tMQ2Ks6yXvttM9pjac+XhgmNZ45shqpvnRWBEGyOR2R7i4YBy5r30tKu+wabN1CKiC6sWrAeJZpehzn59VRJFwq3VPiE6OyezyK3E0qYorOry0uLbQlhdPbjmzwqwamzbsnpgDFqDytLKw6u95yClNZGBS+hCGwFhtO36euGyalXDszms55ffEkEInHSfrrsOm6xnSjfE9UOMgdLH4pUp+80ONbuEv1yTrgrLiklAz7usRXOqfGc8AGthZzlf7gZxU4QCkJ6YDc72a4UUJ8/uYSp9UVtiJS9Kplm89G6XBsyiKWwA8usnlhHV+bUnl/2fi2ZFfQJn5Nk1d4dFU4kueeSgiLFi9Nb7QIhCfPy8N/861+/1klHhEij69VnZ5cfhiLp0yalJoK/1sbnTGd3/17CcB3L+KWwRVHTid//p0ESe/PT3zykTb+4c9ime8F5tzpDwoGIF8hEonueYRZHB5sBvwkVhWx6zEm6gp6cejH6/cdJmDP4Vx+S5xoTwTIZKmWGb4gc9C5xA9BjPMkM5XZFS6q4HcUPR/cGdyrHJMF7alQXVtC3eaErzGh4c3E8SLiOnKL7pMIlbTz7VAkS929PbTPrtwWU761cT8x2bV2pYBE8jxp+a/wAOg0GbqfXSoJmupvh+UcFqNavSlQRpKEn+xrT77M4M9sH0eFIU6igR4S5u+9Au4s26N3nRRsvDpT1nprcu79+kOjYMYTU4vySmYBWvHRDOly5xYz/w8cQmMvW3wO5mZbdJ9itXk0wTMhvF0WAyoJRHEFriPFSFBRqhvfqxjumWMcKmOg6ryUTUiNrt9qyBdast2U7sTXwythtFRgUbREYIfMCbYNbCQ+HnOFgExeeJR7wSCW7MVuiOM1u6G0s5gUeHN+kkT5psWSgCbR8Acz5b1DR7Akey8YY+KwK7c178z92SLnBK6OxaPAdUUl1Y0on7p4Ug8SnFCETvcMIwmkph/c/xRZug+tGR7lnSl5Pqz86QAPRnclDOH20SXPq7De464BJeHwSxTgzaOUjv/twF2wB8XBdNhLqCHnWGI6MK4gng0jxdWbM2clriV0OfZAR0Glj9ApDpTdKCYXHGSrz2JJyDjFvLGsCuTS39oBkTXcKb4Fe1T1UQJbg3GAHqTjumMXueeSuDr7lvefLSFl2Llx60UnTpiuSHuSLOxF9PvFgd25O1F651f3+nwuRF4Mdd5J0HQjKBDYRU8gzN7hr3aTGyPEqWIpVrUBLa4kiW3QnpnIwPHaqwCrbDqtr//IfOSr2QcCFF3jmVjTmhF32wreDuIgZQCN6lutKYk5v2XRtmGdzSsDXQ8NNBrSuL/UWdewLWL0MXCvt1M2U/7C8deDl2+qvrs5ckmw5x5V40R9+8tefjNyjo9iNogPoPEnp9NSwPs7RC9b/ukI0bOiqLn6cLQ/6ENNRTrcglUVHWaBXqRcI661JxWRBRs2IDJsCqRHc31iX42/uvbJAJRgHvCNuq/ghkBsaKBaR3vqkckAafkwxWCnA6fL0Rt4rlw3YMX/sAsMM3yt4sEioR9I0R7c4l+ZH1NnGXmQZg46rRUKfKC4ZeHneuo5T4mXMgZNJ5X//Zf4sgU/nT2xq6771Z63gBlUfRwbZIqH33E1DWqhDky0wia+uMPDT9Jmz28/Us5duDIv/VIVaWWOrDdtOs75wUTlNu5GRxVyx/DU1rA2Fx2ro2cny7zJ0y1txOqkx9EWFIyE8nRqqruEY8Hud6oaucPAoFBtAMv75m5+EBfP9eNFo6/oDYKnVjIZ1d6QYtPsKH9zBky1hx9jhD9jA7opi8K5Dnv/zIWhFuv5nzOGOENflWX08k39JJXvhcnlViNlAn/9iqtIdJZxwAOZPXB2o+O/lJTk1cld4yE5NnFtRsLWyZvxhdUNwsYp1cFbvqibVMuC6PZ2GGXMiBSOCZ1YTpY0dJK+lPDgarXMcWNJVOoiJIKVNkLjlSsV5ZFvsqDgrza90z72x57NfvRKILBk0ndE72SUIFIuImLL0fliIf9amCjt9SJh0z2pmOxBIsGAtgXD+rBsbHVJLyQg2F+pgoiMKnam7zHrx3YBJaBLqMU2kRsyMTn7GLmawxayp6110IzFpmutfWkNpSw8GItZnnKIbmSiFGhNMbwdFv1Xomcti4cmi0ok536IaydMUhn3NKU5CLVtq2ZafaQvhzKX9JVA6y2Ec1PdDoTdHyF/cA24UiJItQbr1+f2S6kZjyUvQpT4BBwaJhsHxHFTrpHu4B3WCgAYju7iAbAwI2CynX3RspT5HYa9cJkt+kyXz8+TN2Af7S/avwPt/vLYlR7TNCxqBGlxoas82ZiZRsaBv9lQpCI7688l7KqlCwkOPVzVdPOA5IsJjv88rfGtttBlvKS/23ReCV2SZVvaf//T8AbeUAc6X308Iv3knrOasFFrsHJL/slsBfLVQPAaB0qKaASPl1fQSaNlBWjKMh8btieAs8UPm+Kt/ltNJwOprL9pEY/3aOGd7vFQS5CujC/fx/dueLnTds6acfvjOU2nSPeuxZUy70ATWG9fWJ6vF3n/7fwjX2LARU/ANWiNwr7Tj9CJvlrAn+giZdL2tHkxOVkX5oZm3jrZIiImr31+5Q78yQOtZiks5CMhw3v6+cKSnO2M9/v25hrYPzx0ar0IN8x4INE9pkzqRfPVwQY5ZrG9Kuo9TlrHGMdNVRVlQnWgcaFAoMepQqX5Ws5BPZ/CiNGE3QyXpsf23DDgY3ijCDmuImQk7CYZaP68lxSym/45YpYfzZY2xR0WMo3U4OMdC80jyStDKIU+cLO7zC5GmRnVYqUpm+T5UIeDPiTv+aDMNLOmVcCPOpw+SZHuRBjbRXc3uLOpZL9RTg1a9AHBeD/sh9XDLzYScmyv89fgjr2MnjR2t3fE5jjqK06cIooa90lVfRBBT9yK+z+xlRmCnvIh3WxO8ktt2qUlVFNngucIfQMlz4hFrpz/aP7ecjoMv6lpGVc9nrrAbqiQlzsS8b3WJVMLdBmKBI51aJ3sRH21mHGgMBWuiAyh96iCZ7oGGqqOffK4rBg7RYtG3mZAwnKO85IUYGC1hQLanh+kmsZ6O6Boh++C5epqMr2seHn/yp/6rM/mvXE2JzWLMvT3L/OrRavZH9cP6smRQ6CtvXx1x7XguLR7NvPxE7GXrM98u6axeT/I9PU9Hs2ZG4oc4qqbwhqnwH3TvuTATFeDUcn8PmGUliao3Om4kaMjl0+6zNk8GvCexdxHRLIXNVNhHepHPB65Fvsntul/1n2f1/vjEt5KT+M75bEGqwXkyN1Okjyw6FEa0MG/WkMIgtPm7xHBf9B6HxjlpqGzBdxMYMUxU2A1TmdgjhPpZ9QCyTHcaeNHeeiUxuU0bZRWCXCmpRaM3sjqtN+koYfrDLdwDd6Hu+CV1SEHvBAhc66v/l6OTeJzPivgYga9fDr0KMv6SB5U990zMSPlcAAQIgGUhgrz4w4vy3swSeDcf5QiK5+03B/puapL/vlLgOmKUqK2iFKdbGBdVm0wn0r5A3T2l0QU9vWQroKkGVcQ7T8IwgIfpJG6u6Rtex1tWWApIhXaTqiR4G9kbHy7mTsTJnfP+lyGii9RHZv0gIOZlXI6VSrH9p4pnQ3J/xbekVJYQKDVNLYcJokMpILS0yywvA0E4AqTREvuTu8H/gofuupeNxsVxbeIHS/xCyz6CQIhSL7/PIOZYKzzr7y+hRFt3uItG6plosSwEZDqnk8Joh0jBL4LAND3iXrq9s3f95vthq1akLHHr2wR6YNDSNV47LeOA+JCum+Y6hRXBjjq8aLPl7s75WbmWnDgnmlvSC8MRBVXQ3KazDjLL1W/X2QKINsrKUaVPo1adtr524OZjw4FX1G7L1oIVKTl3yFqP4VYIVXrElwP9STVR2AgKjYchodRY2wsJhFpxQm5qsgcax0In9MdLtRflsfNLBBYBghPCCQ1ddoggte8FW3o9n+bO6dUjdEF+N4UiUJ1pA9g9ku4d9SeacaEoXzfCJ657zv+ohtbnFm2x3IIMQBiTkpRF6WHC0Yf3oGFfOVPMuG7AO41fCQ1T+oGsOKBt3NUIt6oDOz6/wcKTOLh1HUyOIhPBeFG/4+BtZR9ff52/Z0nqUT9oZEb9Sdvz8slyze2jdyc/r0Z3lWsmf2nXnYI8A+LrG5kgFcLZ3oDVEIDm4mAcn+yBD/dMiWDyjZmobBlBFzkGNYtw4aOvAbKpt7Evog0nP+ivejoqrbBhTi5+2zcYJApvDSx6HA98sbVekU96j44ManglQQdxsIMKtzXJyntj556K0qNL1Ip50JnoZPDdQB8fiOKkQSNHzOGeYtkZCkZWcvNWkZBPnt54/syX505x5kf/61xGdtM6uZdY6IaIKV/lZtbADqmQ+pani2no7WQHJTs8w/Gh8vJi92tMRwzXxVkycS1VYqdWYH/lATMt0MCcrHs1uvLOTUJujJ0X6zkYgMGp+uu5XhNIZPiQANeZtYubRv/bwa3qpP5AIPLRxyMPdUfRJtzPSqGYuz5fRCiE9UYQoiINDus7TyVPIrNQUW+FbSSndO7DWYScKETy3l8Cnp3sfHcL4h/+9Ar27s10fj3y1tWePf+VJMz06z9vJaHEPZjhL46kMgHCRFR/KmQprEu2vNLl7oxD5QPhxMCd1ukSpbslwxkd6Wai8rzINF+qVH6vaTkl2XW3NDPolKFq8IAAvbhqPSWJFKxh+Qxj/s0W1Bq+AovHwC2fuVvzIGB5RPtB2AbCrGUwg+ezfHstB5UM7M1pUoupCBQO5l+b3SGqznAG5VLQfUJ9Au5laOEBLUP5+hLHS/+VDPbJZK9tLkIA+QT+vkTVj/LjOSK/HkJtYomtwK4frfyWa3pfqo/rlh4r+R37GaIpWqBUtbxAVV3M9+Rw2pd862xy8unKpmzovQxqy+jK7UnQEtOtTx14y25F9HrKAmKmDlq7MhOu/C5jALePr1m5wtgNJJC8Wm2QJ3D65c0E5gakCVs/oiB165PLQj854SBtb4yxwcQ+FW+eyzbFiZbXHDu+mFVCyMjJ2xgU4Q2yX/8b8dv/eGL6nlj8AaW5Hk0+gsZXF9W7CafUGPdqX3Mq437DQ31ZgghqY5PaysmKrTsVZzEa9NcyK2OgyyET6/0gWQTcGEhN3R3m3nMNDo9TirSIfMedYovtWvmF5+T9atM8GX6ipbKWreDUQSTEmcYce1Z4COvKoNOvtcysZvIAD/7KVRCoGv/tj/EDN+Gda5npMqLlw1K2RH7rKqGckwahOBQhd/z5EdDMZmvdRtjUBxxKbARdaJrNkycf95FM1Fs2zZ+nCZoOuWvxv+x10v1p/mn/rEoZnRd0AlMidxNBlgCMAQAIVVO0xr3el9HXC09rwVUe9LzcHJMbm8V5fgbHAeBwkE3sN+BCiPmpGgxAubYRcw/X+VnQ13KmUFrAK9aa2hYpzK3Ilz1Vo0Wp+tPWPx1VV1Lx+nxpNLk5rEUhKLCDK491LSmPPr9/ATwVahEcOqjf2X9dmLfL4s5nsJtL3h9iXE3hqFXkDBsfDG5p5hYvoyHbpflTm/FQrxiJnvBTqKM7/vF/gD4xq6g6Of/O52bm8HNWR0pURBzk0xYi6Pk+wgQDfUqHzoa2ugCKRb1WNWh4CXg3F3othRWeOHWYGfIUXnuIDRySEUeZn766POWr7Q3JtTH2GOInd5I9y4EBUe82BObjL39brs7M7n9GqAgFw70UwHCjUyqY/e3e3I5KN7I4/l2D6aq6DNHHtWLx4d/c3/n6Z+/FNuM79Q4r9fwZEIvXEkeKKK7wD88otraZ6IgUqUFegNDxGBcOX+Ev+CGWFZBmTLFABzVZ3CD/+/HeHy7VD4hGnrz9OHwiFUgDmRavpbJdFivbtKQaXr31/ud9Ij42mhVEQvsRdBirigoWrkeAz0nyi6+h8Akq4eAr6eJR8XCoLig0pcSxy3kEX5FlN06PXgwymCU2HYf2Y4XlpVLz2iEFZ8qXiXDnpKelrupG+J2Lcn20m8f/R6YkE1Vlv5jmxK0hPj5NCBPzY+v4CZbQKvKX4MbR/3TILIWNgNJp338rpZ/4YansTkyNzk6KlFCnUL+2BPkQsn+6Hzt2/39vh3mhcZiM3zW0sFHj0IWQeTHF/moSWd2nhf4YXEO5HyQ5pawW2VA/Udg8oG8ceGs8qH5ecEfK/DDo2H+Lxc7PLh//TWUv6umdnKDUQ0A6MIma49y5u+P/90rrlxRNQoyPP0WtdXaqVRuA4l7oF/cMpb92Eqe73RMAyogK7D7qM7AMBPhdIis20HKhWY+GO7UJCglPimrMjh2iOR0dnaQr5dewg8nzzz/8QFvUqdFhhFXIcouVpbrDc2BUBa/e1EFn/JRFfyEiOV8ixtMP+pAAFb52XkIomRNj7JsD5VgbvVpBrEUCygiq1f2pJxLIHMgMEm6mSDif0YZdZ59X/sAi1IIAG1WeyYUId1MIKlLAiVyw5ddORz6p7L1LTiU3tWRN74Q7T1OwpW4cr0JGudJcW2hAakYaQfdQy1u1SBed6yqClXvpb2fDZRg/9/r2I3EovxFqzbVrY4WIGCOFlt98ChOQCZ3vHzknljxWzvNP69khDjvv+pVImjR3CkkO0GMzE7Kwx+0LgOdNFv38lcNnAAAgAElEQVQFMrni905y8VISBhkOloNfw3v7NlCJBcwCNqMM4j4xKOUCmOSjWJAC3m3AXfVcAgGcBW0YOzd0MMTTWzmHgnJBX54f/CJ2fjnvAyMDsy++eny6DL6dTHs21beqot1KAjuQ0UcN/bxuzRZ+OpT/AOE3tq3TIc73EMmYTRedFYG+yGOUaj6a1JivbxHVrUaIhxa5LeCzo0PKug2ZCI+qEO4nmf3PbpdX1ynig856ZKoEL40FmSIa1iHG3RfqhQGsajfOM4CyZbKcAMHLvktGIMZSslR+ZiKdvjsFkRFEP/heXqeChBl9YICfYkuxjmJyQYptwEgkRufmMM2U7kujYbbD/jQJ0mqnPriPz+df0jDghJxsnpEQ0MhRaW1uLjQVbXI5/Yt4AG8gnNGHrZurKwXE1liNGh2t2KhLvf4ZeUHkt1zwRRBWu6/Whes8Dt+UeGVMOhyNjH6x9Sby4ZbwEmguugovyuUvVP/l59n3lwN4OJgEbGbsTTKw9qB5i/jh/uXDVWCXAMyjjeJ6dHyLrkaevzVWswlDeqz4yK9TIEfdkFut3ICnOYD639pkhw40L6BxzqC7hugRjckyNNTtjjOSM0NWliovuH+xxnf5P3NCmkQ1LUsPPTjhXoDgsoKNSdlHs+cy4tMMZbFONNBAPPakgH3w9igqzGYCOyPXPFXSUL+RFAhDhC2WItT9528pwQc9z8FU5mmBAjg8aK2IJIx3FSYq2d+boViUr/XQZQYpH24aIRwAa48kogOV5lLRaPmb2Wep/pDhYFqzvqmnAR0db3BwDG6aRqwogkB24rSv8geL9fpWPbE/OjFn/zwXhwTUkLxeZZm3VKfXDX+tdGobDY5SNLALSP0iy3JL+tsX3CY3AbEhqU8fD6fHLL3eGQAYDk9fu7tR4CM+iTnKFHlXNNJdobbyLQYIR/tYPjo7G4XRXVJ385tLhS+2kLQ57hU2Up5qiyrft14tBnpOiGqOkKtoBsFQgn1/oN4N7fzaCwk/HJcz5FnwXQJZYqjtYCuzNTd+kFGXhuKjkiDkujqzQsxVznE3fCwhSjA8uXnzPcxurMcIbKYfjYfqBixPBk8z/lJ77JuehIG4HOsco1crq0TWRrpNrNPpV+l9t/POk9slM59uAhzHVbBh4BzYbSTkLFsgIiXpG/68AUtPhbrvmWvm5juLjxiURB46+/nUZGxO9oW+DRGDwKaY9n2pML529k9sLpOD5cz/9kbkDtfup1YhHwfwV1yVql7Q3UYGei5BiprN+KL7YnXSSDWfH2KiC1Af9wZqjIxgGkBWS8D7qHe9NNBqv93J26klu138OmKMLVvZk8dZ7Cj8fE1slpmS82CekKk9sm5Q+SFBmsfoypDFlgMBitQXWnyFEkaNXC5ROj91rkllURUka2jnMNGNwEnVnSVve6QVMmokPWIjCIjMlShdA8AleG0NpHP/eFnEuwOtYG2mPtEwiEyHHDslZ5docLsYuETUDmyupEACerWejWi5O7L1EJ/T/CgBmriBNVSH+BrxZClrTk9rDRW53NEH1pVXS0REUPbiXCNY7kTwNkfmC4ijaeVBSixlMEVHnmrpVnCKJJrftfgny+H7VUq0dmywZ1kY8EVrfCYhyD5jAhVrEyE5lHGlHb9k00HADamPuuzt22EF5/pCy/NKZ0hAQKD/6jVSFkg1nOaeR7gESNWgnFFgJv7r5zaEO07VneDR2nJHmQHfmcxVh9WZ5NwEk46bEyngNSQE9rKkDSyCOSA5RmcDC8+cq8XlvHg0fmNlK9ATLrGJ05MZiY3V25T2qjG9Uz8RLKVlIuIu0+x1MSUPEEafvmhcHgEwsNe7ufosV4hoEd92bem9OooEHnwkhO9fErV3ltiwXr+/0hb1QAWzCg7IkyHJHcaLM8h9N58XVY0wk6la9zrBYymSniMjcj0jeYyhMPdvUhgZdzG9z/nMAFgyEe12YTZBc1XC6i3cBqUlygnbVhN9DPAzvxb101RJgV0WnUTLg9XZeBS+S/BTLHSrkHpmVWrDZI2DuS8pR+l7HpscBZbtekFKHLZHdT0i4YocYTcDSJXDboCPoFkNTIe7kjS7SaQ0GyBf+fgJJ1h2wz1CRvN9h/JP4mU4SzUny8OeJDumKczwycqThLvirBjuRv+KpEPtnZT4+SwsDmEquMlSdIyvo0bSsPD5RReejxKzFHjSdGsBFg9IDjGIJ0PX9BXjAE/376r4nQKxZNPW/C9S8P4/BoI89c1Z3Nc8S/RFG/uQJVrpe3n8h4oFsKJLMOeVZ4HHJuB/oW3uo/1zN7WD7Q9FTD34V09DgEzt2CApsDqBBydfesoLYHvQuoGsL1D2kBNyHdGz1Bm3jijZiNrygGcPfUSi7x6esrKmyh33DD3NXCc6sNcexfCWZbj5X7Y5L69tkMOqi7jH5s/qSVyWEVVnbz2KgLOlBcmbZkpFQtTwhwpeX2Dl31Fh5R7QPXsc+YoEUGlTRAfv3sp1qqTXsAMfFgdfklAZM1qSw7GPn/+ZKBrfI4Uih+ZaH0IyMAiEW33Dg0RnV23LoDAzXTzo1GURWfzTXaYaJl/ERtvN/ap1I3go74OYtIIxsG/WccJa5G7S6HRRjH7/l/ITi1s2AEKPSuoNC2sX2fMj0wVyqfAt5uykdMUmtjgWwu7kqmxZCZGmrnLiaEBBR3XU6jaYPE8OqQLXlYr9/m3ZEs1a+JNTKWvtB3YLfNRCGgEwiXP/oN9+YYu4WgiyGyXq6ENIoOm/A2bWULPScCyv9fFOsuoNw7kMIt2P/O1AkVqPI4jE9nILhc7raF0lsSkBVrzMiOFC/fdOH2AEh/MU8kb9B4cJ3NS17SdGnGbxn3rXmYiURC/vPZCQG/Xtw0Ryw3S2PqtfNTGUs7bB4m8OuMWnZpZXt5FDupd+1hfJ8bdeij9fXfaHtOCOt+PmTnQy2YNgFe74CC6s/FXzUE7zWMPTgbS8m/8QapgVrtt+BitHwsp/+3SnNrF17sNg8lUk0AIhrPpzHxbK0Nb3Y5NSCPNcicRfvCMtiZSKdmwPW3Kd6lubVMCXZFWjvyDNEZ0RVSq8PEjiMHvOZexSurQCd9/fAjvPsvdzOLwKvbXnkJyc1+lWtsbtBV83oZNgX9LK+dWbjj7aq9lYzdBaLuzWhb9FIImSrUXoaLqv4ry4qSQ1eFT5gE7rmGA+D36/FTzqWpusdT5gtCJ+0P+cVYWKE70PJBohqgBRHeqmlRy9SAkbzb1n3FWS1GCHj5GWP53UD9niAdqop0yMSTQSzl+QcYtN7PiEsMSenN/VqvLpm045b9Os8WoLiDo7RbJE6LSOZeW9fSeTtmrIXXRTkbyhHVGcDpQZdfz0vT2ZU5qS4WmAWgs6SOzCNpIxaZQFbnoac3Nm+yafKf2M0/d/4GShRlhLmpnNTy6qmZ/3aA8PIOtMqe/SpshQ9Tm4hhXS5b3G1Qb9QL1v9c94F+oJ2zjcTaxjEvn7v4vObzfepkk4W57/odxN1R4ojzy4qO6cOqmVFbS+KbpHpMQ7lrBzXLysJhWg9cwG5l6b2WL3Db1O6uHTX5cI113MwatqsjvgEAbuZGrBeqGvjnASriswy52NoLXO45pF3GCrS5monpt4/Mxcw8y9/ZBfVL37sRmOW1IwevqeJ7e67wFMvfBYBuhxXcm34tDvn52yx6+ZT09lvZH8xGOpDot2R4HDFAz0byDZ6f0NEBVuPxPU8RxZKTkr5GilBcXvrOz7+DOPDXyG4tfeFTeMEZyeVir7DVBMsBc35+uO6YzM8o1I0cLuy7o6h3JnUQosDhGlqQmCmFk/pMIRFtxhqnfELW4Ov/b961pw/bKlo56+h2LUBmkrnpD9RDscpZUCZYdyQbbvHtJUyzOS1tGl4+eXB9UjxhIFzDC6JUqEb3wYQe6qJ8gN5pktZ8Kh9tqR/voOkI2hQ8JOdJfIUZa/BKgfCiUnY4odh+VeuOKytlkdKptLPOyNpqSMRrupaJOholAlL8JfC82z9cl5HaTdfcUXU2u5xMlPbv9cg4d4snKVHpOfkh+CHADAZYJZe918v4wnPqWCWhrcPhG4XkoDYGS+kZicpgsospv0tMcnv7jehYhcwd5Kggkx5gu28g1vog8h8fkP4a3zEqxqyTUQBllDcLZSIhm2i8X9QTR2pqq8EL0G0QKoJq5ttkumRHjvbcqrnC4DhTsoEsrPVhSdq8T3V4whiT7tiDiVje5sAasy7dSLN3SW9hJb7zNCcXJA9mMVGnYXRyZ22lHp8fO1iniyS7T6C+1xGiosYFrMHlspCgt1deqLcgXAPRdWd4+fQ+e+ieZ6b9pf1jwxAT2DDEC833xiGiKshf9jzTXgF2sDibnMOvO5VSyylRPrKb15nR8swntXLUTPssHdLSLuZMVNvnChyKEJbdIncz48q89HStoupfRwiXWXHj33Qu81Hx1+6e+2kUnkzB2aJSBc7dyzK3UDItdvUNBRFil7pRFvXdXxkWNeXwVFr07Q0MekSEPzrnOmKShaAxkUskA3YV2dhYzegwX04icr3WXXjw2pItF4zOmo5/MGPUDv33R8U1tMcVpvP1R1i42yUCrs/GJKd3uWn8SVcytYkHkpp+Ls22BnL+XDX/2FDhEKZiapiYOIE6RdVIFzou1FpYqWTp1Syln5l35/086xog8z0wX8NOYgR5dKBkxAKcO8KOfDTUNHJjA7gVYD08kMaBP7oY/pj6r0bEtiU5tXo2DZkvsbwF9DU5lZpVxLx/YshUu743lAakocPhulXqAY2B3rtfgpN2e8MEEzlF2xx9E+17B57acURBs5zRvGewIlDt+3N6aiayTCbeOk126sFI1lt9c5xkxvhjXH7f9WfP9diYtQ0JGm2ne5u1AAKvNzsBZVauSoESwN6cacoKozGUs6Hl1bdp0zRWsccZgWJ3saXYDxnQNKgkWCOdIrFsAmXs9u4lvdio375OIF17syiTMgGoi1oUVgn+TG3rPlv2MEOplSqplCholwocQI5C9eGFW4VGtJfl/J2R/jiXbq83N/wgYSk3vbbH+u+jkHTIuWnkr46oOMMvZox0+yZOFEaAyWvJtt9jjMO36qfb/yH4l7lO365GkRNjbwX8DBSGJXcztWmHR4l5TloB8vFi7DBC+54RtG5c1WA9S7L6c6tfWxnmRL2meVaouGCfQZdeqQqvsAWn52RTz3QilIaEsIAlpP/DVMjvlomdSaLVCUAK4eUGIUh44mnzQS6rx2Hit/tphdeS5RoPbya+c092dWFh7wIyY5kCyx+kJUuOqnli9FRj4X19f0oC/jVlqHKZSUVo/ueaZcu6k4dHA+/JjGzS73V6XL00ACpPMSKms9lA/YsNm+uGx7Psw+CdFhh+YQ0aLnDtwMpr/HecA20kliQrgfGSYZMxkE9PB9aEejgvin/3fe9iI0IAF9rrL6RZpwbZ1HI7dK69yR5iOvuHvvV1VcVWiiZjMwxtOoK9jT/IiGhqUeZdyB0M/fOL/80i0rqmV/KsQrcZjrhGPqQMyJvzbmi0QH//ffTp8G+Er9es4lN0MuthRCwkxfDIhyNf7Vj9pkgaW1VR3y/FAH2wJB4GxzejE/NwcLFhTJ6ua27Gvvx4I5dWSiMBClxLtfuvh1vdHH3fj4WbzeGB99jf5hHzCQJiOmcULBExVyPXa2jjvfhSLexRyz9UvgVBwp9uXZzXQ+8PsWBeNeONERdb3qr4d9h+RaxOtxakXOJkdedfMPExtLVlmlm+Eo9lxVS86/4nkSVpSdJsTarBSCrHkPj1+od2YXd+ytGm7Vgorxx09iTRBLWZbmWT2FMVtc16rc/SqI87KONXQsnmvsZD+8b6MZO5LU29P07lwfEt+Hx6MPfM2llUHZV8zW60Gz8IvfCQRCUJuwo0YBXTCV2V9x4DOVmbfK4jHgaI0cNICy4niAYblCSb2R4dgxHdhgI0cQWMaTWAcHhsDQdNskNN9NMYofbOPgQRNjUL65VeHX0KjB8UBwgpG2rhd+SoHtD/vko0uTzUJoAphXB7ssfRc/gVqWiJI3Rc5u94Mo8+K5Q2Oce8mcfPLiX+NRZVSJc6s44XFrXZXvb+eB7lKfql+/LLZ+/lhJ+5aOjvgqNgiwiTez/7PSD50qMouxWZDlAPqnCy1LWnPEZ/nHqgqxeegGXe5pY5X6UQrIcFC+VUTIM/jwacBwIo3PuV0j6YgGQQIFro7gGiDH15BLeLNdd34JqTmAJu3xOTRAQGjm5Zx7OLsUOk3c2IcHYLC8sCNN+S/OzRYR2HuW9Hcr6NhJOyzWkqOCig3QX4TKib5GDyXWu0ql/SFgJVEJ5rlTngGpYv+noCwLb6mBZ/1q1SI8UQhejilLmkgyHUgrijHdANvNAHe4vdPavz2AwPrR8BS2xlCc0CIlKtMUUFSBVmRW3A3vLhwqDIjNVhDktJK6r2OpAJR0IiULOosbYpmv3b0iXgW9UbDTkKDqdadU3WVGZTdbvvdR/w1xwYJsot2MDaBNNUy6YSCKDQQmzjWZiB2yn4tUCJnPdVt+IKOEQwmuy0KpPKAvWph9cI1QzrT6hoQhFz5vNH3w4Ut8lIbyYMIvAG1j1tZU8E5YVyiyhgvDA+HUIC+q8LF4u8dGUasOWHapKENOR4UcnY7kTy7OrPigurZAGWhDcO2XPDkoGQTDh3/ssgnzWFOEsD7wp3MMlSV4B01VzkQQGYfUHt+VBaBs2nCuKayGuEf03F/d2mAApkeKW6WFN+XN55DKDYf4buml8Tla2ng5Y3nY2z8yhyAiPh9TG31D7r0v3Uyq5ajf1e5DJKnGE35lS1gITu6itsr3RdeivagDbMux2JFwcN3j/pIZuD/TICfN8xHUdd7yyc80CN1CZa65+ijOJXJQlmtj8QFVWUO89P9tOljuls9n6uxgaY7PcqOiV4qZjw0xvqtkUyt4Rof1u9piZ8GQTbRL5F4CuXcCfk9s6IulSEWv9kMcZuFg7vnd35nRkNL0CNb6CrT1hJY7r/rmky88bqdodXEAPOSIbkRT71ykFasrNEt84dDw3alOvU+k1luzvw7+7nbGHglpaB1AWsgHqxNd9Tt+gkRv3gQfwMhjRfllL2gGlR972XskdoWBHbiZUu4eiCCih/NalBJhM7HpYpeceQgRJqhAtyq7OqGpiUQpLKJLGvP7640tSzV8h9AQjdS3R8wtgwR1vyN1KccU7VotJ5QqSIu0UhLXvGHNfO3OEqESSlexKolKNkTJXhNjeJOlNO5d4EA0UOM5Rb0cKF7Au58DYywb2LUjkmfMxsCdbYAcAlOw+J19JtVs2bQgqoTSkBGUTN4B4MZYf0zp1pMH+icrtN6WW08Sxgd1Ne9Z2qRxWXl7VGngWVdv8eKZiDT1lJ28/pslNbC1M6DY5XTFv/xoRzAt0u+v5dmGNkRV2OqnnW6gmEZ1dMjgOb/UBMTSYDWNtKmGil2JnOF9/DeY24UMARy4elpUqAs7el+5oECnSsYPpMGXqOstsMz4SvblDV1LBtQT0mtKnfZaqyGn8E3YX7SXQeS5p9JOgQezvawWeezD60YIAh3phu+PPX1SQqtkousKsMw1OvDRY5VftY1O7VMIPz2C6HZm2ahJ6do/4YzsuyOVluyqnxS/FUynPW7L2d3VDbzLFXJv2cdPvw6F/unHpYdRt2i/orJUD7YFf3AP+8NTghBKdzViRKH2lkqgmVJ/PnOXamR4frWkw9K4b0ktVmZANu4w0ziMnV0mwErlj38GKx8qrnrUMggxB5qsifRJh5t5q9/B/GayXFjy7og1vGflNxdVnIg+DNyrwNRdqUxxH2dM6kbwR2a2ntcE1oQTRLYTQLJoGlXG6YIoIefk5XCOkn+QW6ic5XGdcWnkrpRqhO5qnBU7PD3L/BDc+Att4jQjPU+LO0aTJ4A8m2E0adL6qNLq1Q598sUCpsxZt+2Jh6noX7ZPgSBDyfufukWfiCa3OeU2qKCjNwutNvyV1OqbPMmFtZFI8oCFujSFDXBnftJaqvYGC4gbIrPLzgImcjr+IpDoln6pBCDIkungQ3JYpJmKuhGLzev48gjAp3GiJ3DIrqS4O4wvAtQqYJiZsIm28l9sU024W/5os/zL34Mk2PiR9S0R2rX6wPE9LKp5uGeE+VZQc3Zvezdft2xc34wy3Cak7cXIk9iFmxduN7R57R8NNJxLkL3YINEmhjn1kNatFZ3wQpgjogkTJtvbBKYGe3OpqDGZU/G5BGEfPmW/pl3GwLVMlvESSRugqxGmSNc+zKC8jtFyh9jUW45Tz0WpijEtEFQ40cCTfdPtPunAT8fVrf05AKpP8Z8DE10I2/Cq4CjlX60Up2mD1ed//UesNKbOcwieHKJ5Saf2vgfMvZjN+J7PqB2/BG4xx6I9EPQ4HBrIROQm9+b4pSwVFD9N+5XWIsNlMTGBtz7SWb6fA0l61kBiVmOMh0FtC3m7UFnlCXXljWEU5ocdpSvUPUqkOyrG4LxgxkgUOLPrgsmnRbblnVaSPRFsKd8cwiEhAvBvdr1gttobHojq65yyD8dmFQRDE2HkR1GCSWgDZtjvOnbfHlZ3CwP+yH2o5yKe7k2qvVsfr/jEd4koIexXgkWJZDANQy8v3NnbIWxCuqH40nx8pZpb87+WHbFjrSpKAtblzmRqqyrszEM+PYSjisCcCIm9aZg4gpkO+vy1tsMDBMp7+4EU6zw+Jpkr2TqwjXtlE0F5S8YAFkleaQm7LfZ9G7TrcsTfVEQheQZ7YivXI411NQddggE9izgqIsAGch6x2AXGMXh5D8NHa/c9kN4QwV/JDQ4eBvIqb9n6aVq73H9CpEGIKUgmWXvAYrIrV8shsMqRenq22XQus3D4/NGALARuQ5984WiJEU5WT1PJk5ulNNhOCo3GVEjIWuB3H2/jBj8AqYU7GUbx8SCiJek4qkazeR9vsxSG1//zL2/+HffFPm5UGLDLNGOP5M5SUj0RbN7A3NrsMrdLdKwxlCuVQmbMwZQOW3SWqno+JCgNrw6p0vmBeiJfJzKYg4qsHVm2y2bLHVssIhWFNUggGtFLaxbnhsCti8FcUfTGzoLRDAfndDuKFHQf2g5AkYHYXHNHB+QTD0dhQLCWsb2z01EczCWxtgwd4KwxymravWzpOsCko9fwlqUijLjxP15HaUO0RhaF0vWODgbYXtSKqQc7GwdYbiQTr7DpjSXRnALiDTcE80Ff4aFmOivMU82qsgXzSohaaQcHMGE02MUKxs7LKJYMTlmCKdZRJd8qGJWA5SBywPNi46XuD49hR5JIb71pDHANuKreZ7KWGEtDwovqPBsijrBkrdjRBluo1k6CpXggd0lJQ9i5UDsf4r7n9ajNUoHB+dGC4v64A9sfO/sWGCZFS1uengrSdTPlv6tth2A+GzGzfjFfXzM14mKMuWouD68QRuD0cZ37cBQuYcd+K1pgGDlsKVMKce3Xdj5gJzxbzvuGHO4Lq2gs2JlTOVo+UxF4/BLkI8FGnlhw4DP36fulhjIifAWEXBDDe6slxA6pr4iKI8oEoUkhtE4aasd6ELRArUftunssVQAo2LlBQp50SNmgYEI7BdiRDFKMZHiH+KBNvb1OeMerVqq/KY0Vtmelgy536FjDZVFZd9fu6Hslt2tnRnrDci3LQKifX/r4J3vBFLNBLeV0J9VLU9LmDTp5oh8MXLGX/uy0csfTKkK2pGz+Ti+CpmCtNOQgCv88E29gWgCI1KHJBxORrufHvz8G6/kty6yxH8dB8LvMCIgOw0EAtwWVUqI0PEV6x8IaEGSkrytr5kA+FsW6kj3LZIdZ5qtgomzttjUa/f8peuOotM5833sDKhRNBySKwU4ObgnhbMkJiLIVGo9FxviiTrXUkJiZLgSDFpIcyA7sABNeJMZwSHqnud6UY/OurM0GgW5NasRIItVrqZPJsnSZSWwyJ2l72uM0vKmrvHO8XXO6erw379P/+kf/YGW5936e3+/7/XxAuUV1i3pMN5d21XhTGbDOgyoHqorjG3oy4eFI0HLYnw6bsufKavPDhDShfNjQsefU3fdqqJnRIdyCHpDufvV/5z3ngfXNPSdFkVl/BsKUGlEUU2urgddeVJzHNdEGHVWqjq2iPnzj4OmgrtnzA64K8Qop70ytF4/8EhzR2Xw710peHNfGX/9BGpHpgLryGF6JvsEnv5L7QFEqekkSX9yazQrWflDQ1AMZbbTwurBMPO4PLM1ALAkg376Ra8OuSFBSUyN0aFOf97hbZkEQnVZ4Jfcfp9rsk2UIBB40v/fJ2PcraYz9wpooHNAqyICwAL1BswaElW/1YQY6PITLjky3D5r52E5plvbUcLVTH+/xU8cwpyJTMN1YaB/U1+XJqeEKTrr+R7rYnhiMreTSGEZUswM3wpVki5Vf2HzpOJGsFjuM2gc52YrOyWb0DqmAFnVUEjriEX2pCZZtkUIAQFFUHvMAdWtUw2Xf9KNhfnhaiqCKaSELhoNTQbQJvkf5PRekrtVk2+kI+9h4lmeSBIV5SFrCEFBUHAe/V5u21/RN15lAd8i4LsmNRrx/wo1ybmT85HNXbooUP9G2VS6i01SHmf7yR9uxrPXkOkP2ThrzChW9HeZbveajoJM9E5ISXciYYWcswlKtUlcirMqocj5EdQ+30hbj2tez22A1jns5Rur8u0gAllSOOAEPoacWAOylS3Y4Pi0mAQ+OjwEbQ6zpn+k9bU3L9Xya25GFnoj+FByAtqwXHJmiLC1VObxPUf4He+BCfdvEgc83OGsi7UCxbyHiNpz5tfvMC7D4LIn9K2ezjWgQQnRmeVaX034+A0T24PASPYSX9iNh9xy8e7bzF1sA7UYl6nW7sJ2rxOULs0SJlWqN/eovYjqCa8uQrXdfyusXODr2iH1oPZDrE/ouieeTdQuBe+Rjj1gARlZdKzmxe+dggrsfm64AACAASURBVF7UqXCAAfeomR9WsqTp1g1SCMV0tl7GGca2ArfX4sMML8VYF3+Xa5uww7YyGqOAQfywdYAl/EI31og3vIQ7SvGvX8Nvv+TYMTg2n8E5rIhhVujolI0+vf9cGdt6C+Ph9K4/uHQc6qHbQeoqrlCoE9+J06d8niwmOcLhGZr+wz51VggMZxLoUeTMKuh7A9jvJPYATMhYFgPGqJdIzAHo2Ch4e80H0k6BFrCL06pWtnQX6tL2QRxRWm74tnI76vSe9OqMWsT69JHpHk2hSvVqIimF4pYinJKJoGMcAf+aAv22BM0o0MZnCX3f8EVvJEy+01iVi84uJ3fMiHiDye3M8+rNWFcNOHRmuOiCMQT3+t2Kvp1Dnm6+Z0QZBwcT93gdJrwqibfMASWdAuxMggTDMRrhmXKidICB9ybO+HnrtkeNXN8zwHk4gpf94KrZoSTiKsmRo+TqBgRkzYqJfFVyUlWdng1qcyvrJx1kpBcpcZ/a59efuH+n50ihf/n9Dzh2JsZ0HFjGp4vzRi9BWyTi754Pa152fvgjntOJhk7BozpK8hTTfYFo4Ci+5BQkTDdHX+guhDkc9gjWVefZFXtYHip63Pc1n8BZ1roF3022d3WdVnwNs5eWfep5AaSMqV+ya+2McBc/NQGKT3HCaNCXiZ8h6GDC6xDiwA/6PUToBREnVEHgsgOtwC9Ogx/Nw6XDOAM3nKoxcrlaDhS9NrvloJA+X9Pe04FVmcjV6v1RwIUTuLIZd+yeJsWVoh2afQpw7RpF8bIX2dD0J3iPll9wNyE7Q9tRhTMTc9KGB9A54KZq+XIgAJeSQp79h0YvWKvImBr+c9y+i/7y6W77DblAuur2hBzFcnSiQXLpoZ+tqTn61pk/2oUGQIJGBUHaTojl1heF2G7K3dSwzai86VYa1Vk17UpcbfgOSY4yF8Y4rLpZ0PvS7Bovuwclsx1PHWQqy5teNVwzpo0Yd21EzTUDoAjlWwDsN/X+3GqSvOvDysZ2yFntvX0aUVqfWeNOKq2JBykqyJs9rwld78otff3DgLLTtfVNy/Q7R65h3Pmp9WLVSUzx+y0sEwcxTay5XwNb7r6qvYeqWW+/wsCtqUH+vPESAjWheP1KBl9gNj3YSl9/PhEe5mftJ+05UfO7GrjrxrOD9le2BiOqJc1kf1Japwav7GPlNfaX1hJ2g/WRdJ8JPp/PoBMkO5AW9v4SvDthxjpQUbnflwKIfQrt25TegWbWkOKGwBh7oEpIfHGjBDxCmqHBVtLSTbYrUPronWvhMv09ykilM+l/3IpNKtVo2MMMW5OX/vY7pvbW9DIm1afIAZJvObC2DE1hIepYD3+DY4iZq0RD1wqnJ0ehJVKahejZdzLNJ3CSgiWBVt8XQRi1rNMGD4bZMaH9pMYLx5NS6Tb0tMJddd390SrqagXXyABDw7wdYhHMzZCzRLPkmSy4GF6mzJ69tKoKBupMWKdXh3u7HWwJu1t7czq4xxNPF8JoA/Zxv643RGkYmLQ9BvCkBAd4HDVbRiqKq5APRwDfDJwIalyZdcgMNjWOVhqq1o9Gh2MXvBGPLj7ToiGF8zpLowGjTnSkAsKSUgBpjTfqB9OOlh5rEBGcHD69Sr22ExRtMhjj5w9wq9oosuGB+GKrT5ZkXFKkq7iWLvOcEKMqNmvDDT9yoh4JwGef+G+nRbvsohkKmiq6xy1hT/YoooO4uawiAlhoukqYKYODUiSjrHXoI6ocnKAzr6ls0yNjw4x444mhZ3wvhDkQ/un/fd/mawqsUJbJhiw3lni2y2pLY4+vbSTeDKzwMIkNqA17xL5KcGoC1nEuSbASw+ttgqEwWdRpuZoNghm34lJcI32Y++qLSaxk4YMvsHOzW/RsqLTLvn3HJcK7Jp/jwEJ4ObiCzgbPvwprznkTr8LJNG+82LG6P90tZapCAVAdeEKT6iiYMAye27AC3bny7Z1RnA20ThUCXjRsLKgiPginA6CcNIFukBJqDSEAakpeMd7oBTvfxMTxfQIEACvSstGDpwn2HX1BBkqJBDuIOgJ++g12OGMUtZV8n33a/ubQsxq89N8+7cRyni0R9jkGsJyrr67qTnY9Zw3NwCe1PUs9k6ZmRwDYSxWXcquOpIJpX4B16We65LmdX67esjQhlatct2eSLHo8IwiRn/7lBbdFCyR7y/0Rmb914pA8PsPYfIgXoLRyoBE/fs7WMFJJaR6W78Mzj/oq0fE2F3uq71L2mBZVIS318ZQ8SKSsgDew74uITLrrG6lYdU6tT3tFS/ObmngcK8xNYtAXy2/1wv3bNeE0RqtEK8tGKPN0+04GQT9pmdlhvTF7C0S5f/EHbnlu2yAwHwnPREi3Kw6aVZrVQkMHoR4RND/7APPe55Vn2asAyjI0PORiPy0npNlIRQ8R00af1eJyqBp3JH0qjYhMjId256tu4Otah+iO47XyEAjgStIkWwslXjn5/kumc2COz84YY6X6/eAvENkU4m1578XCDBAsxhIuMK3VthJYJBYpZ+LNMi8zDM4uxELgRWCKTTJle+gEc45CLINre0MY60WiJzrhtja/iRsreFeJUcBp/WGeolWBm2oBPz5ShFRqxG7lCfLuq6sFazInLRX/VjOqbccQwgQZc0NlLTLYODqgqxeW/eSUAqlNkgF0ANCX4CSfXP7LhUNjplZVOw2f4Dio7rNZtBPDzaqVjaGzba8gA6wDP72fg+HuRd1oNcmwLg0rMsb0Ilp05zhBis69N9pK90+/WCb4KqwbV/NdBAdo/lDZBcfIe0ODU3jh9kjfAQZGkNbtEoAnyULxEg5jXWgSWSVUbQNcXD8EDiEiRqUCiDEb4NpTUTDkkR4sr4xMI4KH1Dwp/eFmjO+S9LLXA/4xFxHizccdaFVHyXq7VcHA2Cqiux9mVKaxJc8qRsHH6ldk/gOIUkv78O5mew43MYTqjl5w42KnJLYugg0jclLs5Vzaug4+bvKff28+Gi4jrpuxr5r47ydcmmghiehLmj2rVupJpfRPXHKMo0neWGe8siLwdwnpK16/zWC3cYbYhcYqoUkSuUk0QZMuRFH+8Ss/fP/V5YNzrSBCnbcK8zspKvDZe6Hiaz7l0GVNgKm66Ly6XCYJWaxgc/rd6lShfsS7f5uPUbIh6lmN7/k/fuwtXsNPpAj6vWEhYACDJ2ZE+SQg/fSVH8Cd8bzz21K6Li0XdLoB3WRNFCRa5nD7UH46uyihHtHw139Q6Aou39dMDHwoqS/vK0xx9rFBTWDl9MejCtaRQ0QHDiZf0nbPPx+XQvsEIcjbTtIOtOdLILwKab5q7hNAUKlpVU8agGORgZPX0yRxBMe0AFXdZv/VoFaHFOrr8pwUoz99TAULxnyXQXSOw6bSefoYq2vvbUfCQVQ+VT+JAYtGfJgv9Pj77+IVm2bQCLZGZVmrGSQAHUV+82EJTF5kW4M5bXw0KjP3cRiOQBZ+2ZNFcU6JlR1bHZ8yePx4fB3u2mP5fkUrH5qTQFqpRILrACos0yinTTjpd1ytznb0aPGchEemYjqRdcpYna8KVc+Mam8NDLarhIAEPuabFXvT+RFVKgr2/h/xZxgGjLvwA5biciyCl9cdL9tBrkXQdgDZ/f08udsym2V94orPRaxEZdPHPTRV5D7f0RV4TVF/D5mvIEkEegqM3laCyxo5s0pZJx1+p56KpZS0AEPmliV5lNnW9Q/Y9+2LNFdsGRrMwRJsZLHbHWYrFAZ3+dLcqvxg4dnkgVCGJamWh1ShjAXdXC43vdDA0pfKO6S7Ti3zMg8kOw9+XXMoSbC6+b+ZfM1XGH/5+N9OIWDP4R7PJJmz7A5b2R/Pdj7/VjeMNuWQ5AUA9m3N3OZ5aoGMTXKzlJ7TnHR0bU3hfWQH08ucoOvATAr2l9eCtxU/f5gIkUuuivK/9pu5X7Sz/rmwAJ67UnzEERiDyirwYZz/RSraE7QC6PDADMAFiHH63jf4m0Vw22+7ge7lxXK+Fley4Htqn/cBLH6vvSqnCyRDw8IHj12TUmeFIG4rfPcPKpAxdTB3MjdOELuPR+tFgXO3LXcOwyFAYUrPROceOvfrpFF6ArQGo1Zi4AD4byAW1+4+XqNXyFuSPcDqmVsF1lvj60LST8Nl14mSVPQNRrJD9Pofx/n2+NPy0Kpb4IXobpzuw7pKoi6ArZ7e0rJ1aE8nlmTIfF4L+Ym9JKWs7BKeeKlAc8Cr4Uz+RCTkmKr/wQrBcNHqYDTDC2D8nZx2nuvz+epB3QyDNCuqKfNC4l8QcsyKKsjQaGp6GZwx2CACKCwfqU45SU0EJI+PBsxkKFjy4d4yIYf2JhC2hEghXaym0+LH77ESijyoMFkKckjdwZvO1WJjcmlbfbYkBRhUFm9I6/P4JemCkRsj70lb+XZAl+TZT26EzIO1WNFoV23BK0r/VlsZE4/rUvFGrpKx0PZGWhpaXFGSH/cTAIxXCcDaeuvBM9qa+uUrpQqAKQDzWHZryn1aaCTTSVogNUBGdj4cA8OrxSO/fARaeiGi8i065ff97m9kRyg+mDBJePRfXZ2H11YZDolTDdxoEpEZ3CjPtvvKV60K6Qe/TzxDcNPnUWjKKnnH9yyujz1dHu/SHvPORBRYfEA8XrKQEz1lfhuIrwt99aIO4hEHBmNpsP68zleNtk6jYk9M26EL8WUMgSQWrNbe2ZneCe85VeOzjzn2GQHske+JlJiGFgLvMDwRbdlkTsPUXM9cf96j3PNKagRnp3z05FR6U8r0ZK+v6zRRn6J3ydTZqCbo0h8Hs1xCWucQPj9se1IhQ6YjupuUfhB4kX/ogfxFSOzpvMgwLc4qSZ0ZNQ639mwNtB59NAzA2LieAz3Vpn4JsowllTuAmjkeSup2fx3rCKJPHYtaSiRHTYSxOlM+9KCTfFieqz0DzqsM2b7UbYQWcZBa6ohmgHq4k4BfTyTLo3OIpUTBUkRmnJOFwRIeJEgoFNMtjoCtSzTaDXx9Zg4oxklI1tb1XFQWynACukq5pIJTvTDaadfJdMbVN7NyIN++/kA0CnebztGBFFATGmuAQZpOllzqAV+ljRK8oS3JttEmDpSYfQKA5WaekvA3rLHizLPJq92OnM8rlZgL7lOdC1nNx6dzNSqzfR/a9c4Rz8F87uTxEIRvOxWDCJnUjLjfFzrpKzjZnVrYdYUPAheBye8SGDnpZVRlXl8eFEUu3a06MpHfj+zwyaaq2k4l3t3X/+KP790zrPvygBgOWzsX7rEYj6FiX39ohuSXfNccM0LIXAd1PcVOKx2Br8L0GmANTJ+944W6loEbhKZGry3ie07DEp5AKtZmBjKZmZxvwQbz868dFrEvdtV62cV5J5vKieChpnMTFAhtTpWv6H1PLBQ32W4pSfLPCPUMut7vnnAO3ru1/z/er8l3vTQ3LQ55RF1iVTz9i87dp1YxLoqVbizXd0/KnGt3ZZKSE3k9+FTJcZweERzzQdGMnY8LSouiGDWQiXgQjvk5p6UBkybwj5bjvJmpnyfjoporPBZhTXFxZeIqSKD4Z1eToBzD6Ygf+2ipkocnS7S6UlnNc281apfE1kZMDGoeFwzR6Z+qSmWlkf7uSgg03yU8k5ChN6asxWowFB0p+/H2Clpfm/loDzU/1QW00DcD3dX/VueINDYWmUd6yLuueS3cXf+JHmPjmiVMoZSO3EbjkE6ndud7pab/rIfGcEWTP503VF2ovymt5Tbds91voTAbW/rP8vFkTketb/NJMK0x7v/0+zY16xy7SNQ49m9Mp6Clv6aS3Q0MYgesEZYkpmOeOTb1/ZLpg7Izfyvkb2ejTUJ46kGnHV7IXm/zRIX/Lox17P7ox7dANKL43ewRD/PAOnNn13IMjirOwvEiHT5StmrAm7Jm8jp737//0UEBBQZfBWBpwtnUFvj7ZczjvLmKox0oHq60JNs2g/NA1iBl4rIOdFbMPugNpjg0Ht3WSrI/bjCDN3e63M934Jo45BGCsxxhQQuNAkOVqB3Mt/eZ+PhRyybQInuxkK9fcxd3RAStchLJ4Fbmbfbk2dXNQPYJ4yn+W52AWESMlQyTQjMVt7/Td/ygXSx3Hz5f3nkoPyJDvr1zGVkUedNVFMUOBlrsSFAjTKboQhs0deJ+CcaYqxkfxdFwiZcF+r/X2+ZCAwa1bd18toPLwC0FlSJCx3NIfPdHxwiThHmZXexVQOzs1RFKBoYltkybHeUOw+nybNRhBp+ZeW0EGwAaykoNjFbtOXQPrWIspqDqBWgIm9qEY6uKp/rMgOAdbzV+WzwsR9bFz0ZT7Iey8/VD9RcOL9cvCZ4aZ/deq15gnJ10CY8mwbf9itRf1E7hgpEClNGSzHE/udXS5BAercEoNhzQJN40GzBN8YLfZx969wPfZspJxGbW/hPKD1IdkpIa3Mq1lfRVvVhsBawLXEJq7+GLQ1djtdceuJ/TbSbR1Ow9dQjVqUQcKZ+MCu71yQ1vtk7+D6G6yOx7o25ztXJUE70iasnkfSZYpL84177Q0RG9HTJ/WCN4Z3Nr/8tgZ7z/v/AN6ohVeqyuYOzx63D6HVWccnLeykM0h7Dxcp1J7MNk0lVQFIxbuIpGPEwThJbyZX/DBsAWfCM2kGgIZvnWW7iMPF8Fn3QpBltxU27lmDMmNPTvW4dPKpuvydlLgxYeimmyup9XrsUPtkPkKlGj0hGsofAJGsQwXAlB5lc/7albSKV3JhGft3SQ0kqrRevZ2OewGyOwCuW5evm2hmDBPu3QAkGWtP3jVq3dLIBDYzO+ciTkjWbcELeXoIWZ04k8EErDyZHyVjXEfzbUS5QMZG6V3fWCf++4OkadO44wKm/pDewHbUZBewbsDGZiFulLE2cHSq+UGpMvL6A4fXHJFVfgPTrtPEFh8erjW6UUj8V8P2LV7HZdxAWJiZ4pa4o1djM9y+PRdQ99l+uO+0esAlEw3vArdnM4NZ5WmqsgJLXOiTs7MVJyAkq9svLJ79IEh31/QC2LQBvabh8kl9DbcecaYNmGMlWi3W+I2NK679ollbcyJokQux8cDL0Qzw8i+w9uggnadU0SmOhfB74aKvAObrqgLjiTbmdl5UPSQuW+Cod5BRdrCr3CwGbetgf2zReHUxPOPjKCs5h5YwYnv1rEEi7+tS+QaWSpsDm+9w3dnkIVxfb9y7L8nKcFX0SejZB1BbbrbXt7uUS3pLgcwu/+Ji1+PvysLom3WPHf3/VBTS/GeoFZDCjDhG+MjC5dLpGNtjZJWfcsRjIePN7G/c3Ha8tHMzpp25sHydsXXVt0EXttrE4GBkoVjjj89HNTx3WJtyPO2V+LGd29SzIlRL376QRor0g/o3OII9eufSsy2BF3/Ws92sbqBaI5712kB6VZn88OtAqze8ctC9IQmcDmg/y3XNmw4cMfAGAzzfGSkkrAABhVwBoc8ckgfrnfNw3FbDzIOBrHc9d5RnKstR4RleKVeoViTvsznxe0yy/V9v5+T/I+ut4KtXuKpRbb+I/AeCouQljVyeDIlWAuZFavT8EzY4rg2q/Bej7IvOmVrpSvZtB+yvqQHrIY1BnF0w2r8KiRpux2gu4Jz7f5VBGT3mP0mdIGjHWuB21AyNXG6meS7rwe5KzKf+Cw4dKBfhGy8CWuMIVgmEHLyOFd9uUrJO+2DYIehk1DMXr0+tzII5A9T1Yk0Xy44avtN5ahXR+ujkpc20PVz06uCd8CbxOhQaagQIXhbcBQYf7lx8jlLFyj9y0VTDDz+1yA6dXA2zx5z1pdQAv/ib67sLEg3gA+mmjhdCc0+HbvgE/OrIdFd/JonowhWRUcddcDeRvO2tWw1wP+z1X7jXCjAO987pC2Aqg+W/vUXABYJNNKH91MXgifs/N9py4GgbJWV3L7IF0Np9ll5zEmpiGM/qqhGd4gkLgFQlqDbGn+dpTNOjkvI9CrEbxkuPRos+zmdI1HTCke+DONILkIGMTqqIcPNLNJZhjgweRlictRX+HruJrcl6o6WXBkXvM+mcK9lFGDDC9thErgxaQk6I9OOFgamPwrpgG1Fmvoftfe/OONvH8GLOWqcu2yLTaVCJPoYUm0Stv16w3u9K4NG9gfj4Ody2AdPaO1BQJ3LiecpPApoRzALjToSlKX7u6cvGJTE9aS6b1Y1YXwYiteOvf0uZNjsUqqFUXmwawxMnDktE6oqDaopiwDqLNC8S37CFbEP1SisM2bXUj8uSx9a0Pf3mftDFchg92V/tS8eFCbUMUQSxSjqR/Ayf94Y2UIkJ7HrJcu5FVT8iKdBrgjrDouGDgUG2J9nMCyIKRpu6nsmvS+XF4HfcMmOJquMeC50tQVmsDN7WAh3Fi1oyMZuEiH/3BaVDGNdtZnczV9sx84dOtodJaBgpLvV+Wdz+eM1AuJ6DU3Zk1MCDZg0RJQFx4C2xs1h1GOFFFwZ35wSL8xpVzZ5MXE+pHLYGn/9OuPAQnZ/uTC+A4GPdqfxYdh/GLZidpr04Gpjv7ExP/zv4OCkaraN4Tv3TsX/kKMJUXlNSRyIhULRTglEpuNHIUmFL3sdo+oXVG2usDIcytDd7zjYoeWjigl8Pwfw8NCAfQnjiii6IUTnBm4+aa6UW4MNt3oDzX3C/HjW7E4h9LhmKCEZQNTLBasi34TI/j7P8bpmUT4yU6Jvli28md+uXAQaXiBaHOcu3na5VAU81lTcp0q4U1eV2j8WA0Oe3KZbBEgNND6RdrIHFIlroyFjgCDDb0uwyllM3amsrsaRv3JJARsKdB1xSLRJ9OZogoOhGB9qhA3KZCo/UV4u7sn6spFVbpmB6aJ67DAEd5RDq0ybp8EUBK7pNGFmEKC3EWnoldc3zLXpoIpW0gxGPFqhgB/0+0VqWAzWh8SMAIiDShHib68RJzDSpQa4dn0gIOL1O8FrAEVMoBJniBH9yt+KgcHkYgMXu2bpyypgGYEl8eAauGptzWiN7UkI7IsQ0BCK75vGuk1eAjzzSFqTWAKWdgVaEJoA+SOtAt0lvXNnrW9p1vRObcsCCjLhsnT8B77DhmVFOK9pKSld3jVAZt3NF/xf8QcJ6C6Dbz8gjftaX7+niF+Ddgah80+UzGgeyTB7VQNpb99ZFgAswiRJlrx7L7/H396WhVV1dnlARAtvm+Mz4DpJ+ynCyewE6grp9bqotgaUlGE0d++CoOcTSTbrJqGaK3OIs7alo6dVuC/VYa6vRE3XQh0KFXUiBIib3zrr0x5Ka1VOzCkSr8LmBWDKTgoAocxjm2h23onrFYkQ6GzN8LUYBA+r+qsX3K87HrognQyNnzCeBMcZlV+bEjpjS54OwaCMxWKzLyqxont34t1N8qoEr8jSQietB6FYiJQntJE1BbpnjN+Y+x+x/7Jyv0vtpvpMwlvqi8IAlsVXnV292wZBF1PTTPKVu5fZOPNdpzSqSOADl3GaP47hDEn4lbPB0Nogx/8RHhqvuC5ZwE9Vg0i8dPfku0gV57QeuMz9xYingtYIBSTfoAp14ud1U9SPJnWD5EhSR7U+Y0Vp/94ZbHFxbUAAj5CxIAfsNm+dl4ZdfRGFJGNS0OH28wFfRccgmOtwYXIpZG5YHvsoQZuHPnFi+2L6rkPqhSotNH3URs+A/tjGmgF61w/l5+wJ6axvS58OITIBmjuD4fcH/61ZRZpaVqpknTAoQAyDJNt+WrSAIMptIV10IPSKjWALAS8U7Vnmtml9K5VW+Wu8OWDKt4vdeMjvu8ljVZCigeEmaHwh3+4suIeD/BlfQJNFriu+08e/xEaudbw8zUgA6MyPl7ApAiVk35AasSh32YDidPN8iOmPZs5ufSxpniN9ycN66DqSyO4YVwXQquYhAZe8+PS7YqFqCLFyiV+MdbsydGmp1CcW10Efizymy2wVtKAVCJGq1otB/VT+p7wDFTC0NNf1BztrQ1X0eg5tlBb7DQ6bsyNqCnbYHSDSIIZSuF44povnzym78v4pl+y+5XAh5rlY9XJRy1Aj3JfOsJ+7Ow6V850DAHRLBy6A7wdtHcv4M3vZaJYzOnrqm3wC0KlDFzA1jLW6xwhdCcC/Ukg4TdccFyRiuIqpsyiCFx4dRUdzz09QXD45XcH49B1Xf3Wo4OFJzjOxipJcQ8BqDqv+ei8RgNOz+0Zx2mogFZ0zzGq+TRc6R36HrGRFkvIG4+xdbzF9WOGgncqj9u7AVcPIMMaC+/vww0NOlSPKqyaHAJH1V1iU01TjWVwRQcex2h4QL5b0bfAjm7c9x4brJvLFsHNcaeJHayY/QfXica5AHRLQ6RBWQ87eHj9NYMMbqkqdkqu3RZfU4GHquu/zpy7csIKwmq19ocHPvdGZxFOhTdxauW+DYSrHGxNWijLyGNHWAzFZVHHD74J14A6qJNgL1XJkJRAuyateyD09bTnJy798Z86HRR+rMrneIo3zmlfeiN0MD/dEcgOr6RgBkmHt/vrqKrufLHXSvwS3qGhASCsrIPIFOU0cAWbLdVE+/p/TW7CkQC0NHCUHTuYV4lJ2bJpS6XTGXx4ATxv/Z2nc+aW/pWFoZ0HvwW1mnQlFfv0F596LjxAzFqFzeBbpA68VvTpqSX87H3W2yq0XjhbZz26TgkB2bTl9oyWCEx1lcDJXFtv9fGa+dJ5ILSOaTXn3s1FOZDWzLFn0zrP2NbZTs51MuvQ3sNsuOqxQOvX4oeTK2w0MPXoKm10Sd8ldtk4TC8liPz3/6RvZscqoYRClkNu4Z6Phy2h5E8b0yIe8JxDvRfOMs4A7tuDXDvA+Tbnq4R4skMLAvJno10hXhxL4bxMcOdrsdr6ofABDWWOMVTi736CuWRrapAXalHeH5QgFRa8gSYV8YFUVk4uKeyMLF1SbH8xqR4mOqKXc08j7w/lvE8BrfOnyzodukDjFNM7aJV4Pfsn1Tx8XXcTHfzKQzCfATWigndYfPqTBSwprIY6wTyeuUm59o6vNO1SZDVcqwAAIABJREFUPD+sETYmY4/ttQX2cOe8JSBi9tPKDha8FYeknbZv0aOVIEPcP7RpjtHccx3wU1ql/zJyHxxNkoDMqQuEoLEr1Pw2w9vdJGpzLT0P66muDzb91fTckP/NXchlv2Exh7a8cgIc6NhxruxOUDHcfIhCAHUQTLA7gtSecNgvoGoaNMKqwKrCG/27lzBrsEgkafGURA6k+B7CD/UGo8oxTzbUnoEpWsXzw8nPUqBbgfe5PWu/xtZFxDxQu2iXxqlc7SEoFgEN82NGFKRbs+Zrr3zmimMWDVtiAbPnxz2jbbOMuHu/mQ2M3TalRZui795gJ6OHlwsLIiPM64DQyLvmteuET61BGZj+drzds3LM7aVSABucPIbrMwQwOA9U5iaxDhC5n4cMDc2A+Qi0azMiHXhki3QlnCgWh3qH27xWuhD6srQoG59qJIm4Wju8z32VIQDzlvrVxp+XDLGHjmTu4NXpXBSu7EpXPeTY6NkncU4blhonujqkOmntcPqwaLW+Rde4H8iAgQ5GOdrtyo042UH++CgqZ6d46mREnSNuAuEG2PVkhrx6FsGwIwwQ0kkv0MwmRsONvG2jKof88h4vbLqHZjKE7+yQi6nHeyhjEaVrxgQduuH2fBUk3pR0b8C7sEWuTNpppTSdzqPI6YMT72sQ/vBY04p7Z9ayv7bISpu3+KbhXQ8qZDYVLP0hTZ/eOuIwF8ZHYWr/PRiOVMao7Ik8rNGdt0s23q7fcelXz1ZyboxruOZiM8PpvP7EifkXf2sCouqUGV9/Qsl1Wlzh0xht5o2StHda8vv/s8msb4Ql+B6PoQHB6xyj5gKFm5ZmeJh/hmK/vK4YDMbpQ69C/+WNNy740Ua7NHH2Dq4a0qNux2tu3pk2TXSBeKqxhKTcnPY+1VxkBdSdhFM+oP6iDtuhMHjO+c6GdqTrRURMNADIBCpe7EvgQBQSqGFTwrM+4l6W5HAWLYKBXgxMtfexbszC+zBbL7uPIhTTq2OHV6iQW+sws871jzyLI/Wf/rnGxK8k/VYGNjrUvyqLddWS+kjlzeYGsTxJvzG92Tlc+z9r/VCdAgChWoG/OyfG3ROe4ivv3Dq0NxxStUwjkCLzQAu++Ne7opZGbv0n4bmowjpW2YVUYA8tsn+9KiLfOfi1FvrqiUJBFBZs+0D7QhAk6yaw6Slg2sC55MIyG/E2UgI4tsILDE0DXwrcC3F3wG+ZspPvaaVi901sPtDZlJXTgjehrriV5tD4TTfsoKYt0s5La62yEQrHy8aMyWA0OfeJ5+5Hq3WQQs/KSZCWiatJmOnsU8HYSkDC9CbjPlDab3HpEMyC4NMMM7353z8+OhoBmOWSmbUtwcv7tf/XmS1B5cXNgODlhRL30Y0Q+bfTJzffPs5aST92aSRDMkPBJN1bj7R4WwGIlDUmAkmMVkPOSlE2Mq1ca84vai6EwwMCZKYj19YEd6u1ikwIoG2RlpklF6UV4aD+pyfPATADqJAjJppUqM6C+x/EZ/yujqdifhvnuX7Va0TMcjpspChMRFFdEop+bhTHt7EAoiIinn3WRI9CMMR5XP8CGZiXRWfu8xc4VPDxgXkxRhw6Rz4qlhH34dZGeQg4yOdTALUDVMVwt5E90ne/LHGdk6pWNXfIRxVjVjdG0na/oa4RxG+iA/knwMm+Au2AjCW8nnie5sNS5VS3Qj70vRnv5Z16ISR2P0F/kyhdBFDVphWI0XnqAuoR9wOw81BPiNXMUcH34U4HTKjpyKXc25WFAmyfWvG0UsZRBDDlKBRspsiRQyhwgiy8PKyCkacNU4zftvYyrc9qD4WGI4/DsqpsUJccEBB+vKoUpgLsGoOFntBQvowLTSooZ1TpdnAv1VThBJklzP78E8ZOf0gFnnWuArqemTpRylCNpfOBFo/YHZaXb4HyNXWrqRv96Pz42z1sqEjYIARgk6RWI/bZa95nVgLCuuYrsr05L4sF4JMTm0sFz0lqM5AR0pG5G2U/qZCrzAncmXzCpwc6i9jBEAV+12J6vISGdbQoeQWDI35VxPx6NRBfYKSv4sLLwdZGHNsZz4mWNBUqbcRoa+7nzae7AJcik5RKAlv20JgD5TTcKHvNcBt5AO/bvzI5TlxzSvkupOBkF0/066YRTeLBk7UP8kdkV6GyOs+kHSHhYKy9nmm4UqQ5WC9WpGiGmbgcpKdyzYr5gult6FnEGnWyyJfWREmqCAGn2VCnM9mQRQYRs3eA6kHcig//2hsxyoe8NPQLyo9uSqgSetTIm14+zEB8vfifgWt6KutWAcc9D3DwS6y6nY+AHxVR26zJtPGtTfj+UJ/30c8zPkFrhhg8BpI8SFHjjq6Vn/M7x5meG3NC+m63HYpB7CHPlCkLQida3Yd7Jvqm4bryEf1NBljsnwNe5v0AoGjTLnGfMWcv4oMdDGlMUjosKlZlSy0Kwp5bVZbeyqe4/dlGye9Xh8VSiMsRotMdwkaHBPIL4CeT035BswWD8FaQABblaFzstR3Rd+GO4lkz0Pg6FK2uIYdoiHViHZbwnerUTODGgvFYQWeazJPN9JW+QNYP8SCMZBh3uxiOVCN9HwHtxhYC27Ho9DYMelQgTwBSFlDS9oQucfzh3cC+m7hGIorjj74BCmJdkIhlnpCPLzNirA+wry/McAKrBS8o0DR6NaEc0wUsm0IV79x3iFVitgItj3zty0ReoUc3CPZZIC6RjF7a5l8JZIVNsGRXvxMA4mN3yCcMeaw9cGmlZ3tX/cfX8oOJ4zUqJ6Bj4+XMswhFT2DG9FkSvpQ94i3krQLg4oZ6bWeyuTqWwmbRoWWlx5dloB0dVYFkbddoEAa3wI44Le8il+W2ufNquXXxV28+BhYa+1dNpjo5OCnEh/20osAKOxf1WrsX4gQdTc1K6prMfrVawDzEvv7cbGfMo/X75AbQzoQ7fTtbLeoYY/3gVdtNnvfSZIDhjEVVik46D7js5wMtebViSmlT8KE8PWK+HU/udgBo2P0KuYqggJMJmPPSkKpVBrBYgwZvXwi9LUki8iTNkn6llHY0F2tnJ4OjrY2cdIN0lSP+979XGw4p65pO+A2Fs2nwYiiBrLEsMBqU5X5U5Zie4OSzFDUNVoCSZRUlQdXeSSAvudV+Wki7JRvzMHuA9640w+YqvDVKbcI15gBRkzYyEY61qRpP2qGOUvTZGgP1KFbluq9vYC4ilvCUskvVDPmLRYrvZa39KGgE+VotKPglvjU+umnVomxQRrowZ+ZAcfn+3IXT7NqCg8Y9APIZq3RkeCr76qcsvksO2NNgyEAMgLigxGaywPu3I3RRtBzWWShUVSL8u0+wDkJDBODE3NKMNtqvbV1A8Ae7Lgei40JSA68cuTy6/odXQTSWoQwMnX6pfM/EIU08ZCi8stWYvMmmapT0H2U6WXF4MFGUuWVR5XimLPJkrTbqWntxYwZw4PZDdKRlI3oWts03OxhWnqA08JrBIYG5H/wukNvVpAmx2+dW/ukPastwV7aUevWTIsXrws4FHEAJe80keQ8f7ZJucZO08pxYueO553GvDf16zyAIAwoXHxfA7TGl1ESHC2UvX4mlL9UedWWlYP/W8JoKmM1Rl5QXbLHDj7VGi/SxyyhPUc8dPLRH33ZFgarVrHZt5i0VG45QVOriq8uc4g+3Yo9iIX4/NF0jq+C9usXcQDeOkYC8AD/0ygOIIVUO516aRgKBVSvy0d+7xoa1yw3mv/s/M9fmCCKJBgP7sOYGqZAr0JE5fg+VzE7NoIqfDWe4/cLgY6dTvMjEGxjKeB815DqmMmOjtlyk+pA2sFo15P1SoR7yLn2d64sduyIV5ggFlW666KkZNeMKvImPYgOKjJxYFzozAh0Lic+caMc1nGIXcVw8DGL4EOz/t7//7eufEph60SItbq4/d21W/J3knTmRBDKQidnYFlcgfKscfihf1Byh38hn3L3DyM1AawzYA8SO3Ne1SVUn3pGcUmoNo2BIJYtXW6azATNcmjSOGkjRQx6G3yvIQAV9rF40+gh8Xkp9GQVUgcffXzny/j5w6giCFsPRP8P7/zr94sYCo3wFhMSUk1fOne7cWNdNDSMntKL1G8drv8EHmlYd/kcCKKOU7hokRaOT1xYiAUVig4fa73rG9BpRdiCm/edTtwL+6nQ/Txkx/LbzucGrbcMM/a8lrd3Gc5i+zV46+LM63TrWB2KYI5wkbyFRDmAnwXcsrBBXS1TT61Q1KhRe8hD3qeg3kob/5bGe88rNJsGKu4raoeUZ8ni5jtn04lMHPFA5mBNyh06JyKknh0DG7DijxFhtVnEj+CDFICsfsdtwBePoIw/07UYIFTDpbKG+6jXljN/tSl8JcquvwEndMfrMx+XHKsnocxPzG8LHbgEEG83HPbaeYxpZd2NFPzhn57P7V3UlyeQNso8bqBC4m9pma5xFzt0zfXQGOyqghsolRYyqTo7Iwo1u0IBieuECYCLp5raPWWm4NHHlS8xq3mVf+xSrPHI6RZElT8thsMvD5OuhZCZkVqBOfXEYgxiUHQGNq3GxpzQD3U4JGOM3ZvWwhNWNB01MZfN4IIF5KcjGt2O5/dnEG/u+ZesqIW/ttUuDEhz8LQygGoFoaCOmU7z1/dbrP6TmB37xk5Z9sqwNjN9IMHUT+yaUbo/wWa2sxvOOBhk4oPGDl9/k5TTja8bgeWAl+2pWIhkpgI1cExy4mJ+cyOsVuK0LBbZkWCJtxwBjW6KkWZPxW2GfLH06XXVS0CuC19tk7cen6iBeSX4QNxK90pGFc3Pzo6n9e08jylvzdH+oQlb18S/u1c7yFRwquXayUWDuCWF1H4218iRVaz8p4+zEWS31eo3hDMIChQDHC51W/tdTklwnfUyOUr9fjl23Wki+FLQinwIdpIT/jFYESizLCqBn0wRLyb3P5Be+VgrVSi0FDeF4pigTwenRcuM7CzQZX1apEUn3yCuhQOLM0xEMcJHNC5MLqGw/Ah0TgfmkSay3oqrIdF68IL1rWi3vzBxgSGZia5/8kyRE8i6qjNq1vd9C6XEqcPH1c1YqpCa3v5zqbQeq7VaK7wrE6Xy0/0VMm0F6h3O/Pk3saIR//1puVKIOVGir5yXphhw85vbQjv8vvZWMHh2yazRL9bWzJWM3w3vHQT1R04ZjlpQXENjS/TdF840qpr5nLUv/+8NwLtfpstZuBNJNLd8qYgXLGgIZJSxYlBQZcLcqSMMZdN66Lhu4WPDlr38Nv5AKQSxMWlt/Pdkh3FiiXK0vvsgWfy+J42F6TIevT2mf3Xi9baI81q4PQaO6R2+d/Vc7ddI5PgViHvilnGTo9Eo6Twp/C77FQ/l6ZqxI4n4/ElRaNF03cIAZeCBx1oapXn5muBUTLV1pf7DkYAxKdjnxqsnLaz9tfPUAzopaeb3i5yYrvFRwSYCsoQ4qTV58MFIfochElVgvg1uPts1tHdL5NlL+jQHICqwiWtvNAFIFSwRRipteeJGt+d5P0CqJotwQxNOy92lqn5eL7WAEbKpRlfa0sfVdD6u6OU8gnCWiTv5lpXRhTagHTAIjxIqXsEdL9TMVTpy9ILLxZztG+sBqPWbjHoVFXOpWsijHzKvNngR9PXLTbBKDsUWpfHCLoErdgw6EkacnxqVaIRQfvjh3/v+NSuGE7Gcj1kVXrWrVq017ROe8PDxVpEjG3S44woEg8M6NAgorh0qhHIFOJ8ghn7tuSqRmsaNSqCB6h2Y/Poz0ZYi+D8UmsYIKVgyHLEMqEbtDQlQMPnUubAN1Sn9p0jaTkqPxZ2u2WlXmmBvZDO3opN9iEdSUQlu2zcTro71pOikeFvcAfsBW8zfKXGCsckDrmLTeBCrFwHUCIlsHH9V8r+sAlwYXwfimRK0FGNR3nspy6QyHc31eGWCEI6ShreBNtnbQ6MG25wfaCpz+ydEecIQ8c4RN8gnWkem9ntrLVqEKcXsVFKfEURuON5lBHp4TJWdqJ+zC/VOQYvsv593/8vYC/bVLcCQEBOOU2ffdJPJuDqopY27wwJr7W40oVf06vOzubVrRSGJxlehF8+non+EUwOHE3q4Xu8stgaVHEEbNg6ERU87s6XxGUNAvhfh0lHOd1tSdL2lkUZe0/kYnl9SJ1WxLqvHVu9JWY3aeyI22ogpDUYjPaVRdxN/YJVf01JxiyohkPNaiQqjZbAnMtlWvw1DU6KqdeHdLCgx2q//jRpMo4vfoJIzbtJ0wUtXa+T6i+Le/qRCIo/0cBHbzZhXFrJfoaOphCczef/7PopVrmNERm7KP6f2HUoyJMun2/W0Ij9E4ACw+zg50e75MwlS2sWykfCxin1rU8ZJ0OHavwiUhA3dvx4FA8pVPB3XJ7U3pCwBPKmmcyw4lfRuBz11pANaDBs0qJDgKD10Waek/xkRPSngNrdwKfK5GYV9hU18+ijrQ6R80NRvrwub6CKitquAVe65i+hPQE1eBYy1oU1XMxsH8d12sbuWyS6cZTygd+lyAK3Vym6Jk/XPukQbpyv0c9ETbeiRfjhhMQmcMRP+RS1uMgV/UjlwOwB0hSrDr3W3GqS3o0B/OOGsOaIRF+EOnzveg/c9j0nUJ/dNTzOcT9du7Me8Ud6bYBAdEClakr0o0fNDVeUaEsHd/W4F3ITGiWMD/ywrD5wJ3Wh5q5UQPgHMM2GxC7ZeWMyQ34uNuVB95dx9E7Wc+WboduLFZe20RoIwp3vRdnIPm6Z+eyQrEbPqFK0/17vegMlGINo9ovyRfOMXDFj9n+q4SFzA0ST/ApnZ19rC1HRoQ0gEAoagdmE5bUJ8s8UYE0BaAY4CI4eQH72X5eHigOgNVCt+oGW8nzXTRKnDg1Asj+hNPKGKeRpcYKUCW13lLMtPIfHSn5mPvIqpUa4BoGqx/VfchHnsBNoB1UnG9UGme/luPohPz1jg4cKnp7iF4fc+l0ka6sNErunO1Vc9JQiYdl209Bya9L6AasrKtN/ayK2+pBJcXhD7FLlWFLBYJRDhtqAKVhaoBnWVJMLau2PPqsiPhZUXPSvd62YwMrj9RMr1b3DCiOkjXaqQ/HSYIU7ENnctKVyw0ckwA4IsTRiWhEFDkKnieffMGgEwVxWq9DHurjltEaXW4jryHHm5VD5Bt9QOdmCwEFil+jVAJm4TSh+n+u2Gs+/l7wl6wz2q87i5gS049vVWbDMp11Vr0GqDEIv0vaozSt//lA/uIux7+yi4VITgrUGfnX30o8XyGITPanVlc5KZbUlB/GyuKgRTHV8l3qByzQSpak+zf8sc+1xR7YTA5gLO4soTslOPHTLTm+q4fjzReXSLZoyMqkdHPQ/+/LaS5nlv7XG3X3lPCaIkC/bp9pm6CTr9Q6EHWgLDtyKvZWg8DvL9B85bhAmpWdJsN7Ip94QH2IswQXEeplEHTAVKyC1wgCq8/bxLRkgkZTzEoPFR6u+5wGmK329swMiETRALRwpswAdFr5JP20XbFCWWrhSFrhCHpTC4CLtzdtpg8jurnAJcHfCM7IZBzeukq/RPMncfn7rH9BlMJTMO/2EJ21XfsPSUWtCuSubf1uHIuoaqdUN7kg4Af0uh23fndckoFjgFq1N4YUhcc0J21XGccP6RvpKfIFliZVj1SaEL8K0xMBrgh2oeg+EIwptvw/gplqqidtCAUmprJUDtmSIa0Ue3IIVyww6xpmjLj7MwTFF9AYztC8wh38IMPJxVS/YgPP50VAifC/lpokAr8Cq/6AJvAFd//JOh42T4PM4DTxs+bSV74n9tUPC/SDl3DVVpG75j7AHiRWzVDjX3eztnzm/7kaEJpmEVhnbkX2n1q+5HyV/a6b0brvubfu9zdK8ZdIcI9roElL+4hzYO31Nj+e1rK5n5+OAfA9MnolV+d1l34CAEes8swDWEdk9u+FQFMozZUd7p57qBjTlgUDAShO3NoflqkKW6vzwL7E04CjsWKdURAMcMb7Oh4K+vJuefPJEvYL/5KA5pxdPZFpwkSFzCfs1dINpffGEbt1KSH126yaTuimxIbI2/c1OLa36/Kgfo7m6YWb903qLRPeDDAYmzxHh7qOF9Q7Ky7TaPxQgClQ1UMExSr9koRkYSLVTYLK95LAafB88uB9DyF4AC4Dy/l2QjIXxJpq/3CA5CsGl1yuT2AvJr88ZB2yhqKEcSzbVFglV3Cfcv6+58aeaZO7C32K3/MA0hdFABMN6TgDx9O3J7Kz/DoAIBYHnXFdsxnulalZj0vvFASzzRebe3dd3wqCd2Gk81jbySspfq5LBUIIJe31DQvCWbBZ9vC3J6I+euLowMG14iJ/Mw5z1DpmG92NAhtPVPPx/nqRtljVyty7WhASA6pB4hrboc4Qzj5pGK688lTOXoG1jUKYLOSENikF2b7P5uhOsnXesy6V1YqFKZirKXjo89wevdMrR1m+Fjpxdz0nktIs4o/W6Jt7j9n12rNsi5kbcjJRe1s4JlVD3DeYVtgKLFB7rrCgrL0r7zDYLb/eONcwXFx/fgPVWYZT/TmjcL//VfJq3c3akxH1CRAZdisOpguXtzjSTfKcp0bGgFybPxL9mOXtmuZ+5aTTCItwGmg6Pos9WVAmC9//T/C794zBFi7yj94c0DRh1/7aNmbvJjv74NizhGfqnVRuf8Tx74/d20p1Jl54sDDQPKl8T2nDaI7vfzTsM5A5w2DuQZLYrGwhPq7l0vmkEsrELvESBu/h16C71gWzbiqWy4mMZH53Z/KeVURUbVvdEaEmA5+abp3LD9DKKVRVUJRldjYczUlgLUrmZmp2+g6eE3Lc4PZ0qccwgvMERSRMbPVT6h3MEwasYVNu3rLJ6sBuW00gk5g8qF60a4ztpkA0K0OF+Obr//DBqDqrM4b0mepEnxYu2t8z3gejsT1GaWWx/KzkHVN/NLBWaQSiBRVfpY/BtWvGLX9K6hJ3CdRVlyTxYyjsEV6zlkyoGcPkB9jlyYbHrGXrK9+ErzW08iR7lOdn7iJysU45/a9+eyUt+1UOhaZFj2UOsluYzKODTAuIyXKt+u97fTShVtTrlz6TWAYCEW/Yyq7lqNOt+vCYXiyvNsSYHz0cZJn8Hbt8TId3hBN/fhNSJIyWqPYkBcTxURV578FVrIkzGhYsUgPloUYg9bHtyOCiAeyE/RWWNQhn5wV9iBYnZqTTEuDsJ/bssF0HN9ie4XGDBsNq3bl3LOGc2ey7BieOCUhE2xniyt03ThSnxiH9m/fsLoPUVx2iGhZkEOUozYwXjtNe7Dq866JraJ5SQBRmD77ywiiWpIx64kdGri96+4mpdYlKRI+sffVdFdirvuJU3pvyp6dnJijRb1dcKuCDiPj0pP//T/fzCHaw3ufiYpajzJjDkiAHkKp6v3xtrK7301mBF9l1DPk3WlNdsgIZBua6CNFEc7io45jXQkPBTjejL78S78ZMavgnpP1P08cD/MbndNrn1obOaUYB9SUggHGMK2a4jDtw+DYUaWNel4MBIG4i/tUFgTfQOeR+hDoI2hywipJyRMqgnEW0yDv89WscL1x+i6wIxHKL5MHxy29QXSUkvDrQ8M37NmQeZx/e6Q8khzQLECV7stuBbaf/CtrTNn88F++Mj8vZ31ip2+H4ot+Q30nEqYrAkwIs/251gXQ7EQ0jJWu8wHVp7xWppGK2gVohTczK1Zz2NfxKr5K2p68Ub982KY141XnBOA76D69HSHbrdpdSisFsiAT4dtAc088QAQrO0BOi+9z+HFDypNIMtaP9Ue9ofSMNZJ8qOe5QI1MDgEgPIL2AoSI+5oVrSpN0thPoELp6ZM0O/zKDzOmPfnGTd7IRD/FwHv2SZsLh+FAFvTcAjlmeY0cTVXpilrJzxYomOZ7Y2/4lWV8h9XMBuDPwFLegatZoqV//PiZqHn87Qbk+JQGNjc62WHg2ylbDpHtvq+LIdPJN7MR3ziF7f//KzrjoDTSPO83oOC0JgsyiiFzOWyJoVpygq10AhMPCasu0R2NY0jM7rwoBhxMZiUtdoANL6LjeMS5mZSV8LqpSjUNAtPqjhEjGRi9hPVylsO8ZhM3ScXJ1sx5CTexztrz3Xdrata38j77f6pSqXTTz/P7fb+fz47mwf5Xf90eP3iEDH25e0FnLlhdzrInX/SSiWwWY18ZAJneMrAIOfOCHYxxoNrsGsDXZ00Ge0MWg0CvrRd9e1WOcGY5t/bfMvberALtq0h32knwMVpeb6HQtpq8KSW4MOL9DWotG0T1cVunsC1npqJqsL3dQmpuf98HxuSdI29JzFWlGDh+PzRnwNwBHOaegVIt/mZ594NcsZIO9ch3E/i6eTrdm9y7uXJmvKKFVKYyeibdgqza9SgE9z7o5XPUu2SBAUHPXKO9VgKyhZjtbJNE9Cw+f2K8rJ0PIZBX5ZODsvPUYzEl6DTOfA9YsJmK/uNtxyjgSDKhnazaS16ALKYH8f91iDB346km86pS6ryUKZ+TZAW6IVKDu67M+pw+A8O7KLlVzMx8Y0VoSYs34TbsmXJMdExW6yrmjDG/l95NpJqCcDjkii74Js8aUin10jcrgsyBpKzVwozSUj8c0y68xk/vqZ/FHZ+kJc6WPK8+rjTRfuCjNrRBLD70o7Pd8+9/zV7anWlKc5TCbjTbtqWb4lzFY8d8z1ZrWqc8r/76L3Uid2dhFPoWLfLMM/eroMyHYwe+G531Bv9zN7MiIMsuiRh6CeQCrq0fvaFbfu9X/xRIii6/USLwTeWOG4UAMpEXwXtkVJDcdmWEMa/1avj1sIwqCepGH32+0uv6a1YucgS40+noxUeMjcXfZ6/4/pT1H68ggwEEkaeRJWJ6GcUqT1zKVUKrAXjp+ioXe4DoSsnqQ9WDA50X9MFI+2J8rqwrzXHARy/+5Zvy3OqVlhOs77j5E2QSye1GZKMffJubZRn7v6KFxr4ff3krFtxWDFnscpT7ME02RScWMMrTgahVAAAgAElEQVT51lMJZiSE3ixJ7Ac6osKxfw1sOwQlZWqGGU6LZXiSp0o9xwqjbst7TXAiGSyUGFVwCGjnIIeMysemQ1gBleZ8viMkJwi6rE9+4hZMQzISaIOml8HsQW8lCw6q8WotovcXR+edb/9cPVxHsnlzq+uR22r0RU6wNbEex1XshnB3ZsR4q0gD1XYMpUBaR0qBW42bOeBOru2M3EHHpZwAV3E3oEYG2wN8WLpBOoQOIAFr+r92I0lO/+5OXtog6f8af2Ylsz1Hf/MZ+XKJPbzUHXqzmdgP4OcAuYYhw6tgNI+dX6YSBTs4YQx0TSWlBjCagNK53weSlc2f/3dAH09K1+tJfqNNNkqGigGdmvy7uOphvlq6gZNO8vtqPYMXIIapUzGUjQY/bSiU73y8sMbz+YMAcRDvyNvBs8nKD8m5wWyOd9xvqb+MZxh8XGp45m8UdMuHyxfWG9SAJelDMoSUQn/9VWOMYjnAm5wILC4VlE0E2v5u+FE1FfZzdSF28NjalO2CvDxlvAO+NoIptbcb9JFPMS2QsHGfPYzi0/dafXrDWS1NXDlLns4VukAnMuimMH1njSrn934lVGwKS+9IgDMK6J9hTBzpGKK7VjMbzwRiv7AXo+sVDDycO04Jv/0zla3BJArIH9eoUZDgbM5vL5A9p2WwoQbc5IOYT777HviPzYCDiEiWrcEv/Twr8DwzQdhGlzQuFrX61qTvq2HD2rCXpOLPj15kNXL4xXQZcSssPUe4IOfDshL9b7/nA0UD08j/qHr20CZ5KWrpN5i8EH9ErA8RSnhURstG5bIR1zIs24+4rTB5CZDv/G7taALo0BXYZOAdiUY4DoBYIs3FH8JxI7HSx2I+6LavatJJJuGsWknZJKoHDlEHXO5ZlyG1L9hdu6JxBh/FnNuuKNFpXHAZ8i22GWWnMcvOyBIqwLxFkKL8U3s4p5ToGTHgdE24wzEe2QGZ7R93NvKyV9HpexNfvsaz8P6nC/IV4sTcqkdNaR4Kykvcy7TRVyceZrAiYuAHFfT2X0YXuDV8LuVgzlzDr5VdNTgvLkcDzrb2lgyLrErrteIZnawW3hPzNRozvFOboTeHtpq0iW311848pll1yL0FEBKj1J3/VisHNWQCCLeFEBCV/+Yzj8osWKpKrUCyxLsJ2diyLoPL936Z3qfyqHOvnmBLUsJ3IdBnbdP3kq6v5uowC3M7q708okPl2KGLflG1DAJfispzFQ7CZ8hbATnI+C8NFxK//l3lUBvmULII+o9XB0kqbKBSADYvaFfSK2PlOnCq0Lb5u3hajTx/nUnTg8nom4IZHRaxKNKT8UuoaZCQMyxG2Lp+Ty1ssWKb4ZgM9RI1bWLR1igk2nZpsbxzV1GhUpyqfL30zT0+/Vvy+75EVwVkdAH/EADVtPrCHFtoPi6eckBY82+sOYz8dm6LCRg5fbm+3sr8E6QaPH5p3+CpJ4s2Q23/Z2CLGdnuEwrYAKC0H1xL0kv8FIsWhjPBn9wNZ1CGakfF3BCBnFPQO7+6n050taFMqwzpDNdtD1D6GDfTKAonHM8eK0d+0wC5VuBGpOxq0FahUt0tOeckZOONuEtCtU453tld+hbFB6KebAdJAwWoQpeBpsF5BKksney74hxHvPQ+iHC6P//B2WJdeK9qqvD1cjO400ipGJqSVkqeO+fDspq8fSryksxz0hxUtMc4eRCLXdoqAIUfA40WHbO+fN1QdFmPfCQGUUkd78UO0bWrQJwK8IfAmFUQwC/rdf485EBsYYnYg/vYkkZmdGorJ9Ti9TVUcT/qN0zebPv1jzllAw+altEjkiVwByVbal8iCUWeBWxi9ZAhL/qTXLWv9NLhLCyX+VNA4zdxsiyQN+KvqZT4QLveHAPKOS9sk7ApxHrh1z9MKQC2PIeZ6dLyXJHIewWlrVB7SfzJ5kCGiZvCicgdynvBMLt3U8OeAp+f5WMpRB7CxyGWmOoUdbEEMeCmgmVmVtbDrx5qQpDkCmb8L+BTl+g4c7dN+7lYbVZdH2Yu6B+m67M9J7KphSk73v/6XmB/eP232Xoo5H7/vBFsNC2QG9GPem2vN2h8IAjqeDLOJ9oV3JfHYRKt3aVAU1tiGftpuGpZujCGNg4vSHXLHKWUhYkHVflundlMuteCmjACrQKnpcyPA3+DL6SWjGm7l05nnrDcqdx/jw6UstEuCRBbD1PQFOmk+YyeQRZlIqO7d03cTC08v139z7du8GowYzJHG14fBc40yQClk87WqCp/bOfq3dHsKmRq3n7wMt0MrJP8B7g+R1v+rTzCGgPflBhv3I0c8H+7D6jYmdISAJYOzkULltfl9aqHOzkCvQ7RvUHzkTNHGpLitHd0X5WP0w0qPZB8WepDSpWjzj6crryrDCcAXR6JOFn/+UZfxpqj2wueTS8/htDvFxzsA0WKVZd/0NMnNb9phPNZfVHTFnN46wNX6S8JtCSWyW392xlIl/veybRPfvhlxbXXwA9psn5bNp/q5DdCHkMfwuXwwT0N+rBaGr05rvvAJw6Gc+TIwbemSksMQsyi1obR1Ji2gNc3rG/6pxIFgp8vLwYyEXqI7VWCTLJlsGokpYitrfjBp5cPwWbQPCst+RpzthbXjgfjmqcZTo+s1M34mxrY0X600yYDNjOBacpTtUHB3P3GmHK/4dhPZ3UhAnsTSYcW6VA37O1UrjciH8cVM0DajtIrIrtInWV7DT1WYOBZPE6QYnTgd3Mop93R/WTt42dIOBw79As01MJwFCH7pJuuT9vB5jlnz3wDH7gJu7XtdEQvljHB1nzRu6xy1wyuVK2lO3tJzaxI/aQP8R1WoqlUKzflKNKQqjWOAVoFm4c5VPrF21JtdySR3G8bNpCLQKkgFBI5yJJNoS1mH0pdYyhbJLUe7fKLxOI6vu23HdpkLxeSATdGom8wSzcn+tFFFMZnDZYInKmbNdtjoFz2mpfNM8Q3ozeesUdqkoj+oGezYAV9WRoYujT0ahVk7u868ECOFir2hVo5baPgIUFngJBh6vI5Tr9WdwUmRofDSO50Wjcyl2YaD5B2/MXvPZkSf+6nyDKvyh9D/ngyXfod8pq7lLOoPdMaU2YeUduzQowfPF1RQ1hIH+K7T8ZwT6u6fK35aX4d5Gf2HkHZJwLzKP4K3SiZxNSPZoBuZVrCucoihA45b2sWUJK4nnnphqcPeYS74a6dw4C9Wdsf0pjkGZm53dm3fMtSVA2GqjWZZyZmCo9rnJ7/+MB5Kb3rm0qu8QBAQ8le29XJhoEB58GZeeBDVbE4gFqX6wB/w8Zc2TQaS+eeAs8OWSIDXihKqPQ7CZ0fEMtzaqa/Vu6okclLoesSRAOsyxCT8DzVSTcmLpYa73gfuazc+T80f1uu0UmGrnNU0U3og36LbAawSfrqU4k+r/OmWqJGDtul6PZlBjg9Ga6x7WjV4e+4IGWFFYjQZA2LAN31hHuhKHF1fRdmzY7xeia78IHKXa2FYdeFmTNg4XHbbRHgZwO5ARPpYRZqv9mBBbz+oAngf9B1lKZAYQFvCwcLJIm5ooJ/GAAH9rK377f68zeRQQIC4ErU3WwhPz8EUNkvD9mnXkkrNi3Jg1WTN5oEDfbUF/1U9G3siqKW2K/TfWjcrsLBcFqreX30agZIuScul784sEAuQKlvAMfm9sR8MDQOpxZ0gM/xQyBbn4WddikZPe0XnQamVyEsJXuOUq69AKYuGDHh1neR0kX05i91yzHyYxLEdrbHQYccFAJD7bOyM8RRGifAwoG++IO8SEPfqwrhi+QdyIfmGFyvV7LwjGmye6DMblQu7qjWpM2VB9ydqoZ+QzAPACu7VwCoWSVV6PeB+dIWJJaKKiM5gPEQt/Q+ABSEPC2Q+0kGUFxzAV4GikP/ctvvYb3eGY4z7fjs8yeEoTMHtRJXV8MLYZ5xYCnQm3Kj4YRnk8kF2ZMHt8CYX/p7qqrCuMCY7s4rQRv9FztGdUh+KNsy/IXqSCk2YABHTSa6BfJGsdFnVM/aasJ4hzpaqJTYHBwy8+br5endIpWzBVBikGC7C21Ki5RLLg65bh0H/PcYJo+eGpNmQcYuA7ahYtwHrHNw2sEYw6HCNIdYH5Uakyde7SbYCOMFsULivd8D8SPH4dqx0GkOuRBfsHpedNIJMm7B+GROPaliYj4ZBLLnhjzOGRd230NeWjbPg9EvyZZas343CfZ1A4bwlb61ZugE3k8NjsfN1wRHCaTYjwCAG3rZgIy9Qec7meoVRvc+O1JpkLCN0X58iky9QvzCzwfBv7ywYfOd/7cOG0AUataTlB8/nf6CyMKd7NWaNsdjaNScoy61nd65sBPoKn2xB28dkzjdet3eLsQcppslBMtzc46k10BR69pYvSdrbIUR5OBL21BV/RkQTwjhgaroNcuSPZ8t26PRzjd+5ZJN757LgxAcoupbwmkuk+oFhlogQ4zo9J2gic+v6AEksQX2CiwtOlamwGYp+w9KomLirVWQBRr25oVM3FlAIYkzfyhhgsWc6vwnJyf/eGM2/UAILoytERvCK8BxAmPgtEDMghFvXlBjAumzc2o0DH6oAYsfwxaA8pHbA4o30kdicyCo0VHdt2uqNgAPNs2c0YgpmMof4FVXHPH6P7lfTBcV3OMHyR4TBEtvwb4VJFmBEUxMtucWiIj4Y+mayc9LlwYWdTJBM0UA4JKrTr3Lu1EaKPjLdkA3wiUwOvpKXtZhnEm4Lex8yZElYtZobmHvPj1TfcVBl4pzPnvL7JwgX/pNkBCEjVbyzrnpkIOK8ze6WPnCgj+x/fr8wp0zjlTKxMl5LC81prAwjSSycO+suf+HQlFPKVtnkCWjAxWnEfSTr64bjGJeVy6p1kG5SvgcKYxRHNLh/HLl/Tm8D9EDUmBOEH4yrp9Hnf+x2uYPBiA6Ag8GtO22c0YChWq3JxT4RCEShFk5uLfkQFz9qONnhTZ/zk6O+Rn8YK2B/O4N1y5vIlso4423q7jM8Qk15+YmLP+jnyQcUz2++ukVUHBaFdrL+mBeH5GOSPoQ2/J6+RYldVbTv7t4+M3SmFvvfYpsSMNyEGYAaPlQfzP4LEig22JOkoS4bfAZk6op85GL0z8IANsEFR8oVfV2/22C0glwkeD/0ad1jIrIPsoS42DmVrm1RcA0bhBjXyjgXpMZU09Og5Blmp6RJnsFbUnfYLtJpIAqK8DdzFaPMVwufvaZ5F1e77bdXVFAgY8q0I6HHPz3x8PB9mqJsdiWjmWmGCH7xAsa+ehiplE6uWWwxIKCO9LnFf2ZITAF+I5G+WEZxCn5qKCGocg5a2wYyRzqo+Cika0g0YttNkodlLFkCHw0GQ5gb2caIRQM4CN+hXWWxd4NzZu5PdZP00e/Q0G7BzNRMF16StesGzkFWLdjO1BuAC9ExxrsgxqxZCE2HGwvRIOuEZzogY93AX4279sQP/8FbGy3AZkV4MaZIJ9OAuWzn3ybRjgKX+MwyC2plovg5OF2MPUeBY1eB/svV2PgvLolHU20TVsvNa83fGl4461UQwdQNXAun8AvoXxJe2sOwJWYMKtbLKUzQRq1OGPGganvpI+B8tmwr/XkXXzAMOV8OxfmBCDPHBLtdvZlfG8U5pI94egRkQOAqNcdXrouoDZU71X4EAIBaf4WzU8DrL4lu1RLMAz+69fLkpy7N7MxS+XXrz6K9SEo//3W6n8olEvsO12UdGbP0yj91o6EvGP48DqDQt79ebKjgWd+4XrTPfGMmT3DKxTGOEIiZn1paM1IGLYXHIgYziyG5mW8OUFFUMOppupUQKuQLCdtWJeoo47RTPPErAUoYcOcR8DrtarkU+1uXa7CaldKXoSVMuT4xNz9Xx90h81uBFFUACEPJ0wJ4m2m7TulEzfWVqPzWiFps4GQwSTMnmICFqpDUtwMmE8zsycU5qqfqau/ardTlIkboyBTqT3idD9uOnQSjFTDnTlaIoyNfab0qK1EDHtn1QAZ1+tsjXAj2ehrhgT7Z71n0W743oD8pzdg3hZXdJFTGGXrZUI+RfGDQg9pN9iY4/2cxlwHzMIsYuOyYsbCUM0kG6Q2BXlWRdPK+NdsUD6jV+gKsg8/HWwn59GjLUr/fhgEhC7AFxDeAlmN8g0iUJE98nM7rq4Vc9rdex09Xni91KeC9pQFPIB11PWXLvQZHk4UPhnXkRzw+oOhOz2innLwJi6L9Y8W9AlmreEF1nSFZPuFlgG5AcX1HkLJ4PPwvjnJc0Bo9kz0UZ37SROsdYSp4JkubGp7/oRGb8sH74I0aFpoHNYhGdlaumZPrG+nlga47Jk8PZe9y2ckbvMCsJ9ce+/x1ijlZRtXjcnh92PuJ2ute+1nKWzq5BsvD3YjPsNzlrwFouLgiFjHHl4WAiHE8AMEdOwfnTkd2TcB0qQAXUmwhAlX2kD1Bgxh4/Nb33xF0OFIOxeu4UK9NYoIhmGEQhYRwDMLKSVrf5Ak4i29tqEkYraQHgIQiJbjps1IzalyE8FJ9qTXInJZe77NFP6DGgFBT7VhdhjUasJdZfgA+F6rGCAyzj2S//jCYw0+zXG+A1FGha/mcMFKaRIQCKkF8zcSiEk1s+X3wdu0LwWgY3OScxPHngQ+QXM9dsRwJ934DApz+pBhYKelPA6gtBxRMGEdeSI7oWr0DMPDBM3b/h+rjymzdesxfZAMkrP4pxgicskNoHSmBrfL1e+73V6IGFKR77n4UuntHr8y2od2SDYlxVNZBWegGbS8aF+pE+wxIJ2sjoyJtgybw/XkIsJzwxQtgmkhuKTfv1g2jrKIosUyaE4W1mUq705VT47rrdi2x+O8uQ0gOY0HAq24hWCGG1ySeI8xzOnNZi2u9CqIeGlN721vu8dOZH1vdMkzy9FfpP36JVKTBS3bUYbjdCXK3RcWmFpKBcGVDWSg+28pm3PkAn7an7cvoP4YiV6WU+F4u6atGuXcjIMY+AqfO2E6aqeRDTJJia7FCfhZCHS0ukZIAKUEcW8PaRs9upkXuiYwOqF5FtwLJFYEhammf9deCPIe+y1d0o0Y1ZZLYjgh1iZgSBePLDZat6HNiGUKhByJBbM6FasDsKpWWoIk+mzIlIOsxhkhiUTieH9nxab5ZZrCCPaqamP7ukwETtxBONUJsj2gsGJKSjD63pudkPB5njdSu7VftVbO+ARc5+d3j6USX07WKMiS4+5yogY4jTz9o3fJs0GnXecXGDtyicceAlpsNdRuRnoH6kjt23eV08tgI+hbaSSZUcvQYipEntJZFcDkOvku2FMIiDjhx9k/vdmF0s2wF4vEjOJz0HZWFeu9VVMY6hSQw8K24JujpW7hpR2Zx8H+U0BD2hFSkOdb9ln0/skJ0v2olWBquu/3AA9sEwoP81xcy1oQoII3HGv/ukWE3grN+o3dfyAMtQGzQ4PPc1dJwHkqSFNwrYvzd8+wLogu+DPZ+4IvExibv7XyQe01OtD9u9M+hNPZkUFLgrZ60FYva7PQwaKS22o9Sy0THJ/o0YVoGWXkqHt1oU7nRBP5L4cGYiE7L8vEcFrKjOo587taqnPR27VP+V7e1Xvnx34wVu7mSm7clo+4Kec1cDdjsZHMrhRsBJderVHysu5DFzN13aAZHek+odlYHH3em82rXL0Fk6WAqLZdKdbinn5WOkengwyqxiJoFioGzYJzE/C+wLo1++yNvqaVWqZk2cAOYUDvdrK0nT2J2Tni2FqZStd+ZcJuMiF5k6Sd2W/Y0xgylohcS6mceluEhDSajIGfGbKpmg1m8Lqz2iW/OM7f8yw22FJ5X5Vm0T4Zs7pZ5Hct4zZEkDMoLfbh1ScUOl539KQ+jZSTYn9TtPv5OppiLJLzIwWvg2hXGt9aY+Wc467XZELTCBQ0KlgMPUgct5//P46e6FVERD42upMVjh5f8wJw4HQ0awk/qMjyk9YStLKimHZGPAOhd9HvPiA/LVWG5kYNXHHFduAsu147i7HI/tcRWxrv1kzFluyI4mDHyt//s2Rro95RMNww36iVA6SLd+5E8GI5aYmduSY09MmUelwxG7fghbO7Pm8bWyAP+WboEfArf7xfKH+9CqimUZd08iRqaCzqflLCQMruBrf2CHBTSku+vpXXcJXBMaLIQzzpwHTStmHDqUwkk6hGAQOX0reXVW3EZE7YWnA/q9zOOmwH7nDzcKC8mVqMK5BcD6mGqbO7h+WJ6xDY/m04oKtpcHRQSjbpNOxnqfT4xfuGuSuEfiZvrUGVqwx+XwWgJprDyfKbd3rjOcag+DYfMeqk0nzFiEPMwt4pHywEj28bwIgmXBkVgpIKlICKVSOkDw5Luw2C+iRM5Q06TE6jc9zMjuTT79Eoe9eQ9hwRhD65XzNtPPRKl/Z6QZj8LoEl99mLiIc+A/aUkkdijeJBh3nbvrabjmAmBTOKNHL08R5lGMCrqyJPWWNgfZ5Tlz2bMD2YIUrdPbLeB5oHXqwQxfJ6bZHd/etW8mGt9TJLHeKqQ7MbVdKG0+h6xqtdMBBwhNi/vfTpa2sS2S5YtkEzm2O50+VsXYXm7Dn149HRoUB3kaam1R+O3AZssiB7GdwHbxENb0dfjJmH/nMt7U23ytMjbPNP/k1x1KUHhdhyImzwSfm5hD/ufr2769zerrrng8JT8BQ95I6T+LRGKrr4Z3xWXpYVBW6cYAtAIOJ4YXm/AcybwobhiDo3wzTnBppw82KwhRcesI5f+Sbz1SVEHxGE61KuFSmxl1xSrAGEH+GTIlDdmxk5UrFuK7vpflT87b9etewDOQEtFHvioEfmfnDaK+yAHW+D8qkWOXToIhj2P/xxLu2Xf3HyfrIM/Cj85C7g4srQfPciyyGX+I7nbPYuAMY1ADpoQl1lL3VeDPY4sE1umJz+2qPeN17PvuIWsv/8Tul/+SmenahnB4sI0sGf2mSKOmS1ail54pVAsr6GRMJWz6bYsPSbMhtmvPBfEjEzgyzwFk9AVFMmIwHhBfyYg5NcXDXSQVqemRJW7W1pkgB1zYTGVANI0up9hTSS0mK22MzDH2xCZvico2a2oS9W8c1kyLUm6c5ftxaD20/EXHPjuGNiy3z1ign+W5qqUMYVmD9FQ3bK2XGFHzsjUNJlV1F9r4mqHsyhbB44XzH05d5sQTm3WMBOXzGqbGX9oyNnK9Mh7LbTfmTVeg2wpY9oUyIi+ZyempNMQjkG2muuiuIT88opGyCZ0bRUL+cZLzZML1Oca7RRjBjEU8wRHkCr4T28AcrYM+o3wnsY3LPFUce8tnbvQmboMoOIzpJ9DMSIrh+fCCQTedYBYCys/LfL69yF+xdX7rqs7a24HK0ZscdKr8a+Jjzd8uM0sowfidrrPqnw/AotX4QAZwRQ4kIdzJRzOgKid+8rT2n95xyE5Hzzo8CCqrfn4P/8cy4UTrgeXdMFgxPZ8ztHvymbmJmX6ZtQYTUi/ysB4yd7fjyPZJBbiFRaEqrZMrRVqPFF3cis198RvcbABhJIiRNkaJvNcwmFilpXenC/EldzCv/c56d/dlJ+yLVBdN//DfDKTLZIzZkwIrRB6Zo2mg698yMbiWkF4hmOK50P9nJDc6GBL9QFqzW464yySBAg4f4K57a7KTM4jeJgFykTQE/LiekrkD/hMnBh091//20fcjQvV5HXTEtnGhlmDPm6ZvF9IDjISeXbYER2ZWAQw461eddBFkaaE4LZEsEstxMT7Cn8ubvTOB1SU2jBFSCFu/dK2wZubhya8zAtvcC1ML2dfKoHCeYhlDS+4G7yIjZvDJmyRWgBuAAw+RgcT0b7Y2XHElllZ+EOma8u6qMgrlC54KcorqqpVLnY2WZQcRVSQ7dkTAJRI0k/MIWv/sv/JlVA3i3v+RNbSuXoStnQsNZtnvfeGfIEMFoGCReDZ4du2n1SEEuCw38EQwUq/EjJnDN1PKEVvGn/Orz8uUR8ZfpPA8jRmzH7ocJ9/7gDAhJJ6ZPvJD1pZj1NcRmcHJBL4KZMJH9B2OIlRgHcVHQZuFzL5qVDBChnhVS6hMFGJWV5aS4pEcsz5R4V17nFkAYi1dL8XL0rDUPz6C+PDoA1NOV5ntJ7jiw/SwO+vt7A6RFe0JOwqFchxc5L8u6qdYajpw/evJZB6klF7WYnWVB6/fX7R2ZYvkkieP2zYwvyBMW2vlyWo0fPH7yetktiBLIG9mAbouRZypE+1bQrcoPhzMBqJ7jPh9q6Mj4vBK7UMotkQOJYZaeL2uR8s4O7/sgSZiEyDCVP7+ZeXuGnDrr8T3mBLmBI8Cwo2agNIljHgl0SSOXvTfP1gNtYrxRwkwhATeHkLD/YGulL41Ur/mCX7j7RQ9UGGhlZbR9LwUmlkrHKe8THyjWJKQaIUQPImYJV53el0yjW/WGfweb35RcVoOfYD/Zukuo4wh/LfA2AloiqVEO84UoXx/O8Jo0h8ixU4r1TdrY+HsOw8Gg+sXdeL4QFcomJa3RTNZqEHRGypfKoY4ASUPgCwfjqIeBSBhEOtE3KyMSsno+qyj1VPLevYpwLHgNftKNcgYi+Axv9ptFov4H9W1IpkOHgZM15jlen53ZwMDJEtNPLNG9AanznT8bTn51ES6biKoYxhOtuumQh9oMIiXdoERl1fvf9yzpZMWhyWC9nYta2A2qyEbKIChfSVnF+tpVr0ejDVG+rfqqNP0whvbc93wcg48Dy9RVG9iCS3Q9Ekzb7ibGvIT3SOHUqHRqoSOLuGhhUXkPi/BJZ7s3tiRtxLwEGgD1afE46VL0yMW8Y+7kq0GrU1FT9MG8QRwce830PaFFvXD9wKE+d6UQXipvuEc9oTrc04y6vIQ7Mgcl4qArRa4EDTVSY2Teuq4sxPvmK3y2Tl3t+ZQ6WgMGf47BN1fClURZmPQX2jH19Fdke3klpnWrUc/O8NHz8+kdicn43a2K0R7viKTYCTZcntRqqmBGkiGJBEADr4Jt2P3wAAACXSURBVCKS77sluxLoJTk39NqlTYg8orpXhQrY5kIJUmxOghet/M5zrzFgwuR5aJwuf87UXgR0+j9lC+Vo7ctI02osLbSls8e40xl5OuyfeSRGC0Omkmi2CtXV043DGc75XUm2K4GB33SkuLwLir4demuHCpZQ0x8S1r7R0MPm3D6/laS7K2YtlvR24S5+1gaKeyGiZv7/A2PybwQhUkHoAAAAAElFTkSuQmCC\");\n  background-size: 6%;\n  animation: grain 5s steps(10) infinite; }\n\n@keyframes grain {\n  0%, 100% {\n    transform: translate(0, 0); }\n  10% {\n    transform: translate(-5%, -10%); }\n  20% {\n    transform: translate(-15%, 5%); }\n  30% {\n    transform: translate(7%, -25%); }\n  40% {\n    transform: translate(-5%, 25%); }\n  50% {\n    transform: translate(-15%, 10%); }\n  60% {\n    transform: translate(15%, 0%); }\n  70% {\n    transform: translate(0%, 15%); }\n  80% {\n    transform: translate(3%, 35%); }\n  90% {\n    transform: translate(-10%, 10%); } }\n","/**************************************************\r\nMIXINS File\r\n\r\nDescription:\tStore SCSS mixins here\r\n\r\nCall: @include backgroundStandard;\r\n\r\n**************************************************/\r\n\r\n\r\n@mixin flex_center {\r\n\tdisplay: flex;\r\n\tflex-direction: row;\r\n\tjustify-content: center;\r\n\talign-items: center;\r\n}\r\n\r\n@mixin backgroundStandard {\r\n\tbackground-size: cover;\r\n\tbackground-position: center;\r\n\tbackground-repeat: no-repeat;\r\n}\r\n\r\n@mixin solidShadowHover {\r\n\t&:hover{\r\n\t\ttext-shadow: $text-shadow-red;\r\n\t}\r\n}\r\n\r\n@mixin maxWidth($maxWidth) {\r\n\twidth: 100%;\r\n\tmax-width: $maxWidth;\r\n\tmargin-left: auto;\r\n\tmargin-right: auto;\r\n}\r\n\r\n@mixin paperTexture{\r\n\t&:after{\r\n\t\tcontent:'';\r\n\t\tposition: absolute;\r\n\t\theight: 100%;\r\n\t\twidth: 100%;\r\n\t\ttop: 0;\r\n\t\tleft: 0;\r\n\t\topacity: .5;\r\n\t\tpointer-events: none;\r\n\t\tbackground-image: url('/img/textures/natural-paper.png');\r\n\t\tbackground-repeat: repeat;\r\n\t\t//mix-blend-mode: lighten;\r\n\t\t//filter: contrast(1.5);\r\n\t\tbackground-size: cover;\r\n\t}\r\n}"],"sourceRoot":""}]);
// Exports
___CSS_LOADER_EXPORT___.locals = {
	"filmGrainFilter": "FilmGrainFilter_filmGrainFilter__fIjhy",
	"grain": "FilmGrainFilter_grain__3p6d_"
};
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./node_modules/next/dist/compiled/resolve-url-loader/index.js?!./node_modules/next/dist/compiled/sass-loader/cjs.js?!./components/Template/ComponentMeta/ComponentMeta.module.scss":
/*!*******************************************************************************************************************************************************************************************************************************************************************!*\
  !*** (webpack)/css-loader/cjs.js??ref--5-oneOf-3-1!(webpack)/postcss-loader/cjs.js??ref--5-oneOf-3-2!(webpack)/resolve-url-loader??ref--5-oneOf-3-3!(webpack)/sass-loader/cjs.js??ref--5-oneOf-3-4!./components/Template/ComponentMeta/ComponentMeta.module.scss ***!
  \*******************************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../../node_modules/next/dist/compiled/css-loader/api.js */ "./node_modules/next/dist/compiled/css-loader/api.js");
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);
// Module
___CSS_LOADER_EXPORT___.push([module.i, "/**************************************************\r\nVARS File\r\n\r\nDescription:\tStore SCSS vars here\r\n\r\n\r\n**************************************************/\n/***** Color Variables *****/\n/***** Named Colors *****/\n/***** Fonts *****/\n/***** Font Sizes *****/\n/***** Letter Spacing *****/\n/***** Content Widths *****/\n/***** Transition Timings *****/\n/***** Shadows *****/\n/* source: https://brumm.af/shadows */\n/**************************************************\r\nMIXINS File\r\n\r\nDescription:\tStore SCSS mixins here\r\n\r\nCall: @include backgroundStandard;\r\n\r\n**************************************************/\n.ComponentMeta_descriptionWrapper__3izpi {\n  padding: 35px 0;\n  display: flex;\n  flex-wrap: wrap; }\n  .ComponentMeta_descriptionWrapper__3izpi .ComponentMeta_row__rfS4t {\n    display: flex;\n    flex-direction: row;\n    width: 100%; }\n    .ComponentMeta_descriptionWrapper__3izpi .ComponentMeta_row__rfS4t:not(:last-of-type) .ComponentMeta_cell__qqI37 {\n      border-bottom: 0px; }\n  .ComponentMeta_descriptionWrapper__3izpi .ComponentMeta_cell__qqI37 {\n    display: flex;\n    justify-content: center;\n    align-items: flex-start;\n    padding: 15px;\n    border: solid 1px #212121; }\n    .ComponentMeta_descriptionWrapper__3izpi .ComponentMeta_cell__qqI37:not(:first-of-type) {\n      border-left: solid 0px #212121; }\n    .ComponentMeta_descriptionWrapper__3izpi .ComponentMeta_cell__qqI37.ComponentMeta_title__10P9G {\n      width: 400px; }\n    .ComponentMeta_descriptionWrapper__3izpi .ComponentMeta_cell__qqI37.ComponentMeta_description__20_1D {\n      width: calc(100% - 400px); }\n    .ComponentMeta_descriptionWrapper__3izpi .ComponentMeta_cell__qqI37.ComponentMeta_contentProps__3S06M {\n      width: calc(100% - 500px); }\n    .ComponentMeta_descriptionWrapper__3izpi .ComponentMeta_cell__qqI37.ComponentMeta_libraries__1Wbmg {\n      width: 500px; }\n    .ComponentMeta_descriptionWrapper__3izpi .ComponentMeta_cell__qqI37 .ComponentMeta_inner__3vcL5 {\n      list-style: none;\n      width: 100%; }\n      .ComponentMeta_descriptionWrapper__3izpi .ComponentMeta_cell__qqI37 .ComponentMeta_inner__3vcL5 li {\n        margin-bottom: 10px; }\n        .ComponentMeta_descriptionWrapper__3izpi .ComponentMeta_cell__qqI37 .ComponentMeta_inner__3vcL5 li span {\n          font-weight: 600;\n          display: block;\n          width: 100%;\n          border-bottom: solid 1px #212121;\n          margin-bottom: 10px; }\n", "",{"version":3,"sources":["webpack://../../../styles/vars.scss","webpack://ComponentMeta.module.scss","webpack://../../../styles/mixins.scss"],"names":[],"mappings":"AAAA;;;;;;kDCMkD;ADGlD,4BAAA;AAUC,yBAAA;AASD,kBAAA;AAKA,uBAAA;AAMA,2BAAA;AAIA,2BAAA;AAMA,+BAAA;AAMA,oBAAA;AAEC,qCAAA;AEzDD;;;;;;;kDDuBkD;AAnBlD;EACC,eAAe;EACf,aAAa;EACb,eAAe,EAAA;EAHhB;IAME,aAAa;IACb,mBAAmB;IACnB,WAAW,EAAA;IARb;MAWS,kBAAkB,EAAA;EAX3B;IAkBE,aAAa;IACb,uBAAuB;IACvB,uBAAuB;IACvB,aAAY;IACZ,yBDhBgB,EAAA;ICNlB;MAwBG,8BDlBe,EAAA;ICNlB;MA0BU,YAAW,EAAA;IA1BrB;MA2BgB,yBAAwB,EAAA;IA3BxC;MA6BiB,yBAAwB,EAAA;IA7BzC;MA8Bc,YAAW,EAAA;IA9BzB;MAiCG,gBAAgB;MAChB,WAAW,EAAA;MAlCd;QAqCI,mBAAmB,EAAA;QArCvB;UAwCK,gBAAgB;UAChB,cAAc;UACd,WAAW;UACX,gCDrCa;UCsCb,mBAAmB,EAAA","sourcesContent":["/**************************************************\r\nVARS File\r\n\r\nDescription:\tStore SCSS vars here\r\n\r\n\r\n**************************************************/\r\n\r\n\r\n/***** Color Variables *****/\r\n\t$black: \t\t#212121;\r\n\t$white: \t\t#fafafa;\r\n\t$grey_1:\t\t#ececec;\r\n\t$grey_2:\t\t#3e3e3e;\r\n\r\n\t$red: \t\t\t#fb0000;\r\n\t\r\n\t$nasa_grey:\t#D1D3D4;\r\n\r\n\t/***** Named Colors *****/\r\n\t\t$primary_color:\t\t$black;\r\n\t\t$secondary_color:\t\t$white;\r\n\r\n\t\t$background_color:\t$white;\r\n\t\t$text_color:\t\t\t$black;\r\n\t\t$accent_color:\t\t$grey_1;\r\n\r\n\r\n/***** Fonts *****/\r\n\t$font_body:\t\t\"MyUnderwood\";\r\n\t$font_display:\t\"AncientMedium\";\r\n\t$font_alt:\t\t\t\"ImpactLabel\";\r\n\r\n/***** Font Sizes *****/\r\n\t$font_size_heading:\t65px;\r\n\t$font_size_subhead:\t36px;\r\n\t$font_size_body:\t\t20px;\r\n\t$font_size_detail:\t16px;\r\n\r\n/***** Letter Spacing *****/\r\n\t$letterSpacingWide:\t\t0.035em;\r\n\t$letterSpacingNormal:\t0.035em;\r\n\r\n/***** Content Widths *****/\r\n\t$content_width_s: \t650px;\r\n\t$content_width_m: \t920px;\r\n\t$content_width_l: \t1450px;\r\n\r\n\r\n/***** Transition Timings *****/\r\n\t$transition_fast:\t\t0.1s ease-in-out;\r\n\t$transition_medium:\t0.25s ease-in-out;\r\n\t$transition_slow:\t\t0.5s ease-in-out;\r\n\r\n\r\n/***** Shadows *****/\r\n\r\n\t/* source: https://brumm.af/shadows */\r\n\t$nice_shadow:\r\n\t\t0 2.8px 2.2px rgba(0, 0, 0, 0.02),\r\n\t\t0 6.7px 5.3px rgba(0, 0, 0, 0.028),\r\n\t\t0 12.5px 10px rgba(0, 0, 0, 0.035),\r\n\t\t0 22.3px 17.9px rgba(0, 0, 0, 0.042),\r\n\t\t0 41.8px 33.4px rgba(0, 0, 0, 0.05),\r\n\t\t0 100px 80px rgba(0, 0, 0, 0.07);\r\n\r\n\r\n\t$text-shadow-red:\r\n\t\t1px 1px $red, \r\n\t\t2px 2px $red, \r\n\t\t3px 3px $red, \r\n\t\t4px 4px $red, \r\n\t\t5px 5px $red;\r\n\t  \r\n\t$text-glow-red:\r\n\t\t0 0 1vw $red, \r\n\t\t0 0 3vw $red, \r\n\t\t0 0 10vw $red, \r\n\t\t0 0 10vw $red, \r\n\t\t0 0 .4vw $red, \r\n\t\t.25vw .25vw .1vw #806914;\r\n","/**************************************************\r\nVARS File\r\n\r\nDescription:\tStore SCSS vars here\r\n\r\n\r\n**************************************************/\n/***** Color Variables *****/\n/***** Named Colors *****/\n/***** Fonts *****/\n/***** Font Sizes *****/\n/***** Letter Spacing *****/\n/***** Content Widths *****/\n/***** Transition Timings *****/\n/***** Shadows *****/\n/* source: https://brumm.af/shadows */\n/**************************************************\r\nMIXINS File\r\n\r\nDescription:\tStore SCSS mixins here\r\n\r\nCall: @include backgroundStandard;\r\n\r\n**************************************************/\n.descriptionWrapper {\n  padding: 35px 0;\n  display: flex;\n  flex-wrap: wrap; }\n  .descriptionWrapper .row {\n    display: flex;\n    flex-direction: row;\n    width: 100%; }\n    .descriptionWrapper .row:not(:last-of-type) .cell {\n      border-bottom: 0px; }\n  .descriptionWrapper .cell {\n    display: flex;\n    justify-content: center;\n    align-items: flex-start;\n    padding: 15px;\n    border: solid 1px #212121; }\n    .descriptionWrapper .cell:not(:first-of-type) {\n      border-left: solid 0px #212121; }\n    .descriptionWrapper .cell.title {\n      width: 400px; }\n    .descriptionWrapper .cell.description {\n      width: calc(100% - 400px); }\n    .descriptionWrapper .cell.contentProps {\n      width: calc(100% - 500px); }\n    .descriptionWrapper .cell.libraries {\n      width: 500px; }\n    .descriptionWrapper .cell .inner {\n      list-style: none;\n      width: 100%; }\n      .descriptionWrapper .cell .inner li {\n        margin-bottom: 10px; }\n        .descriptionWrapper .cell .inner li span {\n          font-weight: 600;\n          display: block;\n          width: 100%;\n          border-bottom: solid 1px #212121;\n          margin-bottom: 10px; }\n","/**************************************************\r\nMIXINS File\r\n\r\nDescription:\tStore SCSS mixins here\r\n\r\nCall: @include backgroundStandard;\r\n\r\n**************************************************/\r\n\r\n\r\n@mixin flex_center {\r\n\tdisplay: flex;\r\n\tflex-direction: row;\r\n\tjustify-content: center;\r\n\talign-items: center;\r\n}\r\n\r\n@mixin backgroundStandard {\r\n\tbackground-size: cover;\r\n\tbackground-position: center;\r\n\tbackground-repeat: no-repeat;\r\n}\r\n\r\n@mixin solidShadowHover {\r\n\t&:hover{\r\n\t\ttext-shadow: $text-shadow-red;\r\n\t}\r\n}\r\n\r\n@mixin maxWidth($maxWidth) {\r\n\twidth: 100%;\r\n\tmax-width: $maxWidth;\r\n\tmargin-left: auto;\r\n\tmargin-right: auto;\r\n}\r\n\r\n@mixin paperTexture{\r\n\t&:after{\r\n\t\tcontent:'';\r\n\t\tposition: absolute;\r\n\t\theight: 100%;\r\n\t\twidth: 100%;\r\n\t\ttop: 0;\r\n\t\tleft: 0;\r\n\t\topacity: .5;\r\n\t\tpointer-events: none;\r\n\t\tbackground-image: url('/img/textures/natural-paper.png');\r\n\t\tbackground-repeat: repeat;\r\n\t\t//mix-blend-mode: lighten;\r\n\t\t//filter: contrast(1.5);\r\n\t\tbackground-size: cover;\r\n\t}\r\n}"],"sourceRoot":""}]);
// Exports
___CSS_LOADER_EXPORT___.locals = {
	"descriptionWrapper": "ComponentMeta_descriptionWrapper__3izpi",
	"row": "ComponentMeta_row__rfS4t",
	"cell": "ComponentMeta_cell__qqI37",
	"title": "ComponentMeta_title__10P9G",
	"description": "ComponentMeta_description__20_1D",
	"contentProps": "ComponentMeta_contentProps__3S06M",
	"libraries": "ComponentMeta_libraries__1Wbmg",
	"inner": "ComponentMeta_inner__3vcL5"
};
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./node_modules/next/dist/compiled/resolve-url-loader/index.js?!./node_modules/next/dist/compiled/sass-loader/cjs.js?!./components/Template/Container/Container.module.scss":
/*!***********************************************************************************************************************************************************************************************************************************************************!*\
  !*** (webpack)/css-loader/cjs.js??ref--5-oneOf-3-1!(webpack)/postcss-loader/cjs.js??ref--5-oneOf-3-2!(webpack)/resolve-url-loader??ref--5-oneOf-3-3!(webpack)/sass-loader/cjs.js??ref--5-oneOf-3-4!./components/Template/Container/Container.module.scss ***!
  \***********************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../../node_modules/next/dist/compiled/css-loader/api.js */ "./node_modules/next/dist/compiled/css-loader/api.js");
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);
// Module
___CSS_LOADER_EXPORT___.push([module.i, "/***** ========== *****/\n/***** CONTAINER  *****/\n/***** ========== *****/\n.Container_container__2RQ73 {\n  max-width: 1450px;\n  width: 100%;\n  margin: 0 auto;\n  padding: 0 35px;\n  box-sizing: border-box;\n  position: relative; }\n  .Container_container__2RQ73.Container_flex__1Nqly {\n    display: flex;\n    flex-direction: row;\n    justify-content: center;\n    align-items: center; }\n", "",{"version":3,"sources":["webpack://Container.module.scss"],"names":[],"mappings":"AAAA,uBAAA;AACA,uBAAA;AACA,uBAAA;AACA;EACC,iBAAiB;EACjB,WAAW;EACX,cAAc;EACd,eAAe;EACf,sBAAsB;EACtB,kBAAkB,EAAA;EANnB;IASE,aAAa;IACb,mBAAmB;IACnB,uBAAuB;IACvB,mBAAmB,EAAA","sourcesContent":["/***** ========== *****/\r\n/***** CONTAINER  *****/\r\n/***** ========== *****/\r\n.container {\r\n\tmax-width: 1450px;\r\n\twidth: 100%;\r\n\tmargin: 0 auto;\r\n\tpadding: 0 35px;\r\n\tbox-sizing: border-box;\r\n\tposition: relative;\r\n\r\n\t&.flex{\r\n\t\tdisplay: flex;\r\n\t\tflex-direction: row;\r\n\t\tjustify-content: center;\r\n\t\talign-items: center;\r\n\t}\r\n}"],"sourceRoot":""}]);
// Exports
___CSS_LOADER_EXPORT___.locals = {
	"container": "Container_container__2RQ73",
	"flex": "Container_flex__1Nqly"
};
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./node_modules/next/dist/compiled/resolve-url-loader/index.js?!./node_modules/next/dist/compiled/sass-loader/cjs.js?!./components/Template/Footer/Footer.module.scss":
/*!*****************************************************************************************************************************************************************************************************************************************************!*\
  !*** (webpack)/css-loader/cjs.js??ref--5-oneOf-3-1!(webpack)/postcss-loader/cjs.js??ref--5-oneOf-3-2!(webpack)/resolve-url-loader??ref--5-oneOf-3-3!(webpack)/sass-loader/cjs.js??ref--5-oneOf-3-4!./components/Template/Footer/Footer.module.scss ***!
  \*****************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../../node_modules/next/dist/compiled/css-loader/api.js */ "./node_modules/next/dist/compiled/css-loader/api.js");
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);
// Module
___CSS_LOADER_EXPORT___.push([module.i, "/**************************************************\r\nVARS File\r\n\r\nDescription:\tStore SCSS vars here\r\n\r\n\r\n**************************************************/\n/***** Color Variables *****/\n/***** Named Colors *****/\n/***** Fonts *****/\n/***** Font Sizes *****/\n/***** Letter Spacing *****/\n/***** Content Widths *****/\n/***** Transition Timings *****/\n/***** Shadows *****/\n/* source: https://brumm.af/shadows */\n/**************************************************\r\nMIXINS File\r\n\r\nDescription:\tStore SCSS mixins here\r\n\r\nCall: @include backgroundStandard;\r\n\r\n**************************************************/\n.Footer_footer__3aUwb {\n  width: 100%;\n  height: 100px;\n  border-top: 1px solid #eaeaea;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  margin-top: 150px; }\n  .Footer_footer__3aUwb .Footer_footer_message__XsYhv {\n    font-size: 3rem;\n    font-family: \"AncientMedium\"; }\n", "",{"version":3,"sources":["webpack://../../../styles/vars.scss","webpack://Footer.module.scss","webpack://../../../styles/mixins.scss"],"names":[],"mappings":"AAAA;;;;;;kDCMkD;ADGlD,4BAAA;AAUC,yBAAA;AASD,kBAAA;AAKA,uBAAA;AAMA,2BAAA;AAIA,2BAAA;AAMA,+BAAA;AAMA,oBAAA;AAEC,qCAAA;AEzDD;;;;;;;kDDuBkD;AAlBlD;EACC,WAAW;EACX,aAAa;EACb,6BAA6B;EAC7B,aAAa;EACb,uBAAuB;EACvB,mBAAmB;EACnB,iBAAiB,EAAA;EAPlB;IAUE,eAAe;IACf,4BDc6B,EAAA","sourcesContent":["/**************************************************\r\nVARS File\r\n\r\nDescription:\tStore SCSS vars here\r\n\r\n\r\n**************************************************/\r\n\r\n\r\n/***** Color Variables *****/\r\n\t$black: \t\t#212121;\r\n\t$white: \t\t#fafafa;\r\n\t$grey_1:\t\t#ececec;\r\n\t$grey_2:\t\t#3e3e3e;\r\n\r\n\t$red: \t\t\t#fb0000;\r\n\t\r\n\t$nasa_grey:\t#D1D3D4;\r\n\r\n\t/***** Named Colors *****/\r\n\t\t$primary_color:\t\t$black;\r\n\t\t$secondary_color:\t\t$white;\r\n\r\n\t\t$background_color:\t$white;\r\n\t\t$text_color:\t\t\t$black;\r\n\t\t$accent_color:\t\t$grey_1;\r\n\r\n\r\n/***** Fonts *****/\r\n\t$font_body:\t\t\"MyUnderwood\";\r\n\t$font_display:\t\"AncientMedium\";\r\n\t$font_alt:\t\t\t\"ImpactLabel\";\r\n\r\n/***** Font Sizes *****/\r\n\t$font_size_heading:\t65px;\r\n\t$font_size_subhead:\t36px;\r\n\t$font_size_body:\t\t20px;\r\n\t$font_size_detail:\t16px;\r\n\r\n/***** Letter Spacing *****/\r\n\t$letterSpacingWide:\t\t0.035em;\r\n\t$letterSpacingNormal:\t0.035em;\r\n\r\n/***** Content Widths *****/\r\n\t$content_width_s: \t650px;\r\n\t$content_width_m: \t920px;\r\n\t$content_width_l: \t1450px;\r\n\r\n\r\n/***** Transition Timings *****/\r\n\t$transition_fast:\t\t0.1s ease-in-out;\r\n\t$transition_medium:\t0.25s ease-in-out;\r\n\t$transition_slow:\t\t0.5s ease-in-out;\r\n\r\n\r\n/***** Shadows *****/\r\n\r\n\t/* source: https://brumm.af/shadows */\r\n\t$nice_shadow:\r\n\t\t0 2.8px 2.2px rgba(0, 0, 0, 0.02),\r\n\t\t0 6.7px 5.3px rgba(0, 0, 0, 0.028),\r\n\t\t0 12.5px 10px rgba(0, 0, 0, 0.035),\r\n\t\t0 22.3px 17.9px rgba(0, 0, 0, 0.042),\r\n\t\t0 41.8px 33.4px rgba(0, 0, 0, 0.05),\r\n\t\t0 100px 80px rgba(0, 0, 0, 0.07);\r\n\r\n\r\n\t$text-shadow-red:\r\n\t\t1px 1px $red, \r\n\t\t2px 2px $red, \r\n\t\t3px 3px $red, \r\n\t\t4px 4px $red, \r\n\t\t5px 5px $red;\r\n\t  \r\n\t$text-glow-red:\r\n\t\t0 0 1vw $red, \r\n\t\t0 0 3vw $red, \r\n\t\t0 0 10vw $red, \r\n\t\t0 0 10vw $red, \r\n\t\t0 0 .4vw $red, \r\n\t\t.25vw .25vw .1vw #806914;\r\n","/**************************************************\r\nVARS File\r\n\r\nDescription:\tStore SCSS vars here\r\n\r\n\r\n**************************************************/\n/***** Color Variables *****/\n/***** Named Colors *****/\n/***** Fonts *****/\n/***** Font Sizes *****/\n/***** Letter Spacing *****/\n/***** Content Widths *****/\n/***** Transition Timings *****/\n/***** Shadows *****/\n/* source: https://brumm.af/shadows */\n/**************************************************\r\nMIXINS File\r\n\r\nDescription:\tStore SCSS mixins here\r\n\r\nCall: @include backgroundStandard;\r\n\r\n**************************************************/\n.footer {\n  width: 100%;\n  height: 100px;\n  border-top: 1px solid #eaeaea;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  margin-top: 150px; }\n  .footer .footer_message {\n    font-size: 3rem;\n    font-family: \"AncientMedium\"; }\n","/**************************************************\r\nMIXINS File\r\n\r\nDescription:\tStore SCSS mixins here\r\n\r\nCall: @include backgroundStandard;\r\n\r\n**************************************************/\r\n\r\n\r\n@mixin flex_center {\r\n\tdisplay: flex;\r\n\tflex-direction: row;\r\n\tjustify-content: center;\r\n\talign-items: center;\r\n}\r\n\r\n@mixin backgroundStandard {\r\n\tbackground-size: cover;\r\n\tbackground-position: center;\r\n\tbackground-repeat: no-repeat;\r\n}\r\n\r\n@mixin solidShadowHover {\r\n\t&:hover{\r\n\t\ttext-shadow: $text-shadow-red;\r\n\t}\r\n}\r\n\r\n@mixin maxWidth($maxWidth) {\r\n\twidth: 100%;\r\n\tmax-width: $maxWidth;\r\n\tmargin-left: auto;\r\n\tmargin-right: auto;\r\n}\r\n\r\n@mixin paperTexture{\r\n\t&:after{\r\n\t\tcontent:'';\r\n\t\tposition: absolute;\r\n\t\theight: 100%;\r\n\t\twidth: 100%;\r\n\t\ttop: 0;\r\n\t\tleft: 0;\r\n\t\topacity: .5;\r\n\t\tpointer-events: none;\r\n\t\tbackground-image: url('/img/textures/natural-paper.png');\r\n\t\tbackground-repeat: repeat;\r\n\t\t//mix-blend-mode: lighten;\r\n\t\t//filter: contrast(1.5);\r\n\t\tbackground-size: cover;\r\n\t}\r\n}"],"sourceRoot":""}]);
// Exports
___CSS_LOADER_EXPORT___.locals = {
	"footer": "Footer_footer__3aUwb",
	"footer_message": "Footer_footer_message__XsYhv"
};
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./node_modules/next/dist/compiled/resolve-url-loader/index.js?!./node_modules/next/dist/compiled/sass-loader/cjs.js?!./components/Template/Header/Header.module.scss":
/*!*****************************************************************************************************************************************************************************************************************************************************!*\
  !*** (webpack)/css-loader/cjs.js??ref--5-oneOf-3-1!(webpack)/postcss-loader/cjs.js??ref--5-oneOf-3-2!(webpack)/resolve-url-loader??ref--5-oneOf-3-3!(webpack)/sass-loader/cjs.js??ref--5-oneOf-3-4!./components/Template/Header/Header.module.scss ***!
  \*****************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../../node_modules/next/dist/compiled/css-loader/api.js */ "./node_modules/next/dist/compiled/css-loader/api.js");
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);
// Module
___CSS_LOADER_EXPORT___.push([module.i, "/**************************************************\r\nVARS File\r\n\r\nDescription:\tStore SCSS vars here\r\n\r\n\r\n**************************************************/\n/***** Color Variables *****/\n/***** Named Colors *****/\n/***** Fonts *****/\n/***** Font Sizes *****/\n/***** Letter Spacing *****/\n/***** Content Widths *****/\n/***** Transition Timings *****/\n/***** Shadows *****/\n/* source: https://brumm.af/shadows */\n/**************************************************\r\nMIXINS File\r\n\r\nDescription:\tStore SCSS mixins here\r\n\r\nCall: @include backgroundStandard;\r\n\r\n**************************************************/\n.Header_header__2tXk3 {\n  width: 100%;\n  background-color: #D1D3D4; }\n\n.Header_container__b6Uux {\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  justify-content: space-between; }\n\n.Header_contentLeft__HPdQO {\n  display: flex;\n  flex-direction: row;\n  justify-content: flex-start;\n  align-items: center;\n  width: 100%;\n  max-width: 100%; }\n  .Header_contentLeft__HPdQO .Header_logo__3Sb59 {\n    display: flex;\n    flex-direction: row;\n    justify-content: center;\n    align-items: center;\n    padding: 10px;\n    margin-right: 30px;\n    border: none; }\n  .Header_contentLeft__HPdQO .Header_title__1hEU7 {\n    display: flex;\n    flex-direction: row;\n    justify-content: center;\n    align-items: center;\n    position: relative;\n    font-size: 65px;\n    padding: 10px 0; }\n\n.Header_contentRight__1F3VT {\n  display: flex;\n  flex-direction: row;\n  justify-content: center;\n  align-items: center;\n  width: 100%;\n  max-width: calc(100% - $static_width); }\n", "",{"version":3,"sources":["webpack://../../../styles/vars.scss","webpack://Header.module.scss","webpack://../../../styles/mixins.scss"],"names":[],"mappings":"AAAA;;;;;;kDCMkD;ADGlD,4BAAA;AAUC,yBAAA;AASD,kBAAA;AAKA,uBAAA;AAMA,2BAAA;AAIA,2BAAA;AAMA,+BAAA;AAMA,oBAAA;AAEC,qCAAA;AEzDD;;;;;;;kDDuBkD;AAnBlD;EACC,WAAW;EACX,yBDWmB,EAAA;;ACPpB;EACC,aAAa;EACb,mBAAmB;EACnB,mBAAmB;EACnB,8BAA8B,EAAA;;AAM/B;EACC,aAAa;EACb,mBAAmB;EACnB,2BAA2B;EAC3B,mBAAmB;EACnB,WAAW;EACX,eARkB,EAAA;EAEnB;ICTC,aAAa;IACb,mBAAmB;IACnB,uBAAuB;IACvB,mBAAmB;IDgBlB,aAAa;IACb,kBAAkB;IAClB,YAAY,EAAA;EAZd;ICTC,aAAa;IACb,mBAAmB;IACnB,uBAAuB;IACvB,mBAAmB;IDuBlB,kBAAkB;IAClB,eDJuB;ICKvB,eAAe,EAAA;;AAIjB;EACC,aAAa;EACb,mBAAmB;EACnB,uBAAuB;EACvB,mBAAmB;EACnB,WAAW;EACX,qCAAqC,EAAA","sourcesContent":["/**************************************************\r\nVARS File\r\n\r\nDescription:\tStore SCSS vars here\r\n\r\n\r\n**************************************************/\r\n\r\n\r\n/***** Color Variables *****/\r\n\t$black: \t\t#212121;\r\n\t$white: \t\t#fafafa;\r\n\t$grey_1:\t\t#ececec;\r\n\t$grey_2:\t\t#3e3e3e;\r\n\r\n\t$red: \t\t\t#fb0000;\r\n\t\r\n\t$nasa_grey:\t#D1D3D4;\r\n\r\n\t/***** Named Colors *****/\r\n\t\t$primary_color:\t\t$black;\r\n\t\t$secondary_color:\t\t$white;\r\n\r\n\t\t$background_color:\t$white;\r\n\t\t$text_color:\t\t\t$black;\r\n\t\t$accent_color:\t\t$grey_1;\r\n\r\n\r\n/***** Fonts *****/\r\n\t$font_body:\t\t\"MyUnderwood\";\r\n\t$font_display:\t\"AncientMedium\";\r\n\t$font_alt:\t\t\t\"ImpactLabel\";\r\n\r\n/***** Font Sizes *****/\r\n\t$font_size_heading:\t65px;\r\n\t$font_size_subhead:\t36px;\r\n\t$font_size_body:\t\t20px;\r\n\t$font_size_detail:\t16px;\r\n\r\n/***** Letter Spacing *****/\r\n\t$letterSpacingWide:\t\t0.035em;\r\n\t$letterSpacingNormal:\t0.035em;\r\n\r\n/***** Content Widths *****/\r\n\t$content_width_s: \t650px;\r\n\t$content_width_m: \t920px;\r\n\t$content_width_l: \t1450px;\r\n\r\n\r\n/***** Transition Timings *****/\r\n\t$transition_fast:\t\t0.1s ease-in-out;\r\n\t$transition_medium:\t0.25s ease-in-out;\r\n\t$transition_slow:\t\t0.5s ease-in-out;\r\n\r\n\r\n/***** Shadows *****/\r\n\r\n\t/* source: https://brumm.af/shadows */\r\n\t$nice_shadow:\r\n\t\t0 2.8px 2.2px rgba(0, 0, 0, 0.02),\r\n\t\t0 6.7px 5.3px rgba(0, 0, 0, 0.028),\r\n\t\t0 12.5px 10px rgba(0, 0, 0, 0.035),\r\n\t\t0 22.3px 17.9px rgba(0, 0, 0, 0.042),\r\n\t\t0 41.8px 33.4px rgba(0, 0, 0, 0.05),\r\n\t\t0 100px 80px rgba(0, 0, 0, 0.07);\r\n\r\n\r\n\t$text-shadow-red:\r\n\t\t1px 1px $red, \r\n\t\t2px 2px $red, \r\n\t\t3px 3px $red, \r\n\t\t4px 4px $red, \r\n\t\t5px 5px $red;\r\n\t  \r\n\t$text-glow-red:\r\n\t\t0 0 1vw $red, \r\n\t\t0 0 3vw $red, \r\n\t\t0 0 10vw $red, \r\n\t\t0 0 10vw $red, \r\n\t\t0 0 .4vw $red, \r\n\t\t.25vw .25vw .1vw #806914;\r\n","/**************************************************\r\nVARS File\r\n\r\nDescription:\tStore SCSS vars here\r\n\r\n\r\n**************************************************/\n/***** Color Variables *****/\n/***** Named Colors *****/\n/***** Fonts *****/\n/***** Font Sizes *****/\n/***** Letter Spacing *****/\n/***** Content Widths *****/\n/***** Transition Timings *****/\n/***** Shadows *****/\n/* source: https://brumm.af/shadows */\n/**************************************************\r\nMIXINS File\r\n\r\nDescription:\tStore SCSS mixins here\r\n\r\nCall: @include backgroundStandard;\r\n\r\n**************************************************/\n.header {\n  width: 100%;\n  background-color: #D1D3D4; }\n\n.container {\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  justify-content: space-between; }\n\n.contentLeft {\n  display: flex;\n  flex-direction: row;\n  justify-content: flex-start;\n  align-items: center;\n  width: 100%;\n  max-width: 100%; }\n  .contentLeft .logo {\n    display: flex;\n    flex-direction: row;\n    justify-content: center;\n    align-items: center;\n    padding: 10px;\n    margin-right: 30px;\n    border: none; }\n  .contentLeft .title {\n    display: flex;\n    flex-direction: row;\n    justify-content: center;\n    align-items: center;\n    position: relative;\n    font-size: 65px;\n    padding: 10px 0; }\n\n.contentRight {\n  display: flex;\n  flex-direction: row;\n  justify-content: center;\n  align-items: center;\n  width: 100%;\n  max-width: calc(100% - $static_width); }\n","/**************************************************\r\nMIXINS File\r\n\r\nDescription:\tStore SCSS mixins here\r\n\r\nCall: @include backgroundStandard;\r\n\r\n**************************************************/\r\n\r\n\r\n@mixin flex_center {\r\n\tdisplay: flex;\r\n\tflex-direction: row;\r\n\tjustify-content: center;\r\n\talign-items: center;\r\n}\r\n\r\n@mixin backgroundStandard {\r\n\tbackground-size: cover;\r\n\tbackground-position: center;\r\n\tbackground-repeat: no-repeat;\r\n}\r\n\r\n@mixin solidShadowHover {\r\n\t&:hover{\r\n\t\ttext-shadow: $text-shadow-red;\r\n\t}\r\n}\r\n\r\n@mixin maxWidth($maxWidth) {\r\n\twidth: 100%;\r\n\tmax-width: $maxWidth;\r\n\tmargin-left: auto;\r\n\tmargin-right: auto;\r\n}\r\n\r\n@mixin paperTexture{\r\n\t&:after{\r\n\t\tcontent:'';\r\n\t\tposition: absolute;\r\n\t\theight: 100%;\r\n\t\twidth: 100%;\r\n\t\ttop: 0;\r\n\t\tleft: 0;\r\n\t\topacity: .5;\r\n\t\tpointer-events: none;\r\n\t\tbackground-image: url('/img/textures/natural-paper.png');\r\n\t\tbackground-repeat: repeat;\r\n\t\t//mix-blend-mode: lighten;\r\n\t\t//filter: contrast(1.5);\r\n\t\tbackground-size: cover;\r\n\t}\r\n}"],"sourceRoot":""}]);
// Exports
___CSS_LOADER_EXPORT___.locals = {
	"header": "Header_header__2tXk3",
	"container": "Header_container__b6Uux",
	"contentLeft": "Header_contentLeft__HPdQO",
	"logo": "Header_logo__3Sb59",
	"title": "Header_title__1hEU7",
	"contentRight": "Header_contentRight__1F3VT"
};
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./node_modules/next/dist/compiled/resolve-url-loader/index.js?!./node_modules/next/dist/compiled/sass-loader/cjs.js?!./components/Template/Sandbox/Sandbox.module.scss":
/*!*******************************************************************************************************************************************************************************************************************************************************!*\
  !*** (webpack)/css-loader/cjs.js??ref--5-oneOf-3-1!(webpack)/postcss-loader/cjs.js??ref--5-oneOf-3-2!(webpack)/resolve-url-loader??ref--5-oneOf-3-3!(webpack)/sass-loader/cjs.js??ref--5-oneOf-3-4!./components/Template/Sandbox/Sandbox.module.scss ***!
  \*******************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../../node_modules/next/dist/compiled/css-loader/api.js */ "./node_modules/next/dist/compiled/css-loader/api.js");
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);
// Module
___CSS_LOADER_EXPORT___.push([module.i, "/**************************************************\r\nVARS File\r\n\r\nDescription:\tStore SCSS vars here\r\n\r\n\r\n**************************************************/\n/***** Color Variables *****/\n/***** Named Colors *****/\n/***** Fonts *****/\n/***** Font Sizes *****/\n/***** Letter Spacing *****/\n/***** Content Widths *****/\n/***** Transition Timings *****/\n/***** Shadows *****/\n/* source: https://brumm.af/shadows */\n/**************************************************\r\nMIXINS File\r\n\r\nDescription:\tStore SCSS mixins here\r\n\r\nCall: @include backgroundStandard;\r\n\r\n**************************************************/\n.Sandbox_sandbox__13XBh {\n  display: block;\n  width: 100%;\n  padding: 0px 0; }\n  .Sandbox_sandbox__13XBh .Sandbox_content__1SEyy {\n    background-color: #D1D3D4;\n    padding: 25px 35px 35px;\n    width: 100%;\n    border-radius: 50px;\n    box-shadow: 0 2.8px 2.2px rgba(0, 0, 0, 0.02), 0 6.7px 5.3px rgba(0, 0, 0, 0.028), 0 12.5px 10px rgba(0, 0, 0, 0.035), 0 22.3px 17.9px rgba(0, 0, 0, 0.042), 0 41.8px 33.4px rgba(0, 0, 0, 0.05), 0 100px 80px rgba(0, 0, 0, 0.07); }\n  .Sandbox_sandbox__13XBh .Sandbox_title__Q86aV {\n    font-size: 12px;\n    margin-bottom: 15px;\n    display: block; }\n  .Sandbox_sandbox__13XBh .Sandbox_inner__1FyGs {\n    padding: 35px;\n    width: 100%;\n    height: 100%;\n    border: 2px dashed #212121;\n    min-height: 500px;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    flex-wrap: wrap; }\n", "",{"version":3,"sources":["webpack://../../../styles/vars.scss","webpack://Sandbox.module.scss","webpack://../../../styles/mixins.scss"],"names":[],"mappings":"AAAA;;;;;;kDCMkD;ADGlD,4BAAA;AAUC,yBAAA;AASD,kBAAA;AAKA,uBAAA;AAMA,2BAAA;AAIA,2BAAA;AAMA,+BAAA;AAMA,oBAAA;AAEC,qCAAA;AEzDD;;;;;;;kDDuBkD;AApBlD;EACC,cAAc;EACd,WAAW;EACX,cAAc,EAAA;EAHf;IAME,yBDQkB;ICPlB,uBAAwB;IACxB,WAAW;IAEX,mBAAmB;IACnB,kODkDgC,EAAA;EC7DlC;IAeE,eAAe;IACf,mBAAmB;IACnB,cAAc,EAAA;EAjBhB;IAqBE,aAAa;IACb,WAAW;IACX,YAAY;IACZ,0BDjBgB;ICkBhB,iBAAiB;IACjB,aAAa;IACb,uBAAuB;IACvB,mBAAmB;IACnB,eAAe,EAAA","sourcesContent":["/**************************************************\r\nVARS File\r\n\r\nDescription:\tStore SCSS vars here\r\n\r\n\r\n**************************************************/\r\n\r\n\r\n/***** Color Variables *****/\r\n\t$black: \t\t#212121;\r\n\t$white: \t\t#fafafa;\r\n\t$grey_1:\t\t#ececec;\r\n\t$grey_2:\t\t#3e3e3e;\r\n\r\n\t$red: \t\t\t#fb0000;\r\n\t\r\n\t$nasa_grey:\t#D1D3D4;\r\n\r\n\t/***** Named Colors *****/\r\n\t\t$primary_color:\t\t$black;\r\n\t\t$secondary_color:\t\t$white;\r\n\r\n\t\t$background_color:\t$white;\r\n\t\t$text_color:\t\t\t$black;\r\n\t\t$accent_color:\t\t$grey_1;\r\n\r\n\r\n/***** Fonts *****/\r\n\t$font_body:\t\t\"MyUnderwood\";\r\n\t$font_display:\t\"AncientMedium\";\r\n\t$font_alt:\t\t\t\"ImpactLabel\";\r\n\r\n/***** Font Sizes *****/\r\n\t$font_size_heading:\t65px;\r\n\t$font_size_subhead:\t36px;\r\n\t$font_size_body:\t\t20px;\r\n\t$font_size_detail:\t16px;\r\n\r\n/***** Letter Spacing *****/\r\n\t$letterSpacingWide:\t\t0.035em;\r\n\t$letterSpacingNormal:\t0.035em;\r\n\r\n/***** Content Widths *****/\r\n\t$content_width_s: \t650px;\r\n\t$content_width_m: \t920px;\r\n\t$content_width_l: \t1450px;\r\n\r\n\r\n/***** Transition Timings *****/\r\n\t$transition_fast:\t\t0.1s ease-in-out;\r\n\t$transition_medium:\t0.25s ease-in-out;\r\n\t$transition_slow:\t\t0.5s ease-in-out;\r\n\r\n\r\n/***** Shadows *****/\r\n\r\n\t/* source: https://brumm.af/shadows */\r\n\t$nice_shadow:\r\n\t\t0 2.8px 2.2px rgba(0, 0, 0, 0.02),\r\n\t\t0 6.7px 5.3px rgba(0, 0, 0, 0.028),\r\n\t\t0 12.5px 10px rgba(0, 0, 0, 0.035),\r\n\t\t0 22.3px 17.9px rgba(0, 0, 0, 0.042),\r\n\t\t0 41.8px 33.4px rgba(0, 0, 0, 0.05),\r\n\t\t0 100px 80px rgba(0, 0, 0, 0.07);\r\n\r\n\r\n\t$text-shadow-red:\r\n\t\t1px 1px $red, \r\n\t\t2px 2px $red, \r\n\t\t3px 3px $red, \r\n\t\t4px 4px $red, \r\n\t\t5px 5px $red;\r\n\t  \r\n\t$text-glow-red:\r\n\t\t0 0 1vw $red, \r\n\t\t0 0 3vw $red, \r\n\t\t0 0 10vw $red, \r\n\t\t0 0 10vw $red, \r\n\t\t0 0 .4vw $red, \r\n\t\t.25vw .25vw .1vw #806914;\r\n","/**************************************************\r\nVARS File\r\n\r\nDescription:\tStore SCSS vars here\r\n\r\n\r\n**************************************************/\n/***** Color Variables *****/\n/***** Named Colors *****/\n/***** Fonts *****/\n/***** Font Sizes *****/\n/***** Letter Spacing *****/\n/***** Content Widths *****/\n/***** Transition Timings *****/\n/***** Shadows *****/\n/* source: https://brumm.af/shadows */\n/**************************************************\r\nMIXINS File\r\n\r\nDescription:\tStore SCSS mixins here\r\n\r\nCall: @include backgroundStandard;\r\n\r\n**************************************************/\n.sandbox {\n  display: block;\n  width: 100%;\n  padding: 0px 0; }\n  .sandbox .content {\n    background-color: #D1D3D4;\n    padding: 25px 35px 35px;\n    width: 100%;\n    border-radius: 50px;\n    box-shadow: 0 2.8px 2.2px rgba(0, 0, 0, 0.02), 0 6.7px 5.3px rgba(0, 0, 0, 0.028), 0 12.5px 10px rgba(0, 0, 0, 0.035), 0 22.3px 17.9px rgba(0, 0, 0, 0.042), 0 41.8px 33.4px rgba(0, 0, 0, 0.05), 0 100px 80px rgba(0, 0, 0, 0.07); }\n  .sandbox .title {\n    font-size: 12px;\n    margin-bottom: 15px;\n    display: block; }\n  .sandbox .inner {\n    padding: 35px;\n    width: 100%;\n    height: 100%;\n    border: 2px dashed #212121;\n    min-height: 500px;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    flex-wrap: wrap; }\n","/**************************************************\r\nMIXINS File\r\n\r\nDescription:\tStore SCSS mixins here\r\n\r\nCall: @include backgroundStandard;\r\n\r\n**************************************************/\r\n\r\n\r\n@mixin flex_center {\r\n\tdisplay: flex;\r\n\tflex-direction: row;\r\n\tjustify-content: center;\r\n\talign-items: center;\r\n}\r\n\r\n@mixin backgroundStandard {\r\n\tbackground-size: cover;\r\n\tbackground-position: center;\r\n\tbackground-repeat: no-repeat;\r\n}\r\n\r\n@mixin solidShadowHover {\r\n\t&:hover{\r\n\t\ttext-shadow: $text-shadow-red;\r\n\t}\r\n}\r\n\r\n@mixin maxWidth($maxWidth) {\r\n\twidth: 100%;\r\n\tmax-width: $maxWidth;\r\n\tmargin-left: auto;\r\n\tmargin-right: auto;\r\n}\r\n\r\n@mixin paperTexture{\r\n\t&:after{\r\n\t\tcontent:'';\r\n\t\tposition: absolute;\r\n\t\theight: 100%;\r\n\t\twidth: 100%;\r\n\t\ttop: 0;\r\n\t\tleft: 0;\r\n\t\topacity: .5;\r\n\t\tpointer-events: none;\r\n\t\tbackground-image: url('/img/textures/natural-paper.png');\r\n\t\tbackground-repeat: repeat;\r\n\t\t//mix-blend-mode: lighten;\r\n\t\t//filter: contrast(1.5);\r\n\t\tbackground-size: cover;\r\n\t}\r\n}"],"sourceRoot":""}]);
// Exports
___CSS_LOADER_EXPORT___.locals = {
	"sandbox": "Sandbox_sandbox__13XBh",
	"content": "Sandbox_content__1SEyy",
	"title": "Sandbox_title__Q86aV",
	"inner": "Sandbox_inner__1FyGs"
};
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ "./node_modules/next/dist/compiled/webpack/harmony-module.js":
/*!*******************************************!*\
  !*** (webpack)/webpack/harmony-module.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__dirname) {module.exports =
/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 931:
/***/ (function(module) {

module.exports = function(originalModule) {
	if (!originalModule.webpackPolyfill) {
		var module = Object.create(originalModule);
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		Object.defineProperty(module, "exports", {
			enumerable: true
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nccwpck_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			__webpack_modules__[moduleId](module, module.exports, __nccwpck_require__);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete __webpack_module_cache__[moduleId];
/******/ 		}
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat */
/******/ 	
/******/ 	__nccwpck_require__.ab = __dirname + "/";/************************************************************************/
/******/ 	// module exports must be returned from runtime so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	return __nccwpck_require__(931);
/******/ })()
;
/* WEBPACK VAR INJECTION */}.call(this, "/"))

/***/ }),

/***/ "./node_modules/next/dist/compiled/webpack/module.js":
/*!***********************************!*\
  !*** (webpack)/webpack/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__dirname) {module.exports =
/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 880:
/***/ (function(module) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nccwpck_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			__webpack_modules__[moduleId](module, module.exports, __nccwpck_require__);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete __webpack_module_cache__[moduleId];
/******/ 		}
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat */
/******/ 	
/******/ 	__nccwpck_require__.ab = __dirname + "/";/************************************************************************/
/******/ 	// module exports must be returned from runtime so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	return __nccwpck_require__(880);
/******/ })()
;
/* WEBPACK VAR INJECTION */}.call(this, "/"))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/amp-context.js":
/*!***************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/amp-context.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.AmpStateContext = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

var AmpStateContext = /*#__PURE__*/_react["default"].createContext({});

exports.AmpStateContext = AmpStateContext;

if (true) {
  AmpStateContext.displayName = 'AmpStateContext';
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/amp.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/amp.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _s = $RefreshSig$();

exports.__esModule = true;
exports.isInAmpMode = isInAmpMode;
exports.useAmp = useAmp;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _ampContext = __webpack_require__(/*! ./amp-context */ "./node_modules/next/dist/next-server/lib/amp-context.js");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function isInAmpMode() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$ampFirst = _ref.ampFirst,
      ampFirst = _ref$ampFirst === void 0 ? false : _ref$ampFirst,
      _ref$hybrid = _ref.hybrid,
      hybrid = _ref$hybrid === void 0 ? false : _ref$hybrid,
      _ref$hasQuery = _ref.hasQuery,
      hasQuery = _ref$hasQuery === void 0 ? false : _ref$hasQuery;

  return ampFirst || hybrid && hasQuery;
}

function useAmp() {
  _s();

  // Don't assign the context value to a variable to save bytes
  return isInAmpMode(_react["default"].useContext(_ampContext.AmpStateContext));
}

_s(useAmp, "gDsCjeeItUuvgOWf1v4qoK9RF6k=");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/head-manager-context.js":
/*!************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/head-manager-context.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.HeadManagerContext = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

var HeadManagerContext = /*#__PURE__*/_react["default"].createContext({});

exports.HeadManagerContext = HeadManagerContext;

if (true) {
  HeadManagerContext.displayName = 'HeadManagerContext';
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/head.js":
/*!********************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/head.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _defineProperty = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

exports.__esModule = true;
exports.defaultHead = defaultHead;
exports["default"] = void 0;

var _react = _interopRequireWildcard(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _sideEffect = _interopRequireDefault(__webpack_require__(/*! ./side-effect */ "./node_modules/next/dist/next-server/lib/side-effect.js"));

var _ampContext = __webpack_require__(/*! ./amp-context */ "./node_modules/next/dist/next-server/lib/amp-context.js");

var _headManagerContext = __webpack_require__(/*! ./head-manager-context */ "./node_modules/next/dist/next-server/lib/head-manager-context.js");

var _amp = __webpack_require__(/*! ./amp */ "./node_modules/next/dist/next-server/lib/amp.js");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function defaultHead() {
  var inAmpMode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  var head = [/*#__PURE__*/_react["default"].createElement("meta", {
    charSet: "utf-8"
  })];

  if (!inAmpMode) {
    head.push( /*#__PURE__*/_react["default"].createElement("meta", {
      name: "viewport",
      content: "width=device-width"
    }));
  }

  return head;
}

function onlyReactElement(list, child) {
  // React children can be "string" or "number" in this case we ignore them for backwards compat
  if (typeof child === 'string' || typeof child === 'number') {
    return list;
  } // Adds support for React.Fragment


  if (child.type === _react["default"].Fragment) {
    return list.concat(_react["default"].Children.toArray(child.props.children).reduce(function (fragmentList, fragmentChild) {
      if (typeof fragmentChild === 'string' || typeof fragmentChild === 'number') {
        return fragmentList;
      }

      return fragmentList.concat(fragmentChild);
    }, []));
  }

  return list.concat(child);
}

var METATYPES = ['name', 'httpEquiv', 'charSet', 'itemProp'];
/*
returns a function for filtering head child elements
which shouldn't be duplicated, like <title/>
Also adds support for deduplicated `key` properties
*/

function unique() {
  var keys = new Set();
  var tags = new Set();
  var metaTypes = new Set();
  var metaCategories = {};
  return function (h) {
    var isUnique = true;
    var hasKey = false;

    if (h.key && typeof h.key !== 'number' && h.key.indexOf('$') > 0) {
      hasKey = true;
      var key = h.key.slice(h.key.indexOf('$') + 1);

      if (keys.has(key)) {
        isUnique = false;
      } else {
        keys.add(key);
      }
    } // eslint-disable-next-line default-case


    switch (h.type) {
      case 'title':
      case 'base':
        if (tags.has(h.type)) {
          isUnique = false;
        } else {
          tags.add(h.type);
        }

        break;

      case 'meta':
        for (var i = 0, len = METATYPES.length; i < len; i++) {
          var metatype = METATYPES[i];
          if (!h.props.hasOwnProperty(metatype)) continue;

          if (metatype === 'charSet') {
            if (metaTypes.has(metatype)) {
              isUnique = false;
            } else {
              metaTypes.add(metatype);
            }
          } else {
            var category = h.props[metatype];
            var categories = metaCategories[metatype] || new Set();

            if ((metatype !== 'name' || !hasKey) && categories.has(category)) {
              isUnique = false;
            } else {
              categories.add(category);
              metaCategories[metatype] = categories;
            }
          }
        }

        break;
    }

    return isUnique;
  };
}
/**
*
* @param headElements List of multiple <Head> instances
*/


function reduceComponents(headElements, props) {
  return headElements.reduce(function (list, headElement) {
    var headElementChildren = _react["default"].Children.toArray(headElement.props.children);

    return list.concat(headElementChildren);
  }, []).reduce(onlyReactElement, []).reverse().concat(defaultHead(props.inAmpMode)).filter(unique()).reverse().map(function (c, i) {
    var key = c.key || i;

    if (false) { var newProps; }

    return /*#__PURE__*/_react["default"].cloneElement(c, {
      key: key
    });
  });
}
/**
* This component injects elements to `<head>` of your page.
* To avoid duplicated `tags` in `<head>` you can use the `key` property, which will make sure every tag is only rendered once.
*/


function Head(_ref) {
  var children = _ref.children;
  var ampState = (0, _react.useContext)(_ampContext.AmpStateContext);
  var headManager = (0, _react.useContext)(_headManagerContext.HeadManagerContext);
  return /*#__PURE__*/_react["default"].createElement(_sideEffect["default"], {
    reduceComponentsToState: reduceComponents,
    headManager: headManager,
    inAmpMode: (0, _amp.isInAmpMode)(ampState)
  }, children);
} // TODO: Remove in the next major release


_c = Head;

Head.rewind = function () {};

var _default = Head;
exports["default"] = _default;

var _c;

$RefreshReg$(_c, "Head");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/side-effect.js":
/*!***************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/side-effect.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _toConsumableArray = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/toConsumableArray */ "./node_modules/@babel/runtime/helpers/toConsumableArray.js");

var _classCallCheck = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js");

var _createClass = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js");

var _assertThisInitialized = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js");

var _inherits = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js");

var _possibleConstructorReturn = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js");

var _getPrototypeOf = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

exports.__esModule = true;
exports["default"] = void 0;

var _react = __webpack_require__(/*! react */ "./node_modules/react/index.js");

var isServer = false;

var _default = /*#__PURE__*/function (_react$Component) {
  _inherits(_default, _react$Component);

  var _super = _createSuper(_default);

  function _default(props) {
    var _this;

    _classCallCheck(this, _default);

    _this = _super.call(this, props);
    _this._hasHeadManager = void 0;

    _this.emitChange = function () {
      if (_this._hasHeadManager) {
        _this.props.headManager.updateHead(_this.props.reduceComponentsToState(_toConsumableArray(_this.props.headManager.mountedInstances), _this.props));
      }
    };

    _this._hasHeadManager = _this.props.headManager && _this.props.headManager.mountedInstances;

    if (isServer && _this._hasHeadManager) {
      _this.props.headManager.mountedInstances.add(_assertThisInitialized(_this));

      _this.emitChange();
    }

    return _this;
  }

  _createClass(_default, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      if (this._hasHeadManager) {
        this.props.headManager.mountedInstances.add(this);
      }

      this.emitChange();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.emitChange();
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this._hasHeadManager) {
        this.props.headManager.mountedInstances["delete"](this);
      }

      this.emitChange();
    }
  }, {
    key: "render",
    value: function render() {
      return null;
    }
  }]);

  return _default;
}(_react.Component);

exports["default"] = _default;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/to-base-64.js":
/*!**************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/to-base-64.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.toBase64 = toBase64;
/**
* Isomorphic base64 that works on the server and client
*/

function toBase64(str) {
  if (false) {} else {
    return window.btoa(str);
  }
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/server/image-config.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/next-server/server/image-config.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
exports.__esModule=true;exports.imageConfigDefault=exports.VALID_LOADERS=void 0;const VALID_LOADERS=['default','imgix','cloudinary','akamai'];exports.VALID_LOADERS=VALID_LOADERS;const imageConfigDefault={deviceSizes:[640,750,828,1080,1200,1920,2048,3840],imageSizes:[16,32,48,64,96,128,256,384],path:'/_next/image',loader:'default',domains:[]};exports.imageConfigDefault=imageConfigDefault;
//# sourceMappingURL=image-config.js.map

/***/ }),

/***/ "./node_modules/next/head.js":
/*!***********************************!*\
  !*** ./node_modules/next/head.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./dist/next-server/lib/head */ "./node_modules/next/dist/next-server/lib/head.js")


/***/ }),

/***/ "./node_modules/next/image.js":
/*!************************************!*\
  !*** ./node_modules/next/image.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./dist/client/image */ "./node_modules/next/dist/client/image.js")


/***/ }),

/***/ "./node_modules/react/cjs/react-jsx-dev-runtime.development.js":
/*!*********************************************************************!*\
  !*** ./node_modules/react/cjs/react-jsx-dev-runtime.development.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v17.0.1
 * react-jsx-dev-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  (function() {
'use strict';

var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var _assign = __webpack_require__(/*! object-assign */ "./node_modules/next/dist/build/polyfills/object-assign.js");

// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var REACT_ELEMENT_TYPE = 0xeac7;
var REACT_PORTAL_TYPE = 0xeaca;
exports.Fragment = 0xeacb;
var REACT_STRICT_MODE_TYPE = 0xeacc;
var REACT_PROFILER_TYPE = 0xead2;
var REACT_PROVIDER_TYPE = 0xeacd;
var REACT_CONTEXT_TYPE = 0xeace;
var REACT_FORWARD_REF_TYPE = 0xead0;
var REACT_SUSPENSE_TYPE = 0xead1;
var REACT_SUSPENSE_LIST_TYPE = 0xead8;
var REACT_MEMO_TYPE = 0xead3;
var REACT_LAZY_TYPE = 0xead4;
var REACT_BLOCK_TYPE = 0xead9;
var REACT_SERVER_BLOCK_TYPE = 0xeada;
var REACT_FUNDAMENTAL_TYPE = 0xead5;
var REACT_SCOPE_TYPE = 0xead7;
var REACT_OPAQUE_ID_TYPE = 0xeae0;
var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;
var REACT_OFFSCREEN_TYPE = 0xeae2;
var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;

if (typeof Symbol === 'function' && Symbol.for) {
  var symbolFor = Symbol.for;
  REACT_ELEMENT_TYPE = symbolFor('react.element');
  REACT_PORTAL_TYPE = symbolFor('react.portal');
  exports.Fragment = symbolFor('react.fragment');
  REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');
  REACT_PROFILER_TYPE = symbolFor('react.profiler');
  REACT_PROVIDER_TYPE = symbolFor('react.provider');
  REACT_CONTEXT_TYPE = symbolFor('react.context');
  REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
  REACT_SUSPENSE_TYPE = symbolFor('react.suspense');
  REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
  REACT_MEMO_TYPE = symbolFor('react.memo');
  REACT_LAZY_TYPE = symbolFor('react.lazy');
  REACT_BLOCK_TYPE = symbolFor('react.block');
  REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
  REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
  REACT_SCOPE_TYPE = symbolFor('react.scope');
  REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');
  REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
  REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');
  REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
}

var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';
function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable !== 'object') {
    return null;
  }

  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }

  return null;
}

var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

function error(format) {
  {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    printWarning('error', format, args);
  }
}

function printWarning(level, format, args) {
  // When changing this logic, you might want to also
  // update consoleWithStackDev.www.js as well.
  {
    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
    var stack = ReactDebugCurrentFrame.getStackAddendum();

    if (stack !== '') {
      format += '%s';
      args = args.concat([stack]);
    }

    var argsWithFormat = args.map(function (item) {
      return '' + item;
    }); // Careful: RN currently depends on this prefix

    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
    // breaks IE9: https://github.com/facebook/react/issues/13610
    // eslint-disable-next-line react-internal/no-production-logging

    Function.prototype.apply.call(console[level], console, argsWithFormat);
  }
}

// Filter certain DOM attributes (e.g. src, href) if their values are empty strings.

var enableScopeAPI = false; // Experimental Create Event Handle API.

function isValidElementType(type) {
  if (typeof type === 'string' || typeof type === 'function') {
    return true;
  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).


  if (type === exports.Fragment || type === REACT_PROFILER_TYPE || type === REACT_DEBUG_TRACING_MODE_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI ) {
    return true;
  }

  if (typeof type === 'object' && type !== null) {
    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
      return true;
    }
  }

  return false;
}

function getWrappedName(outerType, innerType, wrapperName) {
  var functionName = innerType.displayName || innerType.name || '';
  return outerType.displayName || (functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName);
}

function getContextName(type) {
  return type.displayName || 'Context';
}

function getComponentName(type) {
  if (type == null) {
    // Host root, text node or just invalid type.
    return null;
  }

  {
    if (typeof type.tag === 'number') {
      error('Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');
    }
  }

  if (typeof type === 'function') {
    return type.displayName || type.name || null;
  }

  if (typeof type === 'string') {
    return type;
  }

  switch (type) {
    case exports.Fragment:
      return 'Fragment';

    case REACT_PORTAL_TYPE:
      return 'Portal';

    case REACT_PROFILER_TYPE:
      return 'Profiler';

    case REACT_STRICT_MODE_TYPE:
      return 'StrictMode';

    case REACT_SUSPENSE_TYPE:
      return 'Suspense';

    case REACT_SUSPENSE_LIST_TYPE:
      return 'SuspenseList';
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_CONTEXT_TYPE:
        var context = type;
        return getContextName(context) + '.Consumer';

      case REACT_PROVIDER_TYPE:
        var provider = type;
        return getContextName(provider._context) + '.Provider';

      case REACT_FORWARD_REF_TYPE:
        return getWrappedName(type, type.render, 'ForwardRef');

      case REACT_MEMO_TYPE:
        return getComponentName(type.type);

      case REACT_BLOCK_TYPE:
        return getComponentName(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            return getComponentName(init(payload));
          } catch (x) {
            return null;
          }
        }
    }
  }

  return null;
}

// Helpers to patch console.logs to avoid logging during side-effect free
// replaying on render function. This currently only patches the object
// lazily which won't cover if the log function was extracted eagerly.
// We could also eagerly patch the method.
var disabledDepth = 0;
var prevLog;
var prevInfo;
var prevWarn;
var prevError;
var prevGroup;
var prevGroupCollapsed;
var prevGroupEnd;

function disabledLog() {}

disabledLog.__reactDisabledLog = true;
function disableLogs() {
  {
    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      prevLog = console.log;
      prevInfo = console.info;
      prevWarn = console.warn;
      prevError = console.error;
      prevGroup = console.group;
      prevGroupCollapsed = console.groupCollapsed;
      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099

      var props = {
        configurable: true,
        enumerable: true,
        value: disabledLog,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        info: props,
        log: props,
        warn: props,
        error: props,
        group: props,
        groupCollapsed: props,
        groupEnd: props
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    disabledDepth++;
  }
}
function reenableLogs() {
  {
    disabledDepth--;

    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      var props = {
        configurable: true,
        enumerable: true,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        log: _assign({}, props, {
          value: prevLog
        }),
        info: _assign({}, props, {
          value: prevInfo
        }),
        warn: _assign({}, props, {
          value: prevWarn
        }),
        error: _assign({}, props, {
          value: prevError
        }),
        group: _assign({}, props, {
          value: prevGroup
        }),
        groupCollapsed: _assign({}, props, {
          value: prevGroupCollapsed
        }),
        groupEnd: _assign({}, props, {
          value: prevGroupEnd
        })
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    if (disabledDepth < 0) {
      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
    }
  }
}

var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
var prefix;
function describeBuiltInComponentFrame(name, source, ownerFn) {
  {
    if (prefix === undefined) {
      // Extract the VM specific prefix used by each line.
      try {
        throw Error();
      } catch (x) {
        var match = x.stack.trim().match(/\n( *(at )?)/);
        prefix = match && match[1] || '';
      }
    } // We use the prefix to ensure our stacks line up with native stack frames.


    return '\n' + prefix + name;
  }
}
var reentry = false;
var componentFrameCache;

{
  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
  componentFrameCache = new PossiblyWeakMap();
}

function describeNativeComponentFrame(fn, construct) {
  // If something asked for a stack inside a fake render, it should get ignored.
  if (!fn || reentry) {
    return '';
  }

  {
    var frame = componentFrameCache.get(fn);

    if (frame !== undefined) {
      return frame;
    }
  }

  var control;
  reentry = true;
  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.

  Error.prepareStackTrace = undefined;
  var previousDispatcher;

  {
    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function
    // for warnings.

    ReactCurrentDispatcher.current = null;
    disableLogs();
  }

  try {
    // This should throw.
    if (construct) {
      // Something should be setting the props in the constructor.
      var Fake = function () {
        throw Error();
      }; // $FlowFixMe


      Object.defineProperty(Fake.prototype, 'props', {
        set: function () {
          // We use a throwing setter instead of frozen or non-writable props
          // because that won't throw in a non-strict mode function.
          throw Error();
        }
      });

      if (typeof Reflect === 'object' && Reflect.construct) {
        // We construct a different control for this case to include any extra
        // frames added by the construct call.
        try {
          Reflect.construct(Fake, []);
        } catch (x) {
          control = x;
        }

        Reflect.construct(fn, [], Fake);
      } else {
        try {
          Fake.call();
        } catch (x) {
          control = x;
        }

        fn.call(Fake.prototype);
      }
    } else {
      try {
        throw Error();
      } catch (x) {
        control = x;
      }

      fn();
    }
  } catch (sample) {
    // This is inlined manually because closure doesn't do it for us.
    if (sample && control && typeof sample.stack === 'string') {
      // This extracts the first frame from the sample that isn't also in the control.
      // Skipping one frame that we assume is the frame that calls the two.
      var sampleLines = sample.stack.split('\n');
      var controlLines = control.stack.split('\n');
      var s = sampleLines.length - 1;
      var c = controlLines.length - 1;

      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
        // We expect at least one stack frame to be shared.
        // Typically this will be the root most one. However, stack frames may be
        // cut off due to maximum stack limits. In this case, one maybe cut off
        // earlier than the other. We assume that the sample is longer or the same
        // and there for cut off earlier. So we should find the root most frame in
        // the sample somewhere in the control.
        c--;
      }

      for (; s >= 1 && c >= 0; s--, c--) {
        // Next we find the first one that isn't the same which should be the
        // frame that called our sample function and the control.
        if (sampleLines[s] !== controlLines[c]) {
          // In V8, the first line is describing the message but other VMs don't.
          // If we're about to return the first line, and the control is also on the same
          // line, that's a pretty good indicator that our sample threw at same line as
          // the control. I.e. before we entered the sample frame. So we ignore this result.
          // This can happen if you passed a class to function component, or non-function.
          if (s !== 1 || c !== 1) {
            do {
              s--;
              c--; // We may still have similar intermediate frames from the construct call.
              // The next one that isn't the same should be our match though.

              if (c < 0 || sampleLines[s] !== controlLines[c]) {
                // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                var _frame = '\n' + sampleLines[s].replace(' at new ', ' at ');

                {
                  if (typeof fn === 'function') {
                    componentFrameCache.set(fn, _frame);
                  }
                } // Return the line we found.


                return _frame;
              }
            } while (s >= 1 && c >= 0);
          }

          break;
        }
      }
    }
  } finally {
    reentry = false;

    {
      ReactCurrentDispatcher.current = previousDispatcher;
      reenableLogs();
    }

    Error.prepareStackTrace = previousPrepareStackTrace;
  } // Fallback to just using the name if we couldn't make it throw.


  var name = fn ? fn.displayName || fn.name : '';
  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';

  {
    if (typeof fn === 'function') {
      componentFrameCache.set(fn, syntheticFrame);
    }
  }

  return syntheticFrame;
}
function describeFunctionComponentFrame(fn, source, ownerFn) {
  {
    return describeNativeComponentFrame(fn, false);
  }
}

function shouldConstruct(Component) {
  var prototype = Component.prototype;
  return !!(prototype && prototype.isReactComponent);
}

function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {

  if (type == null) {
    return '';
  }

  if (typeof type === 'function') {
    {
      return describeNativeComponentFrame(type, shouldConstruct(type));
    }
  }

  if (typeof type === 'string') {
    return describeBuiltInComponentFrame(type);
  }

  switch (type) {
    case REACT_SUSPENSE_TYPE:
      return describeBuiltInComponentFrame('Suspense');

    case REACT_SUSPENSE_LIST_TYPE:
      return describeBuiltInComponentFrame('SuspenseList');
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_FORWARD_REF_TYPE:
        return describeFunctionComponentFrame(type.render);

      case REACT_MEMO_TYPE:
        // Memo may contain any component type so we recursively resolve it.
        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);

      case REACT_BLOCK_TYPE:
        return describeFunctionComponentFrame(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            // Lazy may contain any component type so we recursively resolve it.
            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
          } catch (x) {}
        }
    }
  }

  return '';
}

var loggedTypeFailures = {};
var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;

function setCurrentlyValidatingElement(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      ReactDebugCurrentFrame.setExtraStackFrame(stack);
    } else {
      ReactDebugCurrentFrame.setExtraStackFrame(null);
    }
  }
}

function checkPropTypes(typeSpecs, values, location, componentName, element) {
  {
    // $FlowFixMe This is okay but Flow doesn't know it.
    var has = Function.call.bind(Object.prototype.hasOwnProperty);

    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.

        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
            err.name = 'Invariant Violation';
            throw err;
          }

          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
        } catch (ex) {
          error$1 = ex;
        }

        if (error$1 && !(error$1 instanceof Error)) {
          setCurrentlyValidatingElement(element);

          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);

          setCurrentlyValidatingElement(null);
        }

        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error$1.message] = true;
          setCurrentlyValidatingElement(element);

          error('Failed %s type: %s', location, error$1.message);

          setCurrentlyValidatingElement(null);
        }
      }
    }
  }
}

var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};
var specialPropKeyWarningShown;
var specialPropRefWarningShown;
var didWarnAboutStringRefs;

{
  didWarnAboutStringRefs = {};
}

function hasValidRef(config) {
  {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.ref !== undefined;
}

function hasValidKey(config) {
  {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.key !== undefined;
}

function warnIfStringRefCannotBeAutoConverted(config, self) {
  {
    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {
      var componentName = getComponentName(ReactCurrentOwner.current.type);

      if (!didWarnAboutStringRefs[componentName]) {
        error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentName(ReactCurrentOwner.current.type), config.ref);

        didWarnAboutStringRefs[componentName] = true;
      }
    }
  }
}

function defineKeyPropWarningGetter(props, displayName) {
  {
    var warnAboutAccessingKey = function () {
      if (!specialPropKeyWarningShown) {
        specialPropKeyWarningShown = true;

        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    };

    warnAboutAccessingKey.isReactWarning = true;
    Object.defineProperty(props, 'key', {
      get: warnAboutAccessingKey,
      configurable: true
    });
  }
}

function defineRefPropWarningGetter(props, displayName) {
  {
    var warnAboutAccessingRef = function () {
      if (!specialPropRefWarningShown) {
        specialPropRefWarningShown = true;

        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    };

    warnAboutAccessingRef.isReactWarning = true;
    Object.defineProperty(props, 'ref', {
      get: warnAboutAccessingRef,
      configurable: true
    });
  }
}
/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, instanceof check
 * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} props
 * @param {*} key
 * @param {string|object} ref
 * @param {*} owner
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @internal
 */


var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allows us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,
    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,
    // Record the component responsible for creating this element.
    _owner: owner
  };

  {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.

    Object.defineProperty(element._store, 'validated', {
      configurable: false,
      enumerable: false,
      writable: true,
      value: false
    }); // self and source are DEV only properties.

    Object.defineProperty(element, '_self', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: self
    }); // Two elements created in two different places should be considered
    // equal for testing purposes and therefore we hide it from enumeration.

    Object.defineProperty(element, '_source', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: source
    });

    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};
/**
 * https://github.com/reactjs/rfcs/pull/107
 * @param {*} type
 * @param {object} props
 * @param {string} key
 */

function jsxDEV(type, config, maybeKey, source, self) {
  {
    var propName; // Reserved names are extracted

    var props = {};
    var key = null;
    var ref = null; // Currently, key can be spread in as a prop. This causes a potential
    // issue if key is also explicitly declared (ie. <div {...props} key="Hi" />
    // or <div key="Hi" {...props} /> ). We want to deprecate key spread,
    // but as an intermediary step, we will use jsxDEV for everything except
    // <div {...props} key="Hi" />, because we aren't currently able to tell if
    // key is explicitly declared to be undefined or not.

    if (maybeKey !== undefined) {
      key = '' + maybeKey;
    }

    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    if (hasValidRef(config)) {
      ref = config.ref;
      warnIfStringRefCannotBeAutoConverted(config, self);
    } // Remaining properties are added to a new props object


    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    } // Resolve default props


    if (type && type.defaultProps) {
      var defaultProps = type.defaultProps;

      for (propName in defaultProps) {
        if (props[propName] === undefined) {
          props[propName] = defaultProps[propName];
        }
      }
    }

    if (key || ref) {
      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;

      if (key) {
        defineKeyPropWarningGetter(props, displayName);
      }

      if (ref) {
        defineRefPropWarningGetter(props, displayName);
      }
    }

    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
  }
}

var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;

function setCurrentlyValidatingElement$1(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
    } else {
      ReactDebugCurrentFrame$1.setExtraStackFrame(null);
    }
  }
}

var propTypesMisspellWarningShown;

{
  propTypesMisspellWarningShown = false;
}
/**
 * Verifies the object is a ReactElement.
 * See https://reactjs.org/docs/react-api.html#isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a ReactElement.
 * @final
 */

function isValidElement(object) {
  {
    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
  }
}

function getDeclarationErrorAddendum() {
  {
    if (ReactCurrentOwner$1.current) {
      var name = getComponentName(ReactCurrentOwner$1.current.type);

      if (name) {
        return '\n\nCheck the render method of `' + name + '`.';
      }
    }

    return '';
  }
}

function getSourceInfoErrorAddendum(source) {
  {
    if (source !== undefined) {
      var fileName = source.fileName.replace(/^.*[\\\/]/, '');
      var lineNumber = source.lineNumber;
      return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
    }

    return '';
  }
}
/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */


var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  {
    var info = getDeclarationErrorAddendum();

    if (!info) {
      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;

      if (parentName) {
        info = "\n\nCheck the top-level render call using <" + parentName + ">.";
      }
    }

    return info;
  }
}
/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */


function validateExplicitKey(element, parentType) {
  {
    if (!element._store || element._store.validated || element.key != null) {
      return;
    }

    element._store.validated = true;
    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);

    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
      return;
    }

    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
    // property, it may be the creator of the child that's responsible for
    // assigning it a key.

    var childOwner = '';

    if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
      // Give the component that originally created this child.
      childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
    }

    setCurrentlyValidatingElement$1(element);

    error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);

    setCurrentlyValidatingElement$1(null);
  }
}
/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */


function validateChildKeys(node, parentType) {
  {
    if (typeof node !== 'object') {
      return;
    }

    if (Array.isArray(node)) {
      for (var i = 0; i < node.length; i++) {
        var child = node[i];

        if (isValidElement(child)) {
          validateExplicitKey(child, parentType);
        }
      }
    } else if (isValidElement(node)) {
      // This element was passed in a valid location.
      if (node._store) {
        node._store.validated = true;
      }
    } else if (node) {
      var iteratorFn = getIteratorFn(node);

      if (typeof iteratorFn === 'function') {
        // Entry iterators used to provide implicit keys,
        // but now we print a separate warning for them later.
        if (iteratorFn !== node.entries) {
          var iterator = iteratorFn.call(node);
          var step;

          while (!(step = iterator.next()).done) {
            if (isValidElement(step.value)) {
              validateExplicitKey(step.value, parentType);
            }
          }
        }
      }
    }
  }
}
/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */


function validatePropTypes(element) {
  {
    var type = element.type;

    if (type === null || type === undefined || typeof type === 'string') {
      return;
    }

    var propTypes;

    if (typeof type === 'function') {
      propTypes = type.propTypes;
    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
    // Inner props are checked in the reconciler.
    type.$$typeof === REACT_MEMO_TYPE)) {
      propTypes = type.propTypes;
    } else {
      return;
    }

    if (propTypes) {
      // Intentionally inside to avoid triggering lazy initializers:
      var name = getComponentName(type);
      checkPropTypes(propTypes, element.props, 'prop', name, element);
    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:

      var _name = getComponentName(type);

      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
    }

    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
    }
  }
}
/**
 * Given a fragment, validate that it can only be provided with fragment props
 * @param {ReactElement} fragment
 */


function validateFragmentProps(fragment) {
  {
    var keys = Object.keys(fragment.props);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];

      if (key !== 'children' && key !== 'key') {
        setCurrentlyValidatingElement$1(fragment);

        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);

        setCurrentlyValidatingElement$1(null);
        break;
      }
    }

    if (fragment.ref !== null) {
      setCurrentlyValidatingElement$1(fragment);

      error('Invalid attribute `ref` supplied to `React.Fragment`.');

      setCurrentlyValidatingElement$1(null);
    }
  }
}

function jsxWithValidation(type, props, key, isStaticChildren, source, self) {
  {
    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
    // succeed and there will likely be errors in render.

    if (!validType) {
      var info = '';

      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
        info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
      }

      var sourceInfo = getSourceInfoErrorAddendum(source);

      if (sourceInfo) {
        info += sourceInfo;
      } else {
        info += getDeclarationErrorAddendum();
      }

      var typeString;

      if (type === null) {
        typeString = 'null';
      } else if (Array.isArray(type)) {
        typeString = 'array';
      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
        typeString = "<" + (getComponentName(type.type) || 'Unknown') + " />";
        info = ' Did you accidentally export a JSX literal instead of a component?';
      } else {
        typeString = typeof type;
      }

      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
    }

    var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.
    // TODO: Drop this when these are no longer allowed as the type argument.

    if (element == null) {
      return element;
    } // Skip key warning if the type isn't valid since our key validation logic
    // doesn't expect a non-string/function type and can throw confusing errors.
    // We don't want exception behavior to differ between dev and prod.
    // (Rendering will throw with a helpful message and as soon as the type is
    // fixed, the key warnings will appear.)


    if (validType) {
      var children = props.children;

      if (children !== undefined) {
        if (isStaticChildren) {
          if (Array.isArray(children)) {
            for (var i = 0; i < children.length; i++) {
              validateChildKeys(children[i], type);
            }

            if (Object.freeze) {
              Object.freeze(children);
            }
          } else {
            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');
          }
        } else {
          validateChildKeys(children, type);
        }
      }
    }

    if (type === exports.Fragment) {
      validateFragmentProps(element);
    } else {
      validatePropTypes(element);
    }

    return element;
  }
} // These two functions exist to still get child warnings in dev

var jsxDEV$1 =  jsxWithValidation ;

exports.jsxDEV = jsxDEV$1;
  })();
}


/***/ }),

/***/ "./node_modules/react/cjs/react.development.js":
/*!*****************************************************!*\
  !*** ./node_modules/react/cjs/react.development.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v17.0.1
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  (function() {
'use strict';

var _assign = __webpack_require__(/*! object-assign */ "./node_modules/next/dist/build/polyfills/object-assign.js");

// TODO: this is special because it gets imported during build.
var ReactVersion = '17.0.1';

// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var REACT_ELEMENT_TYPE = 0xeac7;
var REACT_PORTAL_TYPE = 0xeaca;
exports.Fragment = 0xeacb;
exports.StrictMode = 0xeacc;
exports.Profiler = 0xead2;
var REACT_PROVIDER_TYPE = 0xeacd;
var REACT_CONTEXT_TYPE = 0xeace;
var REACT_FORWARD_REF_TYPE = 0xead0;
exports.Suspense = 0xead1;
var REACT_SUSPENSE_LIST_TYPE = 0xead8;
var REACT_MEMO_TYPE = 0xead3;
var REACT_LAZY_TYPE = 0xead4;
var REACT_BLOCK_TYPE = 0xead9;
var REACT_SERVER_BLOCK_TYPE = 0xeada;
var REACT_FUNDAMENTAL_TYPE = 0xead5;
var REACT_SCOPE_TYPE = 0xead7;
var REACT_OPAQUE_ID_TYPE = 0xeae0;
var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;
var REACT_OFFSCREEN_TYPE = 0xeae2;
var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;

if (typeof Symbol === 'function' && Symbol.for) {
  var symbolFor = Symbol.for;
  REACT_ELEMENT_TYPE = symbolFor('react.element');
  REACT_PORTAL_TYPE = symbolFor('react.portal');
  exports.Fragment = symbolFor('react.fragment');
  exports.StrictMode = symbolFor('react.strict_mode');
  exports.Profiler = symbolFor('react.profiler');
  REACT_PROVIDER_TYPE = symbolFor('react.provider');
  REACT_CONTEXT_TYPE = symbolFor('react.context');
  REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
  exports.Suspense = symbolFor('react.suspense');
  REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
  REACT_MEMO_TYPE = symbolFor('react.memo');
  REACT_LAZY_TYPE = symbolFor('react.lazy');
  REACT_BLOCK_TYPE = symbolFor('react.block');
  REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
  REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
  REACT_SCOPE_TYPE = symbolFor('react.scope');
  REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');
  REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
  REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');
  REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
}

var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';
function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable !== 'object') {
    return null;
  }

  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }

  return null;
}

/**
 * Keeps track of the current dispatcher.
 */
var ReactCurrentDispatcher = {
  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null
};

/**
 * Keeps track of the current batch's configuration such as how long an update
 * should suspend for if it needs to.
 */
var ReactCurrentBatchConfig = {
  transition: 0
};

/**
 * Keeps track of the current owner.
 *
 * The current owner is the component who should own any components that are
 * currently being constructed.
 */
var ReactCurrentOwner = {
  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null
};

var ReactDebugCurrentFrame = {};
var currentExtraStackFrame = null;
function setExtraStackFrame(stack) {
  {
    currentExtraStackFrame = stack;
  }
}

{
  ReactDebugCurrentFrame.setExtraStackFrame = function (stack) {
    {
      currentExtraStackFrame = stack;
    }
  }; // Stack implementation injected by the current renderer.


  ReactDebugCurrentFrame.getCurrentStack = null;

  ReactDebugCurrentFrame.getStackAddendum = function () {
    var stack = ''; // Add an extra top frame while an element is being validated

    if (currentExtraStackFrame) {
      stack += currentExtraStackFrame;
    } // Delegate to the injected renderer-specific implementation


    var impl = ReactDebugCurrentFrame.getCurrentStack;

    if (impl) {
      stack += impl() || '';
    }

    return stack;
  };
}

/**
 * Used by act() to track whether you're inside an act() scope.
 */
var IsSomeRendererActing = {
  current: false
};

var ReactSharedInternals = {
  ReactCurrentDispatcher: ReactCurrentDispatcher,
  ReactCurrentBatchConfig: ReactCurrentBatchConfig,
  ReactCurrentOwner: ReactCurrentOwner,
  IsSomeRendererActing: IsSomeRendererActing,
  // Used by renderers to avoid bundling object-assign twice in UMD bundles:
  assign: _assign
};

{
  ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
}

// by calls to these methods by a Babel plugin.
//
// In PROD (or in packages without access to React internals),
// they are left as they are instead.

function warn(format) {
  {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    printWarning('warn', format, args);
  }
}
function error(format) {
  {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    printWarning('error', format, args);
  }
}

function printWarning(level, format, args) {
  // When changing this logic, you might want to also
  // update consoleWithStackDev.www.js as well.
  {
    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
    var stack = ReactDebugCurrentFrame.getStackAddendum();

    if (stack !== '') {
      format += '%s';
      args = args.concat([stack]);
    }

    var argsWithFormat = args.map(function (item) {
      return '' + item;
    }); // Careful: RN currently depends on this prefix

    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
    // breaks IE9: https://github.com/facebook/react/issues/13610
    // eslint-disable-next-line react-internal/no-production-logging

    Function.prototype.apply.call(console[level], console, argsWithFormat);
  }
}

var didWarnStateUpdateForUnmountedComponent = {};

function warnNoop(publicInstance, callerName) {
  {
    var _constructor = publicInstance.constructor;
    var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';
    var warningKey = componentName + "." + callerName;

    if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
      return;
    }

    error("Can't call %s on a component that is not yet mounted. " + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);

    didWarnStateUpdateForUnmountedComponent[warningKey] = true;
  }
}
/**
 * This is the abstract API for an update queue.
 */


var ReactNoopUpdateQueue = {
  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function (publicInstance) {
    return false;
  },

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueForceUpdate: function (publicInstance, callback, callerName) {
    warnNoop(publicInstance, 'forceUpdate');
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {
    warnNoop(publicInstance, 'replaceState');
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} Name of the calling function in the public API.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState, callback, callerName) {
    warnNoop(publicInstance, 'setState');
  }
};

var emptyObject = {};

{
  Object.freeze(emptyObject);
}
/**
 * Base class helpers for the updating state of a component.
 */


function Component(props, context, updater) {
  this.props = props;
  this.context = context; // If a component has string refs, we will assign a different object later.

  this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the
  // renderer.

  this.updater = updater || ReactNoopUpdateQueue;
}

Component.prototype.isReactComponent = {};
/**
 * Sets a subset of the state. Always use this to mutate
 * state. You should treat `this.state` as immutable.
 *
 * There is no guarantee that `this.state` will be immediately updated, so
 * accessing `this.state` after calling this method may return the old value.
 *
 * There is no guarantee that calls to `setState` will run synchronously,
 * as they may eventually be batched together.  You can provide an optional
 * callback that will be executed when the call to setState is actually
 * completed.
 *
 * When a function is provided to setState, it will be called at some point in
 * the future (not synchronously). It will be called with the up to date
 * component arguments (state, props, context). These values can be different
 * from this.* because your function may be called after receiveProps but before
 * shouldComponentUpdate, and this new state, props, and context will not yet be
 * assigned to this.
 *
 * @param {object|function} partialState Next partial state or function to
 *        produce next partial state to be merged with current state.
 * @param {?function} callback Called after state is updated.
 * @final
 * @protected
 */

Component.prototype.setState = function (partialState, callback) {
  if (!(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null)) {
    {
      throw Error( "setState(...): takes an object of state variables to update or a function which returns an object of state variables." );
    }
  }

  this.updater.enqueueSetState(this, partialState, callback, 'setState');
};
/**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
 * You may want to call this when you know that some deeper aspect of the
 * component's state has changed but `setState` was not called.
 *
 * This will not invoke `shouldComponentUpdate`, but it will invoke
 * `componentWillUpdate` and `componentDidUpdate`.
 *
 * @param {?function} callback Called after update is complete.
 * @final
 * @protected
 */


Component.prototype.forceUpdate = function (callback) {
  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
};
/**
 * Deprecated APIs. These APIs used to exist on classic React classes but since
 * we would like to deprecate them, we're not going to move them over to this
 * modern base class. Instead, we define a getter that warns if it's accessed.
 */


{
  var deprecatedAPIs = {
    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
  };

  var defineDeprecationWarning = function (methodName, info) {
    Object.defineProperty(Component.prototype, methodName, {
      get: function () {
        warn('%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);

        return undefined;
      }
    });
  };

  for (var fnName in deprecatedAPIs) {
    if (deprecatedAPIs.hasOwnProperty(fnName)) {
      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    }
  }
}

function ComponentDummy() {}

ComponentDummy.prototype = Component.prototype;
/**
 * Convenience component with default shallow equality check for sCU.
 */

function PureComponent(props, context, updater) {
  this.props = props;
  this.context = context; // If a component has string refs, we will assign a different object later.

  this.refs = emptyObject;
  this.updater = updater || ReactNoopUpdateQueue;
}

var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
pureComponentPrototype.constructor = PureComponent; // Avoid an extra prototype jump for these methods.

_assign(pureComponentPrototype, Component.prototype);

pureComponentPrototype.isPureReactComponent = true;

// an immutable object with a single mutable value
function createRef() {
  var refObject = {
    current: null
  };

  {
    Object.seal(refObject);
  }

  return refObject;
}

function getWrappedName(outerType, innerType, wrapperName) {
  var functionName = innerType.displayName || innerType.name || '';
  return outerType.displayName || (functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName);
}

function getContextName(type) {
  return type.displayName || 'Context';
}

function getComponentName(type) {
  if (type == null) {
    // Host root, text node or just invalid type.
    return null;
  }

  {
    if (typeof type.tag === 'number') {
      error('Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');
    }
  }

  if (typeof type === 'function') {
    return type.displayName || type.name || null;
  }

  if (typeof type === 'string') {
    return type;
  }

  switch (type) {
    case exports.Fragment:
      return 'Fragment';

    case REACT_PORTAL_TYPE:
      return 'Portal';

    case exports.Profiler:
      return 'Profiler';

    case exports.StrictMode:
      return 'StrictMode';

    case exports.Suspense:
      return 'Suspense';

    case REACT_SUSPENSE_LIST_TYPE:
      return 'SuspenseList';
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_CONTEXT_TYPE:
        var context = type;
        return getContextName(context) + '.Consumer';

      case REACT_PROVIDER_TYPE:
        var provider = type;
        return getContextName(provider._context) + '.Provider';

      case REACT_FORWARD_REF_TYPE:
        return getWrappedName(type, type.render, 'ForwardRef');

      case REACT_MEMO_TYPE:
        return getComponentName(type.type);

      case REACT_BLOCK_TYPE:
        return getComponentName(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            return getComponentName(init(payload));
          } catch (x) {
            return null;
          }
        }
    }
  }

  return null;
}

var hasOwnProperty = Object.prototype.hasOwnProperty;
var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};
var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;

{
  didWarnAboutStringRefs = {};
}

function hasValidRef(config) {
  {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.ref !== undefined;
}

function hasValidKey(config) {
  {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.key !== undefined;
}

function defineKeyPropWarningGetter(props, displayName) {
  var warnAboutAccessingKey = function () {
    {
      if (!specialPropKeyWarningShown) {
        specialPropKeyWarningShown = true;

        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    }
  };

  warnAboutAccessingKey.isReactWarning = true;
  Object.defineProperty(props, 'key', {
    get: warnAboutAccessingKey,
    configurable: true
  });
}

function defineRefPropWarningGetter(props, displayName) {
  var warnAboutAccessingRef = function () {
    {
      if (!specialPropRefWarningShown) {
        specialPropRefWarningShown = true;

        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    }
  };

  warnAboutAccessingRef.isReactWarning = true;
  Object.defineProperty(props, 'ref', {
    get: warnAboutAccessingRef,
    configurable: true
  });
}

function warnIfStringRefCannotBeAutoConverted(config) {
  {
    if (typeof config.ref === 'string' && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
      var componentName = getComponentName(ReactCurrentOwner.current.type);

      if (!didWarnAboutStringRefs[componentName]) {
        error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);

        didWarnAboutStringRefs[componentName] = true;
      }
    }
  }
}
/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, instanceof check
 * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} props
 * @param {*} key
 * @param {string|object} ref
 * @param {*} owner
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @internal
 */


var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allows us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,
    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,
    // Record the component responsible for creating this element.
    _owner: owner
  };

  {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.

    Object.defineProperty(element._store, 'validated', {
      configurable: false,
      enumerable: false,
      writable: true,
      value: false
    }); // self and source are DEV only properties.

    Object.defineProperty(element, '_self', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: self
    }); // Two elements created in two different places should be considered
    // equal for testing purposes and therefore we hide it from enumeration.

    Object.defineProperty(element, '_source', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: source
    });

    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};
/**
 * Create and return a new ReactElement of the given type.
 * See https://reactjs.org/docs/react-api.html#createelement
 */

function createElement(type, config, children) {
  var propName; // Reserved names are extracted

  var props = {};
  var key = null;
  var ref = null;
  var self = null;
  var source = null;

  if (config != null) {
    if (hasValidRef(config)) {
      ref = config.ref;

      {
        warnIfStringRefCannotBeAutoConverted(config);
      }
    }

    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    self = config.__self === undefined ? null : config.__self;
    source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object

    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  } // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.


  var childrenLength = arguments.length - 2;

  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);

    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }

    {
      if (Object.freeze) {
        Object.freeze(childArray);
      }
    }

    props.children = childArray;
  } // Resolve default props


  if (type && type.defaultProps) {
    var defaultProps = type.defaultProps;

    for (propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }
  }

  {
    if (key || ref) {
      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;

      if (key) {
        defineKeyPropWarningGetter(props, displayName);
      }

      if (ref) {
        defineRefPropWarningGetter(props, displayName);
      }
    }
  }

  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
}
function cloneAndReplaceKey(oldElement, newKey) {
  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
  return newElement;
}
/**
 * Clone and return a new ReactElement using element as the starting point.
 * See https://reactjs.org/docs/react-api.html#cloneelement
 */

function cloneElement(element, config, children) {
  if (!!(element === null || element === undefined)) {
    {
      throw Error( "React.cloneElement(...): The argument must be a React element, but you passed " + element + "." );
    }
  }

  var propName; // Original props are copied

  var props = _assign({}, element.props); // Reserved names are extracted


  var key = element.key;
  var ref = element.ref; // Self is preserved since the owner is preserved.

  var self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a
  // transpiler, and the original source is probably a better indicator of the
  // true owner.

  var source = element._source; // Owner will be preserved, unless ref is overridden

  var owner = element._owner;

  if (config != null) {
    if (hasValidRef(config)) {
      // Silently steal the ref from the parent.
      ref = config.ref;
      owner = ReactCurrentOwner.current;
    }

    if (hasValidKey(config)) {
      key = '' + config.key;
    } // Remaining properties override existing props


    var defaultProps;

    if (element.type && element.type.defaultProps) {
      defaultProps = element.type.defaultProps;
    }

    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        if (config[propName] === undefined && defaultProps !== undefined) {
          // Resolve default props
          props[propName] = defaultProps[propName];
        } else {
          props[propName] = config[propName];
        }
      }
    }
  } // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.


  var childrenLength = arguments.length - 2;

  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);

    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }

    props.children = childArray;
  }

  return ReactElement(element.type, key, ref, self, source, owner, props);
}
/**
 * Verifies the object is a ReactElement.
 * See https://reactjs.org/docs/react-api.html#isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a ReactElement.
 * @final
 */

function isValidElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}

var SEPARATOR = '.';
var SUBSEPARATOR = ':';
/**
 * Escape and wrap key so it is safe to use as a reactid
 *
 * @param {string} key to be escaped.
 * @return {string} the escaped key.
 */

function escape(key) {
  var escapeRegex = /[=:]/g;
  var escaperLookup = {
    '=': '=0',
    ':': '=2'
  };
  var escapedString = key.replace(escapeRegex, function (match) {
    return escaperLookup[match];
  });
  return '$' + escapedString;
}
/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */


var didWarnAboutMaps = false;
var userProvidedKeyEscapeRegex = /\/+/g;

function escapeUserProvidedKey(text) {
  return text.replace(userProvidedKeyEscapeRegex, '$&/');
}
/**
 * Generate a key string that identifies a element within a set.
 *
 * @param {*} element A element that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */


function getElementKey(element, index) {
  // Do some typechecking here since we call this blindly. We want to ensure
  // that we don't block potential future ES APIs.
  if (typeof element === 'object' && element !== null && element.key != null) {
    // Explicit key
    return escape('' + element.key);
  } // Implicit key determined by the index in the set


  return index.toString(36);
}

function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
  var type = typeof children;

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  var invokeCallback = false;

  if (children === null) {
    invokeCallback = true;
  } else {
    switch (type) {
      case 'string':
      case 'number':
        invokeCallback = true;
        break;

      case 'object':
        switch (children.$$typeof) {
          case REACT_ELEMENT_TYPE:
          case REACT_PORTAL_TYPE:
            invokeCallback = true;
        }

    }
  }

  if (invokeCallback) {
    var _child = children;
    var mappedChild = callback(_child); // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows:

    var childKey = nameSoFar === '' ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;

    if (Array.isArray(mappedChild)) {
      var escapedChildKey = '';

      if (childKey != null) {
        escapedChildKey = escapeUserProvidedKey(childKey) + '/';
      }

      mapIntoArray(mappedChild, array, escapedChildKey, '', function (c) {
        return c;
      });
    } else if (mappedChild != null) {
      if (isValidElement(mappedChild)) {
        mappedChild = cloneAndReplaceKey(mappedChild, // Keep both the (mapped) and old keys if they differ, just as
        // traverseAllChildren used to do for objects as children
        escapedPrefix + ( // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
        mappedChild.key && (!_child || _child.key !== mappedChild.key) ? // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
        escapeUserProvidedKey('' + mappedChild.key) + '/' : '') + childKey);
      }

      array.push(mappedChild);
    }

    return 1;
  }

  var child;
  var nextName;
  var subtreeCount = 0; // Count of children found in the current subtree.

  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getElementKey(child, i);
      subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
    }
  } else {
    var iteratorFn = getIteratorFn(children);

    if (typeof iteratorFn === 'function') {
      var iterableChildren = children;

      {
        // Warn about using Maps as children
        if (iteratorFn === iterableChildren.entries) {
          if (!didWarnAboutMaps) {
            warn('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');
          }

          didWarnAboutMaps = true;
        }
      }

      var iterator = iteratorFn.call(iterableChildren);
      var step;
      var ii = 0;

      while (!(step = iterator.next()).done) {
        child = step.value;
        nextName = nextNamePrefix + getElementKey(child, ii++);
        subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
      }
    } else if (type === 'object') {
      var childrenString = '' + children;

      {
        {
          throw Error( "Objects are not valid as a React child (found: " + (childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString) + "). If you meant to render a collection of children, use an array instead." );
        }
      }
    }
  }

  return subtreeCount;
}

/**
 * Maps children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenmap
 *
 * The provided mapFunction(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} func The map function.
 * @param {*} context Context for mapFunction.
 * @return {object} Object containing the ordered map of results.
 */
function mapChildren(children, func, context) {
  if (children == null) {
    return children;
  }

  var result = [];
  var count = 0;
  mapIntoArray(children, result, '', '', function (child) {
    return func.call(context, child, count++);
  });
  return result;
}
/**
 * Count the number of children that are typically specified as
 * `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrencount
 *
 * @param {?*} children Children tree container.
 * @return {number} The number of children.
 */


function countChildren(children) {
  var n = 0;
  mapChildren(children, function () {
    n++; // Don't return anything
  });
  return n;
}

/**
 * Iterates through children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenforeach
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} forEachFunc
 * @param {*} forEachContext Context for forEachContext.
 */
function forEachChildren(children, forEachFunc, forEachContext) {
  mapChildren(children, function () {
    forEachFunc.apply(this, arguments); // Don't return anything.
  }, forEachContext);
}
/**
 * Flatten a children object (typically specified as `props.children`) and
 * return an array with appropriately re-keyed children.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrentoarray
 */


function toArray(children) {
  return mapChildren(children, function (child) {
    return child;
  }) || [];
}
/**
 * Returns the first child in a collection of children and verifies that there
 * is only one child in the collection.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenonly
 *
 * The current implementation of this function assumes that a single child gets
 * passed without a wrapper, but the purpose of this helper function is to
 * abstract away the particular structure of children.
 *
 * @param {?object} children Child collection structure.
 * @return {ReactElement} The first and only `ReactElement` contained in the
 * structure.
 */


function onlyChild(children) {
  if (!isValidElement(children)) {
    {
      throw Error( "React.Children.only expected to receive a single React element child." );
    }
  }

  return children;
}

function createContext(defaultValue, calculateChangedBits) {
  if (calculateChangedBits === undefined) {
    calculateChangedBits = null;
  } else {
    {
      if (calculateChangedBits !== null && typeof calculateChangedBits !== 'function') {
        error('createContext: Expected the optional second argument to be a ' + 'function. Instead received: %s', calculateChangedBits);
      }
    }
  }

  var context = {
    $$typeof: REACT_CONTEXT_TYPE,
    _calculateChangedBits: calculateChangedBits,
    // As a workaround to support multiple concurrent renderers, we categorize
    // some renderers as primary and others as secondary. We only expect
    // there to be two concurrent renderers at most: React Native (primary) and
    // Fabric (secondary); React DOM (primary) and React ART (secondary).
    // Secondary renderers store their context values on separate fields.
    _currentValue: defaultValue,
    _currentValue2: defaultValue,
    // Used to track how many concurrent renderers this context currently
    // supports within in a single renderer. Such as parallel server rendering.
    _threadCount: 0,
    // These are circular
    Provider: null,
    Consumer: null
  };
  context.Provider = {
    $$typeof: REACT_PROVIDER_TYPE,
    _context: context
  };
  var hasWarnedAboutUsingNestedContextConsumers = false;
  var hasWarnedAboutUsingConsumerProvider = false;
  var hasWarnedAboutDisplayNameOnConsumer = false;

  {
    // A separate object, but proxies back to the original context object for
    // backwards compatibility. It has a different $$typeof, so we can properly
    // warn for the incorrect usage of Context as a Consumer.
    var Consumer = {
      $$typeof: REACT_CONTEXT_TYPE,
      _context: context,
      _calculateChangedBits: context._calculateChangedBits
    }; // $FlowFixMe: Flow complains about not setting a value, which is intentional here

    Object.defineProperties(Consumer, {
      Provider: {
        get: function () {
          if (!hasWarnedAboutUsingConsumerProvider) {
            hasWarnedAboutUsingConsumerProvider = true;

            error('Rendering <Context.Consumer.Provider> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Provider> instead?');
          }

          return context.Provider;
        },
        set: function (_Provider) {
          context.Provider = _Provider;
        }
      },
      _currentValue: {
        get: function () {
          return context._currentValue;
        },
        set: function (_currentValue) {
          context._currentValue = _currentValue;
        }
      },
      _currentValue2: {
        get: function () {
          return context._currentValue2;
        },
        set: function (_currentValue2) {
          context._currentValue2 = _currentValue2;
        }
      },
      _threadCount: {
        get: function () {
          return context._threadCount;
        },
        set: function (_threadCount) {
          context._threadCount = _threadCount;
        }
      },
      Consumer: {
        get: function () {
          if (!hasWarnedAboutUsingNestedContextConsumers) {
            hasWarnedAboutUsingNestedContextConsumers = true;

            error('Rendering <Context.Consumer.Consumer> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');
          }

          return context.Consumer;
        }
      },
      displayName: {
        get: function () {
          return context.displayName;
        },
        set: function (displayName) {
          if (!hasWarnedAboutDisplayNameOnConsumer) {
            warn('Setting `displayName` on Context.Consumer has no effect. ' + "You should set it directly on the context with Context.displayName = '%s'.", displayName);

            hasWarnedAboutDisplayNameOnConsumer = true;
          }
        }
      }
    }); // $FlowFixMe: Flow complains about missing properties because it doesn't understand defineProperty

    context.Consumer = Consumer;
  }

  {
    context._currentRenderer = null;
    context._currentRenderer2 = null;
  }

  return context;
}

var Uninitialized = -1;
var Pending = 0;
var Resolved = 1;
var Rejected = 2;

function lazyInitializer(payload) {
  if (payload._status === Uninitialized) {
    var ctor = payload._result;
    var thenable = ctor(); // Transition to the next state.

    var pending = payload;
    pending._status = Pending;
    pending._result = thenable;
    thenable.then(function (moduleObject) {
      if (payload._status === Pending) {
        var defaultExport = moduleObject.default;

        {
          if (defaultExport === undefined) {
            error('lazy: Expected the result of a dynamic import() call. ' + 'Instead received: %s\n\nYour code should look like: \n  ' + // Break up imports to avoid accidentally parsing them as dependencies.
            'const MyComponent = lazy(() => imp' + "ort('./MyComponent'))", moduleObject);
          }
        } // Transition to the next state.


        var resolved = payload;
        resolved._status = Resolved;
        resolved._result = defaultExport;
      }
    }, function (error) {
      if (payload._status === Pending) {
        // Transition to the next state.
        var rejected = payload;
        rejected._status = Rejected;
        rejected._result = error;
      }
    });
  }

  if (payload._status === Resolved) {
    return payload._result;
  } else {
    throw payload._result;
  }
}

function lazy(ctor) {
  var payload = {
    // We use these fields to store the result.
    _status: -1,
    _result: ctor
  };
  var lazyType = {
    $$typeof: REACT_LAZY_TYPE,
    _payload: payload,
    _init: lazyInitializer
  };

  {
    // In production, this would just set it on the object.
    var defaultProps;
    var propTypes; // $FlowFixMe

    Object.defineProperties(lazyType, {
      defaultProps: {
        configurable: true,
        get: function () {
          return defaultProps;
        },
        set: function (newDefaultProps) {
          error('React.lazy(...): It is not supported to assign `defaultProps` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');

          defaultProps = newDefaultProps; // Match production behavior more closely:
          // $FlowFixMe

          Object.defineProperty(lazyType, 'defaultProps', {
            enumerable: true
          });
        }
      },
      propTypes: {
        configurable: true,
        get: function () {
          return propTypes;
        },
        set: function (newPropTypes) {
          error('React.lazy(...): It is not supported to assign `propTypes` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');

          propTypes = newPropTypes; // Match production behavior more closely:
          // $FlowFixMe

          Object.defineProperty(lazyType, 'propTypes', {
            enumerable: true
          });
        }
      }
    });
  }

  return lazyType;
}

function forwardRef(render) {
  {
    if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
      error('forwardRef requires a render function but received a `memo` ' + 'component. Instead of forwardRef(memo(...)), use ' + 'memo(forwardRef(...)).');
    } else if (typeof render !== 'function') {
      error('forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render);
    } else {
      if (render.length !== 0 && render.length !== 2) {
        error('forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.');
      }
    }

    if (render != null) {
      if (render.defaultProps != null || render.propTypes != null) {
        error('forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?');
      }
    }
  }

  var elementType = {
    $$typeof: REACT_FORWARD_REF_TYPE,
    render: render
  };

  {
    var ownName;
    Object.defineProperty(elementType, 'displayName', {
      enumerable: false,
      configurable: true,
      get: function () {
        return ownName;
      },
      set: function (name) {
        ownName = name;

        if (render.displayName == null) {
          render.displayName = name;
        }
      }
    });
  }

  return elementType;
}

// Filter certain DOM attributes (e.g. src, href) if their values are empty strings.

var enableScopeAPI = false; // Experimental Create Event Handle API.

function isValidElementType(type) {
  if (typeof type === 'string' || typeof type === 'function') {
    return true;
  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).


  if (type === exports.Fragment || type === exports.Profiler || type === REACT_DEBUG_TRACING_MODE_TYPE || type === exports.StrictMode || type === exports.Suspense || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI ) {
    return true;
  }

  if (typeof type === 'object' && type !== null) {
    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
      return true;
    }
  }

  return false;
}

function memo(type, compare) {
  {
    if (!isValidElementType(type)) {
      error('memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : typeof type);
    }
  }

  var elementType = {
    $$typeof: REACT_MEMO_TYPE,
    type: type,
    compare: compare === undefined ? null : compare
  };

  {
    var ownName;
    Object.defineProperty(elementType, 'displayName', {
      enumerable: false,
      configurable: true,
      get: function () {
        return ownName;
      },
      set: function (name) {
        ownName = name;

        if (type.displayName == null) {
          type.displayName = name;
        }
      }
    });
  }

  return elementType;
}

function resolveDispatcher() {
  var dispatcher = ReactCurrentDispatcher.current;

  if (!(dispatcher !== null)) {
    {
      throw Error( "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem." );
    }
  }

  return dispatcher;
}

function useContext(Context, unstable_observedBits) {
  var dispatcher = resolveDispatcher();

  {
    if (unstable_observedBits !== undefined) {
      error('useContext() second argument is reserved for future ' + 'use in React. Passing it is not supported. ' + 'You passed: %s.%s', unstable_observedBits, typeof unstable_observedBits === 'number' && Array.isArray(arguments[2]) ? '\n\nDid you call array.map(useContext)? ' + 'Calling Hooks inside a loop is not supported. ' + 'Learn more at https://reactjs.org/link/rules-of-hooks' : '');
    } // TODO: add a more generic warning for invalid values.


    if (Context._context !== undefined) {
      var realContext = Context._context; // Don't deduplicate because this legitimately causes bugs
      // and nobody should be using this in existing code.

      if (realContext.Consumer === Context) {
        error('Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' + 'removed in a future major release. Did you mean to call useContext(Context) instead?');
      } else if (realContext.Provider === Context) {
        error('Calling useContext(Context.Provider) is not supported. ' + 'Did you mean to call useContext(Context) instead?');
      }
    }
  }

  return dispatcher.useContext(Context, unstable_observedBits);
}
function useState(initialState) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useState(initialState);
}
function useReducer(reducer, initialArg, init) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useReducer(reducer, initialArg, init);
}
function useRef(initialValue) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useRef(initialValue);
}
function useEffect(create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useEffect(create, deps);
}
function useLayoutEffect(create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useLayoutEffect(create, deps);
}
function useCallback(callback, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useCallback(callback, deps);
}
function useMemo(create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useMemo(create, deps);
}
function useImperativeHandle(ref, create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useImperativeHandle(ref, create, deps);
}
function useDebugValue(value, formatterFn) {
  {
    var dispatcher = resolveDispatcher();
    return dispatcher.useDebugValue(value, formatterFn);
  }
}

// Helpers to patch console.logs to avoid logging during side-effect free
// replaying on render function. This currently only patches the object
// lazily which won't cover if the log function was extracted eagerly.
// We could also eagerly patch the method.
var disabledDepth = 0;
var prevLog;
var prevInfo;
var prevWarn;
var prevError;
var prevGroup;
var prevGroupCollapsed;
var prevGroupEnd;

function disabledLog() {}

disabledLog.__reactDisabledLog = true;
function disableLogs() {
  {
    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      prevLog = console.log;
      prevInfo = console.info;
      prevWarn = console.warn;
      prevError = console.error;
      prevGroup = console.group;
      prevGroupCollapsed = console.groupCollapsed;
      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099

      var props = {
        configurable: true,
        enumerable: true,
        value: disabledLog,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        info: props,
        log: props,
        warn: props,
        error: props,
        group: props,
        groupCollapsed: props,
        groupEnd: props
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    disabledDepth++;
  }
}
function reenableLogs() {
  {
    disabledDepth--;

    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      var props = {
        configurable: true,
        enumerable: true,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        log: _assign({}, props, {
          value: prevLog
        }),
        info: _assign({}, props, {
          value: prevInfo
        }),
        warn: _assign({}, props, {
          value: prevWarn
        }),
        error: _assign({}, props, {
          value: prevError
        }),
        group: _assign({}, props, {
          value: prevGroup
        }),
        groupCollapsed: _assign({}, props, {
          value: prevGroupCollapsed
        }),
        groupEnd: _assign({}, props, {
          value: prevGroupEnd
        })
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    if (disabledDepth < 0) {
      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
    }
  }
}

var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
var prefix;
function describeBuiltInComponentFrame(name, source, ownerFn) {
  {
    if (prefix === undefined) {
      // Extract the VM specific prefix used by each line.
      try {
        throw Error();
      } catch (x) {
        var match = x.stack.trim().match(/\n( *(at )?)/);
        prefix = match && match[1] || '';
      }
    } // We use the prefix to ensure our stacks line up with native stack frames.


    return '\n' + prefix + name;
  }
}
var reentry = false;
var componentFrameCache;

{
  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
  componentFrameCache = new PossiblyWeakMap();
}

function describeNativeComponentFrame(fn, construct) {
  // If something asked for a stack inside a fake render, it should get ignored.
  if (!fn || reentry) {
    return '';
  }

  {
    var frame = componentFrameCache.get(fn);

    if (frame !== undefined) {
      return frame;
    }
  }

  var control;
  reentry = true;
  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.

  Error.prepareStackTrace = undefined;
  var previousDispatcher;

  {
    previousDispatcher = ReactCurrentDispatcher$1.current; // Set the dispatcher in DEV because this might be call in the render function
    // for warnings.

    ReactCurrentDispatcher$1.current = null;
    disableLogs();
  }

  try {
    // This should throw.
    if (construct) {
      // Something should be setting the props in the constructor.
      var Fake = function () {
        throw Error();
      }; // $FlowFixMe


      Object.defineProperty(Fake.prototype, 'props', {
        set: function () {
          // We use a throwing setter instead of frozen or non-writable props
          // because that won't throw in a non-strict mode function.
          throw Error();
        }
      });

      if (typeof Reflect === 'object' && Reflect.construct) {
        // We construct a different control for this case to include any extra
        // frames added by the construct call.
        try {
          Reflect.construct(Fake, []);
        } catch (x) {
          control = x;
        }

        Reflect.construct(fn, [], Fake);
      } else {
        try {
          Fake.call();
        } catch (x) {
          control = x;
        }

        fn.call(Fake.prototype);
      }
    } else {
      try {
        throw Error();
      } catch (x) {
        control = x;
      }

      fn();
    }
  } catch (sample) {
    // This is inlined manually because closure doesn't do it for us.
    if (sample && control && typeof sample.stack === 'string') {
      // This extracts the first frame from the sample that isn't also in the control.
      // Skipping one frame that we assume is the frame that calls the two.
      var sampleLines = sample.stack.split('\n');
      var controlLines = control.stack.split('\n');
      var s = sampleLines.length - 1;
      var c = controlLines.length - 1;

      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
        // We expect at least one stack frame to be shared.
        // Typically this will be the root most one. However, stack frames may be
        // cut off due to maximum stack limits. In this case, one maybe cut off
        // earlier than the other. We assume that the sample is longer or the same
        // and there for cut off earlier. So we should find the root most frame in
        // the sample somewhere in the control.
        c--;
      }

      for (; s >= 1 && c >= 0; s--, c--) {
        // Next we find the first one that isn't the same which should be the
        // frame that called our sample function and the control.
        if (sampleLines[s] !== controlLines[c]) {
          // In V8, the first line is describing the message but other VMs don't.
          // If we're about to return the first line, and the control is also on the same
          // line, that's a pretty good indicator that our sample threw at same line as
          // the control. I.e. before we entered the sample frame. So we ignore this result.
          // This can happen if you passed a class to function component, or non-function.
          if (s !== 1 || c !== 1) {
            do {
              s--;
              c--; // We may still have similar intermediate frames from the construct call.
              // The next one that isn't the same should be our match though.

              if (c < 0 || sampleLines[s] !== controlLines[c]) {
                // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                var _frame = '\n' + sampleLines[s].replace(' at new ', ' at ');

                {
                  if (typeof fn === 'function') {
                    componentFrameCache.set(fn, _frame);
                  }
                } // Return the line we found.


                return _frame;
              }
            } while (s >= 1 && c >= 0);
          }

          break;
        }
      }
    }
  } finally {
    reentry = false;

    {
      ReactCurrentDispatcher$1.current = previousDispatcher;
      reenableLogs();
    }

    Error.prepareStackTrace = previousPrepareStackTrace;
  } // Fallback to just using the name if we couldn't make it throw.


  var name = fn ? fn.displayName || fn.name : '';
  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';

  {
    if (typeof fn === 'function') {
      componentFrameCache.set(fn, syntheticFrame);
    }
  }

  return syntheticFrame;
}
function describeFunctionComponentFrame(fn, source, ownerFn) {
  {
    return describeNativeComponentFrame(fn, false);
  }
}

function shouldConstruct(Component) {
  var prototype = Component.prototype;
  return !!(prototype && prototype.isReactComponent);
}

function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {

  if (type == null) {
    return '';
  }

  if (typeof type === 'function') {
    {
      return describeNativeComponentFrame(type, shouldConstruct(type));
    }
  }

  if (typeof type === 'string') {
    return describeBuiltInComponentFrame(type);
  }

  switch (type) {
    case exports.Suspense:
      return describeBuiltInComponentFrame('Suspense');

    case REACT_SUSPENSE_LIST_TYPE:
      return describeBuiltInComponentFrame('SuspenseList');
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_FORWARD_REF_TYPE:
        return describeFunctionComponentFrame(type.render);

      case REACT_MEMO_TYPE:
        // Memo may contain any component type so we recursively resolve it.
        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);

      case REACT_BLOCK_TYPE:
        return describeFunctionComponentFrame(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            // Lazy may contain any component type so we recursively resolve it.
            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
          } catch (x) {}
        }
    }
  }

  return '';
}

var loggedTypeFailures = {};
var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;

function setCurrentlyValidatingElement(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
    } else {
      ReactDebugCurrentFrame$1.setExtraStackFrame(null);
    }
  }
}

function checkPropTypes(typeSpecs, values, location, componentName, element) {
  {
    // $FlowFixMe This is okay but Flow doesn't know it.
    var has = Function.call.bind(Object.prototype.hasOwnProperty);

    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.

        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
            err.name = 'Invariant Violation';
            throw err;
          }

          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
        } catch (ex) {
          error$1 = ex;
        }

        if (error$1 && !(error$1 instanceof Error)) {
          setCurrentlyValidatingElement(element);

          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);

          setCurrentlyValidatingElement(null);
        }

        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error$1.message] = true;
          setCurrentlyValidatingElement(element);

          error('Failed %s type: %s', location, error$1.message);

          setCurrentlyValidatingElement(null);
        }
      }
    }
  }
}

function setCurrentlyValidatingElement$1(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      setExtraStackFrame(stack);
    } else {
      setExtraStackFrame(null);
    }
  }
}

var propTypesMisspellWarningShown;

{
  propTypesMisspellWarningShown = false;
}

function getDeclarationErrorAddendum() {
  if (ReactCurrentOwner.current) {
    var name = getComponentName(ReactCurrentOwner.current.type);

    if (name) {
      return '\n\nCheck the render method of `' + name + '`.';
    }
  }

  return '';
}

function getSourceInfoErrorAddendum(source) {
  if (source !== undefined) {
    var fileName = source.fileName.replace(/^.*[\\\/]/, '');
    var lineNumber = source.lineNumber;
    return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
  }

  return '';
}

function getSourceInfoErrorAddendumForProps(elementProps) {
  if (elementProps !== null && elementProps !== undefined) {
    return getSourceInfoErrorAddendum(elementProps.__source);
  }

  return '';
}
/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */


var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  var info = getDeclarationErrorAddendum();

  if (!info) {
    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;

    if (parentName) {
      info = "\n\nCheck the top-level render call using <" + parentName + ">.";
    }
  }

  return info;
}
/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */


function validateExplicitKey(element, parentType) {
  if (!element._store || element._store.validated || element.key != null) {
    return;
  }

  element._store.validated = true;
  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);

  if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
    return;
  }

  ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
  // property, it may be the creator of the child that's responsible for
  // assigning it a key.

  var childOwner = '';

  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
    // Give the component that originally created this child.
    childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
  }

  {
    setCurrentlyValidatingElement$1(element);

    error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);

    setCurrentlyValidatingElement$1(null);
  }
}
/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */


function validateChildKeys(node, parentType) {
  if (typeof node !== 'object') {
    return;
  }

  if (Array.isArray(node)) {
    for (var i = 0; i < node.length; i++) {
      var child = node[i];

      if (isValidElement(child)) {
        validateExplicitKey(child, parentType);
      }
    }
  } else if (isValidElement(node)) {
    // This element was passed in a valid location.
    if (node._store) {
      node._store.validated = true;
    }
  } else if (node) {
    var iteratorFn = getIteratorFn(node);

    if (typeof iteratorFn === 'function') {
      // Entry iterators used to provide implicit keys,
      // but now we print a separate warning for them later.
      if (iteratorFn !== node.entries) {
        var iterator = iteratorFn.call(node);
        var step;

        while (!(step = iterator.next()).done) {
          if (isValidElement(step.value)) {
            validateExplicitKey(step.value, parentType);
          }
        }
      }
    }
  }
}
/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */


function validatePropTypes(element) {
  {
    var type = element.type;

    if (type === null || type === undefined || typeof type === 'string') {
      return;
    }

    var propTypes;

    if (typeof type === 'function') {
      propTypes = type.propTypes;
    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
    // Inner props are checked in the reconciler.
    type.$$typeof === REACT_MEMO_TYPE)) {
      propTypes = type.propTypes;
    } else {
      return;
    }

    if (propTypes) {
      // Intentionally inside to avoid triggering lazy initializers:
      var name = getComponentName(type);
      checkPropTypes(propTypes, element.props, 'prop', name, element);
    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:

      var _name = getComponentName(type);

      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
    }

    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
    }
  }
}
/**
 * Given a fragment, validate that it can only be provided with fragment props
 * @param {ReactElement} fragment
 */


function validateFragmentProps(fragment) {
  {
    var keys = Object.keys(fragment.props);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];

      if (key !== 'children' && key !== 'key') {
        setCurrentlyValidatingElement$1(fragment);

        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);

        setCurrentlyValidatingElement$1(null);
        break;
      }
    }

    if (fragment.ref !== null) {
      setCurrentlyValidatingElement$1(fragment);

      error('Invalid attribute `ref` supplied to `React.Fragment`.');

      setCurrentlyValidatingElement$1(null);
    }
  }
}
function createElementWithValidation(type, props, children) {
  var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
  // succeed and there will likely be errors in render.

  if (!validType) {
    var info = '';

    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
      info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
    }

    var sourceInfo = getSourceInfoErrorAddendumForProps(props);

    if (sourceInfo) {
      info += sourceInfo;
    } else {
      info += getDeclarationErrorAddendum();
    }

    var typeString;

    if (type === null) {
      typeString = 'null';
    } else if (Array.isArray(type)) {
      typeString = 'array';
    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
      typeString = "<" + (getComponentName(type.type) || 'Unknown') + " />";
      info = ' Did you accidentally export a JSX literal instead of a component?';
    } else {
      typeString = typeof type;
    }

    {
      error('React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
    }
  }

  var element = createElement.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.
  // TODO: Drop this when these are no longer allowed as the type argument.

  if (element == null) {
    return element;
  } // Skip key warning if the type isn't valid since our key validation logic
  // doesn't expect a non-string/function type and can throw confusing errors.
  // We don't want exception behavior to differ between dev and prod.
  // (Rendering will throw with a helpful message and as soon as the type is
  // fixed, the key warnings will appear.)


  if (validType) {
    for (var i = 2; i < arguments.length; i++) {
      validateChildKeys(arguments[i], type);
    }
  }

  if (type === exports.Fragment) {
    validateFragmentProps(element);
  } else {
    validatePropTypes(element);
  }

  return element;
}
var didWarnAboutDeprecatedCreateFactory = false;
function createFactoryWithValidation(type) {
  var validatedFactory = createElementWithValidation.bind(null, type);
  validatedFactory.type = type;

  {
    if (!didWarnAboutDeprecatedCreateFactory) {
      didWarnAboutDeprecatedCreateFactory = true;

      warn('React.createFactory() is deprecated and will be removed in ' + 'a future major release. Consider using JSX ' + 'or use React.createElement() directly instead.');
    } // Legacy hook: remove it


    Object.defineProperty(validatedFactory, 'type', {
      enumerable: false,
      get: function () {
        warn('Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');

        Object.defineProperty(this, 'type', {
          value: type
        });
        return type;
      }
    });
  }

  return validatedFactory;
}
function cloneElementWithValidation(element, props, children) {
  var newElement = cloneElement.apply(this, arguments);

  for (var i = 2; i < arguments.length; i++) {
    validateChildKeys(arguments[i], newElement.type);
  }

  validatePropTypes(newElement);
  return newElement;
}

{

  try {
    var frozenObject = Object.freeze({});
    /* eslint-disable no-new */

    new Map([[frozenObject, null]]);
    new Set([frozenObject]);
    /* eslint-enable no-new */
  } catch (e) {
  }
}

var createElement$1 =  createElementWithValidation ;
var cloneElement$1 =  cloneElementWithValidation ;
var createFactory =  createFactoryWithValidation ;
var Children = {
  map: mapChildren,
  forEach: forEachChildren,
  count: countChildren,
  toArray: toArray,
  only: onlyChild
};

exports.Children = Children;
exports.Component = Component;
exports.PureComponent = PureComponent;
exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
exports.cloneElement = cloneElement$1;
exports.createContext = createContext;
exports.createElement = createElement$1;
exports.createFactory = createFactory;
exports.createRef = createRef;
exports.forwardRef = forwardRef;
exports.isValidElement = isValidElement;
exports.lazy = lazy;
exports.memo = memo;
exports.useCallback = useCallback;
exports.useContext = useContext;
exports.useDebugValue = useDebugValue;
exports.useEffect = useEffect;
exports.useImperativeHandle = useImperativeHandle;
exports.useLayoutEffect = useLayoutEffect;
exports.useMemo = useMemo;
exports.useReducer = useReducer;
exports.useRef = useRef;
exports.useState = useState;
exports.version = ReactVersion;
  })();
}


/***/ }),

/***/ "./node_modules/react/index.js":
/*!*************************************!*\
  !*** ./node_modules/react/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react.development.js */ "./node_modules/react/cjs/react.development.js");
}


/***/ }),

/***/ "./node_modules/react/jsx-dev-runtime.js":
/*!***********************************************!*\
  !*** ./node_modules/react/jsx-dev-runtime.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ "./node_modules/react/cjs/react-jsx-dev-runtime.development.js");
}


/***/ }),

/***/ "./pages/FilmGrainFilter.js":
/*!**********************************!*\
  !*** ./pages/FilmGrainFilter.js ***!
  \**********************************/
/*! exports provided: __N_SSG, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__N_SSG", function() { return __N_SSG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Home; });
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/head */ "./node_modules/next/head.js");
/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_head__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _components_Template_Header_Header__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @components/Template/Header/Header */ "./components/Template/Header/Header.js");
/* harmony import */ var _components_Template_Container_Container__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @components/Template/Container/Container */ "./components/Template/Container/Container.js");
/* harmony import */ var _components_Template_Sandbox_Sandbox__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @components/Template/Sandbox/Sandbox */ "./components/Template/Sandbox/Sandbox.js");
/* harmony import */ var _components_Template_ComponentMeta_ComponentMeta__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @components/Template/ComponentMeta/ComponentMeta */ "./components/Template/ComponentMeta/ComponentMeta.js");
/* harmony import */ var _components_Template_Footer_Footer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @components/Template/Footer/Footer */ "./components/Template/Footer/Footer.js");
/* harmony import */ var _components_FilmGrainFilter_FilmGrainFilter__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @components/FilmGrainFilter/FilmGrainFilter */ "./components/FilmGrainFilter/FilmGrainFilter.js");


var _jsxFileName = "D:\\Dev\\Personal Sites\\Necro Cult Zine React\\Git Folder 1\\necrocult-nextjs\\pages\\FilmGrainFilter.js";
//IMPORTS
//import Head from '@components/Head/Head'






 //VARS

var __N_SSG = true;
function Home(props) {
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["Fragment"], {
    children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(next_head__WEBPACK_IMPORTED_MODULE_1___default.a, {
      children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("title", {
        children: "Necro Cult Zine Component"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 47,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 46,
      columnNumber: 7
    }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_components_FilmGrainFilter_FilmGrainFilter__WEBPACK_IMPORTED_MODULE_7__["default"], {}, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 50,
      columnNumber: 7
    }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("main", {
      children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_components_Template_Header_Header__WEBPACK_IMPORTED_MODULE_2__["default"], {
        title: "Necro Cult Zine Component Demo"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 53,
        columnNumber: 9
      }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_components_Template_Container_Container__WEBPACK_IMPORTED_MODULE_3__["default"], {
        children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_components_Template_ComponentMeta_ComponentMeta__WEBPACK_IMPORTED_MODULE_5__["default"], {
          title: props.title,
          author: props.author,
          authorTeam: props.authorTeam,
          description: props.description,
          contentProps: props.contentProps,
          libraries: props.libraries
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 55,
          columnNumber: 11
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 54,
        columnNumber: 9
      }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_components_Template_Sandbox_Sandbox__WEBPACK_IMPORTED_MODULE_4__["default"], {
        children: ["This component should be a top-level element.", /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("br", {}, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 67,
          columnNumber: 10
        }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("br", {}, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 67,
          columnNumber: 15
        }, this), "It should sit outside of any primary content."]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 65,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 52,
      columnNumber: 7
    }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_components_Template_Footer_Footer__WEBPACK_IMPORTED_MODULE_6__["default"], {
      footerMessage: props.footerMessage
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 73,
      columnNumber: 7
    }, this)]
  }, void 0, true);
}
_c = Home;

var _c;

$RefreshReg$(_c, "Home");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module)))

/***/ })

},[["./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2FFilmGrainFilter&absolutePagePath=D%3A%5CDev%5CPersonal%20Sites%5CNecro%20Cult%20Zine%20React%5CGit%20Folder%201%5Cnecrocult-nextjs%5Cpages%5CFilmGrainFilter.js!./","webpack"]]]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9GaWxtR3JhaW5GaWx0ZXIvRmlsbUdyYWluRmlsdGVyLmpzIiwid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL0ZpbG1HcmFpbkZpbHRlci9GaWxtR3JhaW5GaWx0ZXIubW9kdWxlLnNjc3M/N2VlYyIsIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9MYXlvdXQvTWFzdGVyQ1NTL01hc3RlckNTUy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9MYXlvdXQvTWFzdGVySlMvTWFzdGVySlMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvVGVtcGxhdGUvQ29tcG9uZW50TWV0YS9Db21wb25lbnRNZXRhLmpzIiwid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL1RlbXBsYXRlL0NvbXBvbmVudE1ldGEvQ29tcG9uZW50TWV0YS5tb2R1bGUuc2Nzcz9mMDBkIiwid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL1RlbXBsYXRlL0NvbnRhaW5lci9Db250YWluZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvVGVtcGxhdGUvQ29udGFpbmVyL0NvbnRhaW5lci5tb2R1bGUuc2Nzcz8yOWE4Iiwid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL1RlbXBsYXRlL0Zvb3Rlci9Gb290ZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvVGVtcGxhdGUvRm9vdGVyL0Zvb3Rlci5tb2R1bGUuc2Nzcz81YmVkIiwid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL1RlbXBsYXRlL0hlYWRlci9IZWFkZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvVGVtcGxhdGUvSGVhZGVyL0hlYWRlci5tb2R1bGUuc2Nzcz84OWE2Iiwid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL1RlbXBsYXRlL1NhbmRib3gvU2FuZGJveC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9UZW1wbGF0ZS9TYW5kYm94L1NhbmRib3gubW9kdWxlLnNjc3M/ZjYwNCIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXJyYXlMaWtlVG9BcnJheS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXJyYXlXaXRoSG9sZXMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FycmF5V2l0aG91dEhvbGVzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3REZXN0cnVjdHVyaW5nRW1wdHkuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2V4dGVuZHMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0cy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pdGVyYWJsZVRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2l0ZXJhYmxlVG9BcnJheUxpbWl0LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9ub25JdGVyYWJsZVJlc3QuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL25vbkl0ZXJhYmxlU3ByZWFkLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zZXRQcm90b3R5cGVPZi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvc2xpY2VkVG9BcnJheS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdG9Db25zdW1hYmxlQXJyYXkuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL29iamVjdC1hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtY2xpZW50LXBhZ2VzLWxvYWRlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1zdHlsZS1sb2FkZXIvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9jbGllbnQvaW1hZ2UudHN4Iiwid2VicGFjazovL19OX0UvLi4vLi4vY2xpZW50L3JlcXVlc3QtaWRsZS1jYWxsYmFjay50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uL2NsaWVudC91c2UtaW50ZXJzZWN0aW9uLnRzeCIsIndlYnBhY2s6Ly9fTl9FLyh3ZWJwYWNrKS9jc3MtbG9hZGVyL2FwaS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9GaWxtR3JhaW5GaWx0ZXIvRmlsbUdyYWluRmlsdGVyLm1vZHVsZS5zY3NzIiwid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL1RlbXBsYXRlL0NvbXBvbmVudE1ldGEvQ29tcG9uZW50TWV0YS5tb2R1bGUuc2NzcyIsIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9UZW1wbGF0ZS9Db250YWluZXIvQ29udGFpbmVyLm1vZHVsZS5zY3NzIiwid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL1RlbXBsYXRlL0Zvb3Rlci9Gb290ZXIubW9kdWxlLnNjc3MiLCJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvVGVtcGxhdGUvSGVhZGVyL0hlYWRlci5tb2R1bGUuc2NzcyIsIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9UZW1wbGF0ZS9TYW5kYm94L1NhbmRib3gubW9kdWxlLnNjc3MiLCJ3ZWJwYWNrOi8vX05fRS8od2VicGFjaykvd2VicGFjay9oYXJtb255LW1vZHVsZS5qcyIsIndlYnBhY2s6Ly9fTl9FLyh3ZWJwYWNrKS93ZWJwYWNrL21vZHVsZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9hbXAtY29udGV4dC50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9hbXAudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvaGVhZC1tYW5hZ2VyLWNvbnRleHQudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvaGVhZC50c3giLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvc2lkZS1lZmZlY3QudHN4Iiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3RvLWJhc2UtNjQudHMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvbmV4dC1zZXJ2ZXIvc2VydmVyL2ltYWdlLWNvbmZpZy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvaGVhZC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvaW1hZ2UuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LmRldmVsb3BtZW50LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL3BhZ2VzL0ZpbG1HcmFpbkZpbHRlci5qcyJdLCJuYW1lcyI6WyJGaWxtR3JhaW5GaWx0ZXIiLCJzdHlsZXMiLCJmaWxtR3JhaW5GaWx0ZXIiLCJNYXN0ZXJDU1MiLCJNYXN0ZXJKUyIsIkNvbXBvbmVudE1ldGEiLCJ0aXRsZSIsImF1dGhvciIsImF1dGhvclRlYW0iLCJkZXNjcmlwdGlvbiIsImNvbnRlbnRQcm9wcyIsImxpYnJhcmllcyIsImRlc2NyaXB0aW9uV3JhcHBlciIsInJvdyIsImNlbGwiLCJpbm5lciIsInByb3BzIiwiQ29udGFpbmVyIiwiY2hpbGRyZW4iLCJjb250YWluZXJTaXplIiwiZmxleCIsImNvbnRhaW5lciIsIkZvb3RlciIsImZvb3Rlck1lc3NhZ2UiLCJmb290ZXIiLCJmb290ZXJfbWVzc2FnZSIsIkhlYWRlciIsImhlYWRlciIsImNvbnRlbnRMZWZ0IiwiY29udGVudFJpZ2h0IiwiU2FuZGJveCIsInNhbmRib3giLCJjb250ZW50IiwiVkFMSURfTE9BRElOR19WQUxVRVMiLCJsb2FkZXJzIiwiVkFMSURfTEFZT1VUX1ZBTFVFUyIsInByb2Nlc3MiLCJpbWFnZUNvbmZpZ0RlZmF1bHQiLCJkZXZpY2VTaXplcyIsImltYWdlU2l6ZXMiLCJsb2FkZXIiLCJwYXRoIiwiZG9tYWlucyIsImFsbFNpemVzIiwiY29uZmlnRGV2aWNlU2l6ZXMiLCJhIiwic2l6ZXMiLCJsYXlvdXQiLCJwZXJjZW50U2l6ZXMiLCJtIiwicGFyc2VJbnQiLCJzbWFsbGVzdFJhdGlvIiwiTWF0aCIsIndpZHRocyIsInMiLCJraW5kIiwid2lkdGgiLCJ3IiwicCIsInNyYyIsInNyY1NldCIsImdldFdpZHRocyIsImxhc3QiLCJxdWFsaXR5IiwiaSIsImxvYWQiLCJyb290IiwiVkFMSURfTE9BREVSUyIsInVub3B0aW1pemVkIiwicHJpb3JpdHkiLCJhbGwiLCJyZXN0IiwidW5zaXplZCIsIkJvb2xlYW4iLCJKU09OIiwiaGVpZ2h0IiwibG9hZGluZyIsImlzTGF6eSIsInJvb3RNYXJnaW4iLCJkaXNhYmxlZCIsImlzVmlzaWJsZSIsIndpZHRoSW50IiwiZ2V0SW50IiwiaGVpZ2h0SW50IiwicXVhbGl0eUludCIsImltZ1N0eWxlIiwidmlzaWJpbGl0eSIsInBvc2l0aW9uIiwidG9wIiwibGVmdCIsImJvdHRvbSIsInJpZ2h0IiwiYm94U2l6aW5nIiwicGFkZGluZyIsImJvcmRlciIsIm1hcmdpbiIsImRpc3BsYXkiLCJtaW5XaWR0aCIsIm1heFdpZHRoIiwibWluSGVpZ2h0IiwibWF4SGVpZ2h0Iiwib2JqZWN0Rml0Iiwib2JqZWN0UG9zaXRpb24iLCJxdW90aWVudCIsInBhZGRpbmdUb3AiLCJpc05hTiIsIndyYXBwZXJTdHlsZSIsIm92ZXJmbG93Iiwic2l6ZXJTdHlsZSIsInNpemVyU3ZnIiwiaW1nQXR0cmlidXRlcyIsImdlbmVyYXRlSW1nQXR0cnMiLCJwYXJhbXMiLCJwYXJhbXNTdHJpbmciLCJub3JtYWxpemVTcmMiLCJtaXNzaW5nVmFsdWVzIiwicGFyc2VkU3JjIiwiY29uc29sZSIsImNvbmZpZ0RvbWFpbnMiLCJlbmNvZGVVUklDb21wb25lbnQiLCJyZXF1ZXN0SWRsZUNhbGxiYWNrIiwic2VsZiIsInN0YXJ0IiwiRGF0ZSIsInNldFRpbWVvdXQiLCJjYiIsImRpZFRpbWVvdXQiLCJ0aW1lUmVtYWluaW5nIiwiY2FuY2VsSWRsZUNhbGxiYWNrIiwiY2xlYXJUaW1lb3V0IiwiaGFzSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJpc0Rpc2FibGVkIiwidW5vYnNlcnZlIiwic2V0UmVmIiwiZWwiLCJvYnNlcnZlIiwic2V0VmlzaWJsZSIsImlkbGVDYWxsYmFjayIsImNyZWF0ZU9ic2VydmVyIiwiZWxlbWVudHMiLCJvYnNlcnZlciIsIm9ic2VydmVycyIsImlkIiwib3B0aW9ucyIsImluc3RhbmNlIiwiZW50cmllcyIsImVudHJ5IiwiY2FsbGJhY2siLCJBbXBTdGF0ZUNvbnRleHQiLCJSZWFjdCIsImFtcEZpcnN0IiwiaHlicmlkIiwiaGFzUXVlcnkiLCJpc0luQW1wTW9kZSIsIkhlYWRNYW5hZ2VyQ29udGV4dCIsImluQW1wTW9kZSIsImhlYWQiLCJjaGlsZCIsImxpc3QiLCJmcmFnbWVudExpc3QiLCJNRVRBVFlQRVMiLCJrZXlzIiwidGFncyIsIm1ldGFUeXBlcyIsIm1ldGFDYXRlZ29yaWVzIiwiaCIsImlzVW5pcXVlIiwiaGFzS2V5Iiwia2V5IiwibGVuIiwibWV0YXR5cGUiLCJjYXRlZ29yeSIsImNhdGVnb3JpZXMiLCJoZWFkRWxlbWVudHMiLCJoZWFkRWxlbWVudENoaWxkcmVuIiwiaGVhZEVsZW1lbnQiLCJkZWZhdWx0SGVhZCIsInVuaXF1ZSIsImMiLCJhbXBTdGF0ZSIsImhlYWRNYW5hZ2VyIiwiSGVhZCIsImlzU2VydmVyIiwiY29uc3RydWN0b3IiLCJfaGFzSGVhZE1hbmFnZXIiLCJlbWl0Q2hhbmdlIiwiY29tcG9uZW50RGlkTW91bnQiLCJjb21wb25lbnREaWRVcGRhdGUiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsInJlbmRlciIsIkNvbXBvbmVudCIsIndpbmRvdyIsIkhvbWUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBRWUsU0FBU0EsZUFBVCxPQUVaO0FBQUE7O0FBQ0Qsc0JBQ0M7QUFBSyxhQUFTLEVBQUVDLG1FQUFNLENBQUNDO0FBQXZCO0FBQUE7QUFBQTtBQUFBO0FBQUEsVUFERDtBQUdEO0tBTnVCRixlOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNGeEIsVUFBVSxtQkFBTyxDQUFDLHNOQUEyRztBQUM3SCwwQkFBMEIsbUJBQU8sQ0FBQyxpbkJBQXdWOztBQUUxWDs7QUFFQTtBQUNBLDBCQUEwQixRQUFTO0FBQ25DOztBQUVBOztBQUVBLG1DQUFtQztBQUNuQztBQUNBLHNFQUFzRSx3Q0FBd0M7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsSUFBSSxJQUFVO0FBQ2Q7QUFDQSxrRUFBa0UsaUJBQWlCLGNBQWMsTUFBTSxZQUFZLGlDQUFpQztBQUNwSixVQUFVLGdCQUFnQixlQUFlLFlBQVksaUNB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RTs7QUFFUCxpREFBaUQ7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsU0FBUztBQUNULHdCQUF3QjtBQUN4QjtBQUNBLFNBQVM7QUFDVCx3QkFBd0I7QUFDeEI7QUFDQSxTQUFTO0FBQ1QseUJBQXlCO0FBQ3pCO0FBQ0EsU0FBUztBQUNULHlCQUF5QjtBQUN6QjtBQUNBLFNBQVM7QUFDVCxrQ0FBa0M7QUFDbEM7QUFDQSxTQUFTO0FBQ1QsNEJBQTRCO0FBQzVCO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMERBQTBEOztBQUUxRDtBQUNBOztBQUVBO0FBQ0Esd0RBQXdEO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7O0FBR2pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOzs7QUFHSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEhBQTBIO0FBQzFIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUVBQW1FOztBQUVuRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLFdBQVcsRUFBRTtBQUNiLFdBQVcsRUFBRTtBQUNiLFdBQVcsY0FBYztBQUN6QixXQUFXLEVBQUU7QUFDYixXQUFXLEVBQUU7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEVBQUU7O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssRUFBRTtBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsMkRBQTJELFNBQVM7QUFDcEUseUJBQXlCLFNBQVM7QUFDbEM7QUFDQSxhQUFhLFNBQVM7QUFDdEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLEVBQUU7QUFDYjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0REFBNEQ7QUFDNUQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxFQUFFO0FBQ2I7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1EQUFtRDs7QUFFbkQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsV0FBVyxFQUFFO0FBQ2IsV0FBVyxFQUFFO0FBQ2IsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsRUFBRTtBQUNiLFdBQVcsRUFBRTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2I7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssRUFBRTs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxFQUFFO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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QUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQSx5Q0FBeUM7QUFDekM7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEI7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsaUJBQWlCO0FBQ3BDOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxREFBcUQ7QUFDckQ7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsdUNBQXVDO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7Ozs7Ozs7Ozs7OztBQzV4RWE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDO0FBQ0QsbUJBQW1CLG1CQUFPLENBQUMsaUZBQTRCO0FBQ3ZEOzs7Ozs7Ozs7Ozs7O0FDTmE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDO0FBQ0QsbUJBQW1CLG1CQUFPLENBQUMsaUhBQTRDO0FBQ3ZFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Q0FJQTs7O0FBK0JlLFNBQVNDLElBQVQsQ0FBY2hMLEtBQWQsRUFBcUI7QUFDbEMsc0JBQ0U7QUFBQSw0QkFDRSxxRUFBQyxnREFBRDtBQUFBLDZCQUNFO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBREY7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQURGLGVBS0UscUVBQUMsbUZBQUQ7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUxGLGVBT0U7QUFBQSw4QkFDRSxxRUFBQywwRUFBRDtBQUFRLGFBQUssRUFBQztBQUFkO0FBQUE7QUFBQTtBQUFBO0FBQUEsY0FERixlQUVFLHFFQUFDLGdGQUFEO0FBQUEsK0JBQ0UscUVBQUMsd0ZBQUQ7QUFDRSxlQUFLLEVBQUVBLEtBQUssQ0FBQ1YsS0FEZjtBQUVFLGdCQUFNLEVBQUVVLEtBQUssQ0FBQ1QsTUFGaEI7QUFHRSxvQkFBVSxFQUFFUyxLQUFLLENBQUNSLFVBSHBCO0FBSUUscUJBQVcsRUFBRVEsS0FBSyxDQUFDUCxXQUpyQjtBQUtFLHNCQUFZLEVBQUVPLEtBQUssQ0FBQ04sWUFMdEI7QUFNRSxtQkFBUyxFQUFFTSxLQUFLLENBQUNMO0FBTm5CO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFERjtBQUFBO0FBQUE7QUFBQTtBQUFBLGNBRkYsZUFhRSxxRUFBQyw0RUFBRDtBQUFBLGlGQUVDO0FBQUE7QUFBQTtBQUFBO0FBQUEsZ0JBRkQsZUFFTTtBQUFBO0FBQUE7QUFBQTtBQUFBLGdCQUZOO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxjQWJGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQVBGLGVBNEJFLHFFQUFDLDBFQUFEO0FBQVEsbUJBQWEsRUFBRUssS0FBSyxDQUFDTztBQUE3QjtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBNUJGO0FBQUEsa0JBREY7QUFnQ0Q7S0FqQ3VCeUssSSIsImZpbGUiOiJzdGF0aWMvY2h1bmtzL3BhZ2VzL0ZpbG1HcmFpbkZpbHRlci5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBzdHlsZXMgZnJvbSAnLi9GaWxtR3JhaW5GaWx0ZXIubW9kdWxlLnNjc3MnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBGaWxtR3JhaW5GaWx0ZXIoeyBcclxuICAvL3BhZ2UgdmFyc1xyXG59KSB7XHJcbiAgcmV0dXJuIChcclxuICBcdDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuZmlsbUdyYWluRmlsdGVyfSA+PC9kaXY+XHJcbiAgKVxyXG59XHJcbiIsInZhciBhcGkgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtc3R5bGUtbG9hZGVyL3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMy0xIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMy0yIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVzb2x2ZS11cmwtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTUtb25lT2YtMy0zIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvc2Fzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMy00IS4vRmlsbUdyYWluRmlsdGVyLm1vZHVsZS5zY3NzXCIpO1xuXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICB9XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gZnVuY3Rpb24oZWxlbWVudCl7Ly8gVGhlc2UgZWxlbWVudHMgc2hvdWxkIGFsd2F5cyBleGlzdC4gSWYgdGhleSBkbyBub3QsXG4vLyB0aGlzIGNvZGUgc2hvdWxkIGZhaWwuXG52YXIgYW5jaG9yRWxlbWVudD1kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjX19uZXh0X2Nzc19fRE9fTk9UX1VTRV9fJyk7dmFyIHBhcmVudE5vZGU9YW5jaG9yRWxlbWVudC5wYXJlbnROb2RlOy8vIE5vcm1hbGx5IDxoZWFkPlxuLy8gRWFjaCBzdHlsZSB0YWcgc2hvdWxkIGJlIHBsYWNlZCByaWdodCBiZWZvcmUgb3VyXG4vLyBhbmNob3IuIEJ5IGluc2VydGluZyBiZWZvcmUgYW5kIG5vdCBhZnRlciwgd2UgZG8gbm90XG4vLyBuZWVkIHRvIHRyYWNrIHRoZSBsYXN0IGluc2VydGVkIGVsZW1lbnQuXG5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtZW50LGFuY2hvckVsZW1lbnQpO307XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cbmlmIChtb2R1bGUuaG90KSB7XG4gIGlmICghY29udGVudC5sb2NhbHMgfHwgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKSB7XG4gICAgdmFyIGlzRXF1YWxMb2NhbHMgPSBmdW5jdGlvbiBpc0VxdWFsTG9jYWxzKGEsYixpc05hbWVkRXhwb3J0KXtpZighYSYmYnx8YSYmIWIpe3JldHVybiBmYWxzZTt9bGV0IHA7Zm9yKHAgaW4gYSl7aWYoaXNOYW1lZEV4cG9ydCYmcD09PSdkZWZhdWx0Jyl7Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG5jb250aW51ZTt9aWYoYVtwXSE9PWJbcF0pe3JldHVybiBmYWxzZTt9fWZvcihwIGluIGIpe2lmKGlzTmFtZWRFeHBvcnQmJnA9PT0nZGVmYXVsdCcpey8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250aW51ZVxuY29udGludWU7fWlmKCFhW3BdKXtyZXR1cm4gZmFsc2U7fX1yZXR1cm4gdHJ1ZTt9O1xuICAgIHZhciBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFxuICAgICAgXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0zLTEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wb3N0Y3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0zLTIhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZXNvbHZlLXVybC1sb2FkZXIvaW5kZXguanM/P3JlZi0tNS1vbmVPZi0zLTMhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9zYXNzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0zLTQhLi9GaWxtR3JhaW5GaWx0ZXIubW9kdWxlLnNjc3NcIixcbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0zLTEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wb3N0Y3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0zLTIhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZXNvbHZlLXVybC1sb2FkZXIvaW5kZXguanM/P3JlZi0tNS1vbmVPZi0zLTMhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9zYXNzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0zLTQhLi9GaWxtR3JhaW5GaWx0ZXIubW9kdWxlLnNjc3NcIik7XG5cbiAgICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghaXNFcXVhbExvY2FscyhvbGRMb2NhbHMsIGNvbnRlbnQubG9jYWxzKSkge1xuICAgICAgICAgICAgICAgIG1vZHVsZS5ob3QuaW52YWxpZGF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICAgICAgICAgICAgdXBkYXRlKGNvbnRlbnQpO1xuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHtcbiAgICB1cGRhdGUoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHMgfHwge307IiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5cclxuTWFzdGVyQ1NTIFx0XHJcblx0XHJcblx0LVx0TGluayBhbGwgSlMgZmlsZXMgaW4gZGVzaXJlZCBvcmRlciwgXHJcblx0XHR0aGVuIGFkZCB0aGlzIGNvbXBvbmVudCB0byB0aGUgZW5kIG9mIFxyXG5cdFx0eW91ciBnbG9iYWwgbGF5b3V0LCBzbyBhbGwgSlMgaXMgbG9hZGVkIGxhc3QuXHJcblxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBNYXN0ZXJDU1MoeyBcclxuICAvL3BhZ2UgdmFyc1xyXG59KSB7XHJcbiAgcmV0dXJuIChcclxuICBcdDw+XHJcbiAgXHRcdDxsaW5rIHJlbD1cInN0eWxlc2hlZXRcIiBocmVmPVwiaHR0cHM6Ly9jZG5qcy5jbG91ZGZsYXJlLmNvbS9hamF4L2xpYnMvZm9udC1hd2Vzb21lLzUuMTUuMy9jc3MvYWxsLm1pbi5jc3NcIiBpbnRlZ3JpdHk9XCJzaGE1MTItaUJCWG04Zlc5MCtudUxjU0tsYm1yUGNMYTBPVDkyeE8xQklzWit5d0RXWkN2cXNXZ2NjVjNnRm9SQnYweis4ZExKZ3lBSEloUjM1VlpjMm9NL2dJMXc9PVwiIGNyb3NzT3JpZ2luPVwiYW5vbnltb3VzXCIgLz5cclxuICBcdDwvPlxyXG4gIClcclxufVxyXG4iLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcblxyXG5NYXN0ZXJKUyBcdFxyXG5cdFxyXG5cdC1cdExpbmsgYWxsIEpTIGZpbGVzIGluIGRlc2lyZWQgb3JkZXIsIFxyXG5cdFx0dGhlbiBhZGQgdGhpcyBjb21wb25lbnQgdG8gdGhlIGVuZCBvZiBcclxuXHRcdHlvdXIgZ2xvYmFsIGxheW91dCwgc28gYWxsIEpTIGlzIGxvYWRlZCBsYXN0LlxyXG5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTWFzdGVySlMoeyBcclxuICAvL3BhZ2UgdmFyc1xyXG59KSB7XHJcbiAgcmV0dXJuIChcclxuICBcdDw+XHJcbiAgXHRcdDxzY3JpcHQgc3JjPVwiaHR0cHM6Ly9jZG5qcy5jbG91ZGZsYXJlLmNvbS9hamF4L2xpYnMvanF1ZXJ5LzMuNi4wL2pxdWVyeS5taW4uanNcIiBpbnRlZ3JpdHk9XCJzaGE1MTItODk0WUU2UVdENUk1OUhnWk9HUmVGWW00ZG5XYzFRdDVOdHZZU2FOY09QK3UxVDlxWWR2ZGloejBQUFNpaXFuLysvM2U3Sm80RWFHN1R1YmZXR1VyTVE9PVwiIGNyb3NzT3JpZ2luPVwiYW5vbnltb3VzXCI+PC9zY3JpcHQ+XHJcblxyXG4gIFx0XHQ8c2NyaXB0IHNyYz1cImh0dHBzOi8vY2RuanMuY2xvdWRmbGFyZS5jb20vYWpheC9saWJzL2hlYWRyb29tLzAuMTIuMC9oZWFkcm9vbS5taW4uanNcIiBpbnRlZ3JpdHk9XCJzaGE1MTItOVVzcktUWXpTOXNtRG0yRTU4TUxzMEFDdE9raStVQzRiQnE0aUs1d2k3bEp5Y3dxY2FpSHhyMWJkRXNJVm9LMGw1U1RFekxVZFl5RGRGUTVPRWpjenc9PVwiIGNyb3NzT3JpZ2luPVwiYW5vbnltb3VzXCI+PC9zY3JpcHQ+XHJcbiAgXHRcdDxzY3JpcHQgc3JjPVwiaHR0cHM6Ly9jZG5qcy5jbG91ZGZsYXJlLmNvbS9hamF4L2xpYnMvaGVhZHJvb20vMC4xMi4wL2pRdWVyeS5oZWFkcm9vbS5taW4uanNcIiBpbnRlZ3JpdHk9XCJzaGE1MTItM3p4TkltRWhRMnBuT1NIZHlHQ0NKaHBNclUzNWo3VWdubHljVS9zTG5ic2RtY0grcFhtOWJSOWh0dTZwNmdncXg2YjVWRUtlaW5haktEcFVXN0x1VFE9PVwiIGNyb3NzT3JpZ2luPVwiYW5vbnltb3VzXCI+PC9zY3JpcHQ+XHJcblxyXG4gIFx0XHQ8c2NyaXB0IHNyYz1cImh0dHBzOi8vY2RuanMuY2xvdWRmbGFyZS5jb20vYWpheC9saWJzL2ZvbnQtYXdlc29tZS81LjE1LjMvanMvc29saWQubWluLmpzXCIgaW50ZWdyaXR5PVwic2hhNTEyLVFjK2NCTXQvNC9LWEoxRjZuTlFhaFhJc2dQeWdITTRTMlhXQ2hvdW1WOHFrcFo5b08rZ0JEQkVwT3hnYmtRUS82RGxIeDZjVXhhNW5CaEVidWlSOHh3PT1cIiBjcm9zc09yaWdpbj1cImFub255bW91c1wiPjwvc2NyaXB0PlxyXG5cclxuICBcdFx0PHNjcmlwdCBzcmM9XCIvc2NyaXB0cy9tYWluLmpzXCI+PC9zY3JpcHQ+XHJcbiAgXHQ8Lz5cclxuICApXHJcbn1cclxuIiwiaW1wb3J0IHN0eWxlcyBmcm9tICcuL0NvbXBvbmVudE1ldGEubW9kdWxlLnNjc3MnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDb21wb25lbnRNZXRhKHsgXHJcbiAgdGl0bGUsXHJcbiAgYXV0aG9yLFxyXG4gIGF1dGhvclRlYW0sXHJcbiAgZGVzY3JpcHRpb24sXHJcbiAgY29udGVudFByb3BzLFxyXG4gIGxpYnJhcmllcyxcclxufSkge1xyXG4gIHJldHVybiAoXHJcbiAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5kZXNjcmlwdGlvbldyYXBwZXJ9PlxyXG4gIFx0XHJcblxyXG5cdDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMucm93fT5cclxuXHRcdDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuY2VsbCArJyAnKyBzdHlsZXMudGl0bGV9PlxyXG5cdFx0XHQ8dWwgY2xhc3NOYW1lPXtzdHlsZXMuaW5uZXJ9PlxyXG5cdFx0XHRcdDxsaSBjbGFzc05hbWU9e3N0eWxlcy50aXRsZX0+XHJcblx0XHRcdFx0XHQ8c3Bhbj5Db21wb25lbnQ6PC9zcGFuPiBcclxuXHRcdFx0XHRcdHt0aXRsZX1cclxuXHRcdFx0XHQ8L2xpPlxyXG5cdFx0XHRcdDxsaSBjbGFzc05hbWU9e3N0eWxlcy5hdXRob3J9PlxyXG5cdFx0XHRcdFx0PHNwYW4+RGV2ZWxvcGVyOjwvc3Bhbj4gXHJcblx0XHRcdFx0XHR7YXV0aG9yfTxici8+XHJcblx0XHRcdFx0XHR7YXV0aG9yVGVhbX1cclxuXHRcdFx0XHQ8L2xpPlxyXG5cdFx0XHQ8L3VsPlxyXG5cdFx0PC9kaXY+XHJcblx0XHJcblx0XHQ8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmNlbGwgKycgJysgc3R5bGVzLmRlc2NyaXB0aW9ufT5cclxuXHRcdFx0PHVsIGNsYXNzTmFtZT17c3R5bGVzLmlubmVyfT5cclxuXHRcdFx0XHQ8bGkgY2xhc3NOYW1lPXtzdHlsZXMuZGVzY3JpcHRpb259PlxyXG5cdFx0XHRcdFx0PHNwYW4+RGVzY3JpcHRpb246PC9zcGFuPiBcclxuXHRcdFx0XHRcdHtkZXNjcmlwdGlvbn1cclxuXHRcdFx0XHQ8L2xpPlxyXG5cdFx0XHQ8L3VsPlxyXG5cdFx0PC9kaXY+XHJcblx0PC9kaXY+XHJcblxyXG5cdDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMucm93fT5cclxuXHRcdDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuY2VsbCArJyAnKyBzdHlsZXMuY29udGVudFByb3BzfT5cclxuXHRcdFx0PHVsIGNsYXNzTmFtZT17c3R5bGVzLmlubmVyfT5cclxuXHRcdFx0XHQ8bGkgY2xhc3NOYW1lPXtzdHlsZXMucHJvcHN9PlxyXG5cdFx0XHRcdFx0PHNwYW4+QXZhaWxhYmxlIFByb3BzOjwvc3Bhbj4gXHJcblx0XHRcdFx0PC9saT5cclxuXHRcdFx0XHR7Y29udGVudFByb3BzfVxyXG5cdFx0XHQ8L3VsPlxyXG5cdFx0PC9kaXY+XHJcblx0XHJcblx0XHQ8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmNlbGwgKycgJysgc3R5bGVzLmxpYnJhcmllc30+XHJcblx0XHRcdDx1bCBjbGFzc05hbWU9e3N0eWxlcy5pbm5lcn0+XHJcblx0XHRcdFx0PGxpIGNsYXNzTmFtZT17c3R5bGVzLmxpYnJhcmllc30+XHJcblx0XHRcdFx0XHQ8c3Bhbj5MaWJyYXJpZXMgVXNlZDo8L3NwYW4+IFxyXG5cdFx0XHRcdDwvbGk+XHJcblx0XHRcdFx0e2xpYnJhcmllc31cclxuXHRcdFx0PC91bD5cclxuXHRcdDwvZGl2PlxyXG5cdDwvZGl2PlxyXG4gICAgXHJcbiAgICBcclxuICA8L2Rpdj5cclxuICApXHJcbn1cclxuIiwidmFyIGFwaSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1zdHlsZS1sb2FkZXIvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIik7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0zLTEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wb3N0Y3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0zLTIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZXNvbHZlLXVybC1sb2FkZXIvaW5kZXguanM/P3JlZi0tNS1vbmVPZi0zLTMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9zYXNzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0zLTQhLi9Db21wb25lbnRNZXRhLm1vZHVsZS5zY3NzXCIpO1xuXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICB9XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gZnVuY3Rpb24oZWxlbWVudCl7Ly8gVGhlc2UgZWxlbWVudHMgc2hvdWxkIGFsd2F5cyBleGlzdC4gSWYgdGhleSBkbyBub3QsXG4vLyB0aGlzIGNvZGUgc2hvdWxkIGZhaWwuXG52YXIgYW5jaG9yRWxlbWVudD1kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjX19uZXh0X2Nzc19fRE9fTk9UX1VTRV9fJyk7dmFyIHBhcmVudE5vZGU9YW5jaG9yRWxlbWVudC5wYXJlbnROb2RlOy8vIE5vcm1hbGx5IDxoZWFkPlxuLy8gRWFjaCBzdHlsZSB0YWcgc2hvdWxkIGJlIHBsYWNlZCByaWdodCBiZWZvcmUgb3VyXG4vLyBhbmNob3IuIEJ5IGluc2VydGluZyBiZWZvcmUgYW5kIG5vdCBhZnRlciwgd2UgZG8gbm90XG4vLyBuZWVkIHRvIHRyYWNrIHRoZSBsYXN0IGluc2VydGVkIGVsZW1lbnQuXG5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtZW50LGFuY2hvckVsZW1lbnQpO307XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cbmlmIChtb2R1bGUuaG90KSB7XG4gIGlmICghY29udGVudC5sb2NhbHMgfHwgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKSB7XG4gICAgdmFyIGlzRXF1YWxMb2NhbHMgPSBmdW5jdGlvbiBpc0VxdWFsTG9jYWxzKGEsYixpc05hbWVkRXhwb3J0KXtpZighYSYmYnx8YSYmIWIpe3JldHVybiBmYWxzZTt9bGV0IHA7Zm9yKHAgaW4gYSl7aWYoaXNOYW1lZEV4cG9ydCYmcD09PSdkZWZhdWx0Jyl7Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG5jb250aW51ZTt9aWYoYVtwXSE9PWJbcF0pe3JldHVybiBmYWxzZTt9fWZvcihwIGluIGIpe2lmKGlzTmFtZWRFeHBvcnQmJnA9PT0nZGVmYXVsdCcpey8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250aW51ZVxuY29udGludWU7fWlmKCFhW3BdKXtyZXR1cm4gZmFsc2U7fX1yZXR1cm4gdHJ1ZTt9O1xuICAgIHZhciBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFxuICAgICAgXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0zLTEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wb3N0Y3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0zLTIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZXNvbHZlLXVybC1sb2FkZXIvaW5kZXguanM/P3JlZi0tNS1vbmVPZi0zLTMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9zYXNzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0zLTQhLi9Db21wb25lbnRNZXRhLm1vZHVsZS5zY3NzXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMy0xIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMy0yIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVzb2x2ZS11cmwtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTUtb25lT2YtMy0zIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvc2Fzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMy00IS4vQ29tcG9uZW50TWV0YS5tb2R1bGUuc2Nzc1wiKTtcblxuICAgICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCFpc0VxdWFsTG9jYWxzKG9sZExvY2FscywgY29udGVudC5sb2NhbHMpKSB7XG4gICAgICAgICAgICAgICAgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgICAgICAgICAgICB1cGRhdGUoY29udGVudCk7XG4gICAgICB9XG4gICAgKVxuICB9XG5cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkge1xuICAgIHVwZGF0ZSgpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscyB8fCB7fTsiLCJpbXBvcnQgc3R5bGVzIGZyb20gJy4vQ29udGFpbmVyLm1vZHVsZS5zY3NzJ1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ29udGFpbmVyKHsgXHJcblx0Y2hpbGRyZW4sXHJcblx0Y29udGFpbmVyU2l6ZSwgXHJcblx0ZmxleCxcclxufSkge1xyXG4gIHJldHVybiAoXHJcbiAgICAgIDxkaXYgY2xhc3NOYW1lPXsgc3R5bGVzLmNvbnRhaW5lciArIChmbGV4ID8gJyAnK3N0eWxlcy5mbGV4OiAnJykgfT5cclxuICAgICAgICB7Y2hpbGRyZW59XHJcbiAgICAgIDwvZGl2PlxyXG4gIClcclxufVxyXG4iLCJ2YXIgYXBpID0gcmVxdWlyZShcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXN0eWxlLWxvYWRlci9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKTtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTMtMSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTMtMiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Jlc29sdmUtdXJsLWxvYWRlci9pbmRleC5qcz8/cmVmLS01LW9uZU9mLTMtMyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Nhc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTMtNCEuL0NvbnRhaW5lci5tb2R1bGUuc2Nzc1wiKTtcblxuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgfVxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLmluc2VydCA9IGZ1bmN0aW9uKGVsZW1lbnQpey8vIFRoZXNlIGVsZW1lbnRzIHNob3VsZCBhbHdheXMgZXhpc3QuIElmIHRoZXkgZG8gbm90LFxuLy8gdGhpcyBjb2RlIHNob3VsZCBmYWlsLlxudmFyIGFuY2hvckVsZW1lbnQ9ZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI19fbmV4dF9jc3NfX0RPX05PVF9VU0VfXycpO3ZhciBwYXJlbnROb2RlPWFuY2hvckVsZW1lbnQucGFyZW50Tm9kZTsvLyBOb3JtYWxseSA8aGVhZD5cbi8vIEVhY2ggc3R5bGUgdGFnIHNob3VsZCBiZSBwbGFjZWQgcmlnaHQgYmVmb3JlIG91clxuLy8gYW5jaG9yLiBCeSBpbnNlcnRpbmcgYmVmb3JlIGFuZCBub3QgYWZ0ZXIsIHdlIGRvIG5vdFxuLy8gbmVlZCB0byB0cmFjayB0aGUgbGFzdCBpbnNlcnRlZCBlbGVtZW50LlxucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWxlbWVudCxhbmNob3JFbGVtZW50KTt9O1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5pZiAobW9kdWxlLmhvdCkge1xuICBpZiAoIWNvbnRlbnQubG9jYWxzIHx8IG1vZHVsZS5ob3QuaW52YWxpZGF0ZSkge1xuICAgIHZhciBpc0VxdWFsTG9jYWxzID0gZnVuY3Rpb24gaXNFcXVhbExvY2FscyhhLGIsaXNOYW1lZEV4cG9ydCl7aWYoIWEmJmJ8fGEmJiFiKXtyZXR1cm4gZmFsc2U7fWxldCBwO2ZvcihwIGluIGEpe2lmKGlzTmFtZWRFeHBvcnQmJnA9PT0nZGVmYXVsdCcpey8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250aW51ZVxuY29udGludWU7fWlmKGFbcF0hPT1iW3BdKXtyZXR1cm4gZmFsc2U7fX1mb3IocCBpbiBiKXtpZihpc05hbWVkRXhwb3J0JiZwPT09J2RlZmF1bHQnKXsvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udGludWVcbmNvbnRpbnVlO31pZighYVtwXSl7cmV0dXJuIGZhbHNlO319cmV0dXJuIHRydWU7fTtcbiAgICB2YXIgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcbiAgICAgIFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMy0xIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMy0yIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVzb2x2ZS11cmwtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTUtb25lT2YtMy0zIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvc2Fzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMy00IS4vQ29udGFpbmVyLm1vZHVsZS5zY3NzXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMy0xIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMy0yIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVzb2x2ZS11cmwtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTUtb25lT2YtMy0zIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvc2Fzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMy00IS4vQ29udGFpbmVyLm1vZHVsZS5zY3NzXCIpO1xuXG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIWlzRXF1YWxMb2NhbHMob2xkTG9jYWxzLCBjb250ZW50LmxvY2FscykpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUuaG90LmludmFsaWRhdGUoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgICAgICAgICAgIHVwZGF0ZShjb250ZW50KTtcbiAgICAgIH1cbiAgICApXG4gIH1cblxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7XG4gICAgdXBkYXRlKCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzIHx8IHt9OyIsImltcG9ydCBzdHlsZXMgZnJvbSAnLi9Gb290ZXIubW9kdWxlLnNjc3MnXHJcbmltcG9ydCBNYXN0ZXJKUyBmcm9tICdAY29tcG9uZW50cy9MYXlvdXQvTWFzdGVySlMvTWFzdGVySlMnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBGb290ZXIoeyBmb290ZXJNZXNzYWdlIH0pIHtcclxuICByZXR1cm4gKFxyXG4gICAgPD5cclxuICAgICAgPGZvb3RlciBjbGFzc05hbWU9e3N0eWxlcy5mb290ZXJ9PlxyXG4gICAgICAgPHAgY2xhc3NOYW1lPXtzdHlsZXMuZm9vdGVyX21lc3NhZ2V9Pntmb290ZXJNZXNzYWdlfTwvcD5cclxuICAgICAgPC9mb290ZXI+XHJcblxyXG4gICAgICA8TWFzdGVySlMvPlxyXG4gICAgPC8+XHJcbiAgKVxyXG59XHJcbiIsInZhciBhcGkgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtc3R5bGUtbG9hZGVyL3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMy0xIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMy0yIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVzb2x2ZS11cmwtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTUtb25lT2YtMy0zIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvc2Fzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMy00IS4vRm9vdGVyLm1vZHVsZS5zY3NzXCIpO1xuXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICB9XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gZnVuY3Rpb24oZWxlbWVudCl7Ly8gVGhlc2UgZWxlbWVudHMgc2hvdWxkIGFsd2F5cyBleGlzdC4gSWYgdGhleSBkbyBub3QsXG4vLyB0aGlzIGNvZGUgc2hvdWxkIGZhaWwuXG52YXIgYW5jaG9yRWxlbWVudD1kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjX19uZXh0X2Nzc19fRE9fTk9UX1VTRV9fJyk7dmFyIHBhcmVudE5vZGU9YW5jaG9yRWxlbWVudC5wYXJlbnROb2RlOy8vIE5vcm1hbGx5IDxoZWFkPlxuLy8gRWFjaCBzdHlsZSB0YWcgc2hvdWxkIGJlIHBsYWNlZCByaWdodCBiZWZvcmUgb3VyXG4vLyBhbmNob3IuIEJ5IGluc2VydGluZyBiZWZvcmUgYW5kIG5vdCBhZnRlciwgd2UgZG8gbm90XG4vLyBuZWVkIHRvIHRyYWNrIHRoZSBsYXN0IGluc2VydGVkIGVsZW1lbnQuXG5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtZW50LGFuY2hvckVsZW1lbnQpO307XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cbmlmIChtb2R1bGUuaG90KSB7XG4gIGlmICghY29udGVudC5sb2NhbHMgfHwgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKSB7XG4gICAgdmFyIGlzRXF1YWxMb2NhbHMgPSBmdW5jdGlvbiBpc0VxdWFsTG9jYWxzKGEsYixpc05hbWVkRXhwb3J0KXtpZighYSYmYnx8YSYmIWIpe3JldHVybiBmYWxzZTt9bGV0IHA7Zm9yKHAgaW4gYSl7aWYoaXNOYW1lZEV4cG9ydCYmcD09PSdkZWZhdWx0Jyl7Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG5jb250aW51ZTt9aWYoYVtwXSE9PWJbcF0pe3JldHVybiBmYWxzZTt9fWZvcihwIGluIGIpe2lmKGlzTmFtZWRFeHBvcnQmJnA9PT0nZGVmYXVsdCcpey8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250aW51ZVxuY29udGludWU7fWlmKCFhW3BdKXtyZXR1cm4gZmFsc2U7fX1yZXR1cm4gdHJ1ZTt9O1xuICAgIHZhciBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFxuICAgICAgXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0zLTEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wb3N0Y3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0zLTIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZXNvbHZlLXVybC1sb2FkZXIvaW5kZXguanM/P3JlZi0tNS1vbmVPZi0zLTMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9zYXNzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0zLTQhLi9Gb290ZXIubW9kdWxlLnNjc3NcIixcbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0zLTEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wb3N0Y3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0zLTIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZXNvbHZlLXVybC1sb2FkZXIvaW5kZXguanM/P3JlZi0tNS1vbmVPZi0zLTMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9zYXNzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0zLTQhLi9Gb290ZXIubW9kdWxlLnNjc3NcIik7XG5cbiAgICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghaXNFcXVhbExvY2FscyhvbGRMb2NhbHMsIGNvbnRlbnQubG9jYWxzKSkge1xuICAgICAgICAgICAgICAgIG1vZHVsZS5ob3QuaW52YWxpZGF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICAgICAgICAgICAgdXBkYXRlKGNvbnRlbnQpO1xuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHtcbiAgICB1cGRhdGUoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHMgfHwge307IiwiaW1wb3J0IHN0eWxlcyBmcm9tICcuL0hlYWRlci5tb2R1bGUuc2NzcydcclxuaW1wb3J0IENvbnRhaW5lciBmcm9tICdAY29tcG9uZW50cy9UZW1wbGF0ZS9Db250YWluZXIvQ29udGFpbmVyJ1xyXG5pbXBvcnQgSW1hZ2UgZnJvbSAnbmV4dC9pbWFnZSdcclxuXHJcbmltcG9ydCBNYXN0ZXJDU1MgZnJvbSAnQGNvbXBvbmVudHMvTGF5b3V0L01hc3RlckNTUy9NYXN0ZXJDU1MnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBIZWFkZXIoeyB0aXRsZSB9KSB7XHJcbiAgcmV0dXJuIChcclxuICBcdDxoZWFkZXIgY2xhc3NOYW1lPXtzdHlsZXMuaGVhZGVyfT5cclxuICBcdCAgPE1hc3RlckNTUy8+XHJcbiAgXHQgIDxDb250YWluZXIgY2xhc3NOYW1lPXtzdHlsZXMuY29udGFpbmVyfT5cclxuICBcdCAgICBcclxuICBcdCAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmNvbnRlbnRMZWZ0fT5cclxuICAgICAgICAgICAgICBcclxuICBcdCAgICAgIFxyXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMudGl0bGV9PlxyXG4gICAgICAgICAgICAgICAgPGgxIGNsYXNzTmFtZT1cIm9sZF9lbmdsaXNoXCI+e3RpdGxlfTwvaDE+XHJcbiAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgXHQgICAgPC9kaXY+XHJcbiAgXHJcbiAgXHQgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5jb250ZW50UmlnaHR9PlxyXG4gIFx0ICAgICAgXHJcbiAgXHQgICAgPC9kaXY+XHJcbiAgXHQgICAgXHJcbiAgXHQgIDwvQ29udGFpbmVyPlxyXG4gIFx0PC9oZWFkZXI+XHJcbiAgKVxyXG59XHJcbiIsInZhciBhcGkgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtc3R5bGUtbG9hZGVyL3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMy0xIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMy0yIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVzb2x2ZS11cmwtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTUtb25lT2YtMy0zIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvc2Fzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMy00IS4vSGVhZGVyLm1vZHVsZS5zY3NzXCIpO1xuXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICB9XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gZnVuY3Rpb24oZWxlbWVudCl7Ly8gVGhlc2UgZWxlbWVudHMgc2hvdWxkIGFsd2F5cyBleGlzdC4gSWYgdGhleSBkbyBub3QsXG4vLyB0aGlzIGNvZGUgc2hvdWxkIGZhaWwuXG52YXIgYW5jaG9yRWxlbWVudD1kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjX19uZXh0X2Nzc19fRE9fTk9UX1VTRV9fJyk7dmFyIHBhcmVudE5vZGU9YW5jaG9yRWxlbWVudC5wYXJlbnROb2RlOy8vIE5vcm1hbGx5IDxoZWFkPlxuLy8gRWFjaCBzdHlsZSB0YWcgc2hvdWxkIGJlIHBsYWNlZCByaWdodCBiZWZvcmUgb3VyXG4vLyBhbmNob3IuIEJ5IGluc2VydGluZyBiZWZvcmUgYW5kIG5vdCBhZnRlciwgd2UgZG8gbm90XG4vLyBuZWVkIHRvIHRyYWNrIHRoZSBsYXN0IGluc2VydGVkIGVsZW1lbnQuXG5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtZW50LGFuY2hvckVsZW1lbnQpO307XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cbmlmIChtb2R1bGUuaG90KSB7XG4gIGlmICghY29udGVudC5sb2NhbHMgfHwgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKSB7XG4gICAgdmFyIGlzRXF1YWxMb2NhbHMgPSBmdW5jdGlvbiBpc0VxdWFsTG9jYWxzKGEsYixpc05hbWVkRXhwb3J0KXtpZighYSYmYnx8YSYmIWIpe3JldHVybiBmYWxzZTt9bGV0IHA7Zm9yKHAgaW4gYSl7aWYoaXNOYW1lZEV4cG9ydCYmcD09PSdkZWZhdWx0Jyl7Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG5jb250aW51ZTt9aWYoYVtwXSE9PWJbcF0pe3JldHVybiBmYWxzZTt9fWZvcihwIGluIGIpe2lmKGlzTmFtZWRFeHBvcnQmJnA9PT0nZGVmYXVsdCcpey8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250aW51ZVxuY29udGludWU7fWlmKCFhW3BdKXtyZXR1cm4gZmFsc2U7fX1yZXR1cm4gdHJ1ZTt9O1xuICAgIHZhciBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFxuICAgICAgXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0zLTEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wb3N0Y3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0zLTIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZXNvbHZlLXVybC1sb2FkZXIvaW5kZXguanM/P3JlZi0tNS1vbmVPZi0zLTMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9zYXNzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0zLTQhLi9IZWFkZXIubW9kdWxlLnNjc3NcIixcbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0zLTEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wb3N0Y3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0zLTIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZXNvbHZlLXVybC1sb2FkZXIvaW5kZXguanM/P3JlZi0tNS1vbmVPZi0zLTMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9zYXNzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0zLTQhLi9IZWFkZXIubW9kdWxlLnNjc3NcIik7XG5cbiAgICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghaXNFcXVhbExvY2FscyhvbGRMb2NhbHMsIGNvbnRlbnQubG9jYWxzKSkge1xuICAgICAgICAgICAgICAgIG1vZHVsZS5ob3QuaW52YWxpZGF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICAgICAgICAgICAgdXBkYXRlKGNvbnRlbnQpO1xuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHtcbiAgICB1cGRhdGUoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHMgfHwge307IiwiaW1wb3J0IHN0eWxlcyBmcm9tICcuL1NhbmRib3gubW9kdWxlLnNjc3MnXHJcbmltcG9ydCBDb250YWluZXIgZnJvbSAnQGNvbXBvbmVudHMvVGVtcGxhdGUvQ29udGFpbmVyL0NvbnRhaW5lcidcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFNhbmRib3goeyBcclxuXHRjaGlsZHJlbiwgXHJcbn0pIHtcclxuICByZXR1cm4gKFxyXG4gICAgPHNlY3Rpb24gIGNsYXNzTmFtZT17c3R5bGVzLnNhbmRib3h9PlxyXG4gICAgICBcclxuICAgICAgPENvbnRhaW5lcj5cclxuICAgICAgICA8ZGl2ICBjbGFzc05hbWU9e3N0eWxlcy5jb250ZW50fT5cclxuICAgICAgICAgIDxwIGNsYXNzTmFtZT17c3R5bGVzLnRpdGxlfT5Db21wb25lbnQgU2FuZGJveDwvcD5cclxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuaW5uZXJ9PlxyXG4gICAgICAgICAgICB7Y2hpbGRyZW59XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgPC9Db250YWluZXI+XHJcbiAgICAgXHJcbiAgICA8L3NlY3Rpb24+XHJcbiAgKVxyXG59XHJcbiIsInZhciBhcGkgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtc3R5bGUtbG9hZGVyL3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMy0xIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMy0yIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVzb2x2ZS11cmwtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTUtb25lT2YtMy0zIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvc2Fzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMy00IS4vU2FuZGJveC5tb2R1bGUuc2Nzc1wiKTtcblxuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgfVxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLmluc2VydCA9IGZ1bmN0aW9uKGVsZW1lbnQpey8vIFRoZXNlIGVsZW1lbnRzIHNob3VsZCBhbHdheXMgZXhpc3QuIElmIHRoZXkgZG8gbm90LFxuLy8gdGhpcyBjb2RlIHNob3VsZCBmYWlsLlxudmFyIGFuY2hvckVsZW1lbnQ9ZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI19fbmV4dF9jc3NfX0RPX05PVF9VU0VfXycpO3ZhciBwYXJlbnROb2RlPWFuY2hvckVsZW1lbnQucGFyZW50Tm9kZTsvLyBOb3JtYWxseSA8aGVhZD5cbi8vIEVhY2ggc3R5bGUgdGFnIHNob3VsZCBiZSBwbGFjZWQgcmlnaHQgYmVmb3JlIG91clxuLy8gYW5jaG9yLiBCeSBpbnNlcnRpbmcgYmVmb3JlIGFuZCBub3QgYWZ0ZXIsIHdlIGRvIG5vdFxuLy8gbmVlZCB0byB0cmFjayB0aGUgbGFzdCBpbnNlcnRlZCBlbGVtZW50LlxucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWxlbWVudCxhbmNob3JFbGVtZW50KTt9O1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5pZiAobW9kdWxlLmhvdCkge1xuICBpZiAoIWNvbnRlbnQubG9jYWxzIHx8IG1vZHVsZS5ob3QuaW52YWxpZGF0ZSkge1xuICAgIHZhciBpc0VxdWFsTG9jYWxzID0gZnVuY3Rpb24gaXNFcXVhbExvY2FscyhhLGIsaXNOYW1lZEV4cG9ydCl7aWYoIWEmJmJ8fGEmJiFiKXtyZXR1cm4gZmFsc2U7fWxldCBwO2ZvcihwIGluIGEpe2lmKGlzTmFtZWRFeHBvcnQmJnA9PT0nZGVmYXVsdCcpey8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250aW51ZVxuY29udGludWU7fWlmKGFbcF0hPT1iW3BdKXtyZXR1cm4gZmFsc2U7fX1mb3IocCBpbiBiKXtpZihpc05hbWVkRXhwb3J0JiZwPT09J2RlZmF1bHQnKXsvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udGludWVcbmNvbnRpbnVlO31pZighYVtwXSl7cmV0dXJuIGZhbHNlO319cmV0dXJuIHRydWU7fTtcbiAgICB2YXIgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcbiAgICAgIFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMy0xIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMy0yIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVzb2x2ZS11cmwtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTUtb25lT2YtMy0zIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvc2Fzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMy00IS4vU2FuZGJveC5tb2R1bGUuc2Nzc1wiLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTMtMSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTMtMiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Jlc29sdmUtdXJsLWxvYWRlci9pbmRleC5qcz8/cmVmLS01LW9uZU9mLTMtMyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Nhc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTMtNCEuL1NhbmRib3gubW9kdWxlLnNjc3NcIik7XG5cbiAgICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghaXNFcXVhbExvY2FscyhvbGRMb2NhbHMsIGNvbnRlbnQubG9jYWxzKSkge1xuICAgICAgICAgICAgICAgIG1vZHVsZS5ob3QuaW52YWxpZGF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICAgICAgICAgICAgdXBkYXRlKGNvbnRlbnQpO1xuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHtcbiAgICB1cGRhdGUoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHMgfHwge307IiwiZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYXJyMltpXSA9IGFycltpXTtcbiAgfVxuXG4gIHJldHVybiBhcnIyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hcnJheUxpa2VUb0FycmF5OyIsImZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlXaXRoSG9sZXM7IiwidmFyIGFycmF5TGlrZVRvQXJyYXkgPSByZXF1aXJlKFwiLi9hcnJheUxpa2VUb0FycmF5XCIpO1xuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KGFycik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5V2l0aG91dEhvbGVzOyIsImZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGY7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2Fzc2VydFRoaXNJbml0aWFsaXplZDsiLCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9jbGFzc0NhbGxDaGVjazsiLCJmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2NyZWF0ZUNsYXNzOyIsImZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZpbmVQcm9wZXJ0eTsiLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfb2JqZWN0RGVzdHJ1Y3R1cmluZ0VtcHR5KG9iaikge1xuICBpZiAob2JqID09IG51bGwpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgZGVzdHJ1Y3R1cmUgdW5kZWZpbmVkXCIpO1xufSIsImZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcblxuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZXh0ZW5kczsiLCJmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBtb2R1bGUuZXhwb3J0cyA9IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgfTtcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZ2V0UHJvdG90eXBlT2Y7IiwidmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZShcIi4vc2V0UHJvdG90eXBlT2ZcIik7XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIHNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaW5oZXJpdHM7IiwiZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICBcImRlZmF1bHRcIjogb2JqXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdDsiLCJmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2l0ZXJhYmxlVG9BcnJheTsiLCJmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8ICEoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSkgcmV0dXJuO1xuICB2YXIgX2FyciA9IFtdO1xuICB2YXIgX24gPSB0cnVlO1xuICB2YXIgX2QgPSBmYWxzZTtcbiAgdmFyIF9lID0gdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2QgPSB0cnVlO1xuICAgIF9lID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9hcnI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2l0ZXJhYmxlVG9BcnJheUxpbWl0OyIsImZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX25vbkl0ZXJhYmxlUmVzdDsiLCJmdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9ub25JdGVyYWJsZVNwcmVhZDsiLCJmdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIGtleSwgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZTsiLCJ2YXIgX3R5cGVvZiA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZlwiKTtcblxudmFyIGFzc2VydFRoaXNJbml0aWFsaXplZCA9IHJlcXVpcmUoXCIuL2Fzc2VydFRoaXNJbml0aWFsaXplZFwiKTtcblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9XG5cbiAgcmV0dXJuIGFzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjsiLCJmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9zZXRQcm90b3R5cGVPZjsiLCJ2YXIgYXJyYXlXaXRoSG9sZXMgPSByZXF1aXJlKFwiLi9hcnJheVdpdGhIb2xlc1wiKTtcblxudmFyIGl0ZXJhYmxlVG9BcnJheUxpbWl0ID0gcmVxdWlyZShcIi4vaXRlcmFibGVUb0FycmF5TGltaXRcIik7XG5cbnZhciB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSA9IHJlcXVpcmUoXCIuL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5XCIpO1xuXG52YXIgbm9uSXRlcmFibGVSZXN0ID0gcmVxdWlyZShcIi4vbm9uSXRlcmFibGVSZXN0XCIpO1xuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgcmV0dXJuIGFycmF5V2l0aEhvbGVzKGFycikgfHwgaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IG5vbkl0ZXJhYmxlUmVzdCgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9zbGljZWRUb0FycmF5OyIsInZhciBhcnJheVdpdGhvdXRIb2xlcyA9IHJlcXVpcmUoXCIuL2FycmF5V2l0aG91dEhvbGVzXCIpO1xuXG52YXIgaXRlcmFibGVUb0FycmF5ID0gcmVxdWlyZShcIi4vaXRlcmFibGVUb0FycmF5XCIpO1xuXG52YXIgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkgPSByZXF1aXJlKFwiLi91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheVwiKTtcblxudmFyIG5vbkl0ZXJhYmxlU3ByZWFkID0gcmVxdWlyZShcIi4vbm9uSXRlcmFibGVTcHJlYWRcIik7XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgcmV0dXJuIGFycmF5V2l0aG91dEhvbGVzKGFycikgfHwgaXRlcmFibGVUb0FycmF5KGFycikgfHwgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBub25JdGVyYWJsZVNwcmVhZCgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF90b0NvbnN1bWFibGVBcnJheTsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF90eXBlb2Y7IiwidmFyIGFycmF5TGlrZVRvQXJyYXkgPSByZXF1aXJlKFwiLi9hcnJheUxpa2VUb0FycmF5XCIpO1xuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheTsiLCJcInVzZSBzdHJpY3RcIjt2YXIgYXNzaWduPU9iamVjdC5hc3NpZ24uYmluZChPYmplY3QpO21vZHVsZS5leHBvcnRzPWFzc2lnbjttb2R1bGUuZXhwb3J0cy5kZWZhdWx0PW1vZHVsZS5leHBvcnRzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2JqZWN0LWFzc2lnbi5qcy5tYXAiLCJcbiAgICAod2luZG93Ll9fTkVYVF9QID0gd2luZG93Ll9fTkVYVF9QIHx8IFtdKS5wdXNoKFtcbiAgICAgIFwiL0ZpbG1HcmFpbkZpbHRlclwiLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmVxdWlyZShcIkQ6XFxcXERldlxcXFxQZXJzb25hbCBTaXRlc1xcXFxOZWNybyBDdWx0IFppbmUgUmVhY3RcXFxcR2l0IEZvbGRlciAxXFxcXG5lY3JvY3VsdC1uZXh0anNcXFxccGFnZXNcXFxcRmlsbUdyYWluRmlsdGVyLmpzXCIpO1xuICAgICAgfVxuICAgIF0pO1xuICAiLCJcInVzZSBzdHJpY3RcIjtjb25zdCBpc09sZElFPWZ1bmN0aW9uIGlzT2xkSUUoKXtsZXQgbWVtbztyZXR1cm4gZnVuY3Rpb24gbWVtb3JpemUoKXtpZih0eXBlb2YgbWVtbz09PSd1bmRlZmluZWQnKXsvLyBUZXN0IGZvciBJRSA8PSA5IGFzIHByb3Bvc2VkIGJ5IEJyb3dzZXJoYWNrc1xuLy8gQHNlZSBodHRwOi8vYnJvd3NlcmhhY2tzLmNvbS8jaGFjay1lNzFkODY5MmY2NTMzNDE3M2ZlZTcxNWMyMjJjYjgwNVxuLy8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlclxuLy8gdG8gb3BlcmF0ZSBjb3JyZWN0bHkgaW50byBub24tc3RhbmRhcmQgZW52aXJvbm1lbnRzXG4vLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcbm1lbW89Qm9vbGVhbih3aW5kb3cmJmRvY3VtZW50JiZkb2N1bWVudC5hbGwmJiF3aW5kb3cuYXRvYik7fXJldHVybiBtZW1vO307fSgpO2NvbnN0IGdldFRhcmdldD1mdW5jdGlvbiBnZXRUYXJnZXQoKXtjb25zdCBtZW1vPXt9O3JldHVybiBmdW5jdGlvbiBtZW1vcml6ZSh0YXJnZXQpe2lmKHR5cGVvZiBtZW1vW3RhcmdldF09PT0ndW5kZWZpbmVkJyl7bGV0IHN0eWxlVGFyZ2V0PWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTsvLyBTcGVjaWFsIGNhc2UgdG8gcmV0dXJuIGhlYWQgb2YgaWZyYW1lIGluc3RlYWQgb2YgaWZyYW1lIGl0c2VsZlxuaWYod2luZG93LkhUTUxJRnJhbWVFbGVtZW50JiZzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCl7dHJ5ey8vIFRoaXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYWNjZXNzIHRvIGlmcmFtZSBpcyBibG9ja2VkXG4vLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuc3R5bGVUYXJnZXQ9c3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7fWNhdGNoKGUpey8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG5zdHlsZVRhcmdldD1udWxsO319bWVtb1t0YXJnZXRdPXN0eWxlVGFyZ2V0O31yZXR1cm4gbWVtb1t0YXJnZXRdO307fSgpO2NvbnN0IHN0eWxlc0luRG9tPVtdO2Z1bmN0aW9uIGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpe2xldCByZXN1bHQ9LTE7Zm9yKGxldCBpPTA7aTxzdHlsZXNJbkRvbS5sZW5ndGg7aSsrKXtpZihzdHlsZXNJbkRvbVtpXS5pZGVudGlmaWVyPT09aWRlbnRpZmllcil7cmVzdWx0PWk7YnJlYWs7fX1yZXR1cm4gcmVzdWx0O31mdW5jdGlvbiBtb2R1bGVzVG9Eb20obGlzdCxvcHRpb25zKXtjb25zdCBpZENvdW50TWFwPXt9O2NvbnN0IGlkZW50aWZpZXJzPVtdO2ZvcihsZXQgaT0wO2k8bGlzdC5sZW5ndGg7aSsrKXtjb25zdCBpdGVtPWxpc3RbaV07Y29uc3QgaWQ9b3B0aW9ucy5iYXNlP2l0ZW1bMF0rb3B0aW9ucy5iYXNlOml0ZW1bMF07Y29uc3QgY291bnQ9aWRDb3VudE1hcFtpZF18fDA7Y29uc3QgaWRlbnRpZmllcj1gJHtpZH0gJHtjb3VudH1gO2lkQ291bnRNYXBbaWRdPWNvdW50KzE7Y29uc3QgaW5kZXg9Z2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7Y29uc3Qgb2JqPXtjc3M6aXRlbVsxXSxtZWRpYTppdGVtWzJdLHNvdXJjZU1hcDppdGVtWzNdfTtpZihpbmRleCE9PS0xKXtzdHlsZXNJbkRvbVtpbmRleF0ucmVmZXJlbmNlcysrO3N0eWxlc0luRG9tW2luZGV4XS51cGRhdGVyKG9iaik7fWVsc2V7c3R5bGVzSW5Eb20ucHVzaCh7aWRlbnRpZmllcix1cGRhdGVyOmFkZFN0eWxlKG9iaixvcHRpb25zKSxyZWZlcmVuY2VzOjF9KTt9aWRlbnRpZmllcnMucHVzaChpZGVudGlmaWVyKTt9cmV0dXJuIGlkZW50aWZpZXJzO31mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucyl7Y29uc3Qgc3R5bGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtjb25zdCBhdHRyaWJ1dGVzPW9wdGlvbnMuYXR0cmlidXRlc3x8e307aWYodHlwZW9mIGF0dHJpYnV0ZXMubm9uY2U9PT0ndW5kZWZpbmVkJyl7Y29uc3Qgbm9uY2U9Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG50eXBlb2YgX193ZWJwYWNrX25vbmNlX18hPT0ndW5kZWZpbmVkJz9fX3dlYnBhY2tfbm9uY2VfXzpudWxsO2lmKG5vbmNlKXthdHRyaWJ1dGVzLm5vbmNlPW5vbmNlO319T2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChrZXk9PntzdHlsZS5zZXRBdHRyaWJ1dGUoa2V5LGF0dHJpYnV0ZXNba2V5XSk7fSk7aWYodHlwZW9mIG9wdGlvbnMuaW5zZXJ0PT09J2Z1bmN0aW9uJyl7b3B0aW9ucy5pbnNlcnQoc3R5bGUpO31lbHNle2NvbnN0IHRhcmdldD1nZXRUYXJnZXQob3B0aW9ucy5pbnNlcnR8fCdoZWFkJyk7aWYoIXRhcmdldCl7dGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnQnIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTt9dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTt9cmV0dXJuIHN0eWxlO31mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpey8vIGlzdGFuYnVsIGlnbm9yZSBpZlxuaWYoc3R5bGUucGFyZW50Tm9kZT09PW51bGwpe3JldHVybiBmYWxzZTt9c3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7fS8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL2NvbnN0IHJlcGxhY2VUZXh0PWZ1bmN0aW9uIHJlcGxhY2VUZXh0KCl7Y29uc3QgdGV4dFN0b3JlPVtdO3JldHVybiBmdW5jdGlvbiByZXBsYWNlKGluZGV4LHJlcGxhY2VtZW50KXt0ZXh0U3RvcmVbaW5kZXhdPXJlcGxhY2VtZW50O3JldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO307fSgpO2Z1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcoc3R5bGUsaW5kZXgscmVtb3ZlLG9iail7Y29uc3QgY3NzPXJlbW92ZT8nJzpvYmoubWVkaWE/YEBtZWRpYSAke29iai5tZWRpYX0geyR7b2JqLmNzc319YDpvYmouY3NzOy8vIEZvciBvbGQgSUVcbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9pZihzdHlsZS5zdHlsZVNoZWV0KXtzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQ9cmVwbGFjZVRleHQoaW5kZXgsY3NzKTt9ZWxzZXtjb25zdCBjc3NOb2RlPWRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7Y29uc3QgY2hpbGROb2Rlcz1zdHlsZS5jaGlsZE5vZGVzO2lmKGNoaWxkTm9kZXNbaW5kZXhdKXtzdHlsZS5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7fWlmKGNoaWxkTm9kZXMubGVuZ3RoKXtzdHlsZS5pbnNlcnRCZWZvcmUoY3NzTm9kZSxjaGlsZE5vZGVzW2luZGV4XSk7fWVsc2V7c3R5bGUuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7fX19ZnVuY3Rpb24gYXBwbHlUb1RhZyhzdHlsZSxvcHRpb25zLG9iail7bGV0IGNzcz1vYmouY3NzO2NvbnN0IG1lZGlhPW9iai5tZWRpYTtjb25zdCBzb3VyY2VNYXA9b2JqLnNvdXJjZU1hcDtpZihtZWRpYSl7c3R5bGUuc2V0QXR0cmlidXRlKCdtZWRpYScsbWVkaWEpO31lbHNle3N0eWxlLnJlbW92ZUF0dHJpYnV0ZSgnbWVkaWEnKTt9aWYoc291cmNlTWFwJiZ0eXBlb2YgYnRvYSE9PSd1bmRlZmluZWQnKXtjc3MrPWBcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LCR7YnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKX0gKi9gO30vLyBGb3Igb2xkIElFXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgICovaWYoc3R5bGUuc3R5bGVTaGVldCl7c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0PWNzczt9ZWxzZXt3aGlsZShzdHlsZS5maXJzdENoaWxkKXtzdHlsZS5yZW1vdmVDaGlsZChzdHlsZS5maXJzdENoaWxkKTt9c3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7fX1sZXQgc2luZ2xldG9uPW51bGw7bGV0IHNpbmdsZXRvbkNvdW50ZXI9MDtmdW5jdGlvbiBhZGRTdHlsZShvYmosb3B0aW9ucyl7bGV0IHN0eWxlO2xldCB1cGRhdGU7bGV0IHJlbW92ZTtpZihvcHRpb25zLnNpbmdsZXRvbil7Y29uc3Qgc3R5bGVJbmRleD1zaW5nbGV0b25Db3VudGVyKys7c3R5bGU9c2luZ2xldG9ufHwoc2luZ2xldG9uPWluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSk7dXBkYXRlPWFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLHN0eWxlLHN0eWxlSW5kZXgsZmFsc2UpO3JlbW92ZT1hcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCxzdHlsZSxzdHlsZUluZGV4LHRydWUpO31lbHNle3N0eWxlPWluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKTt1cGRhdGU9YXBwbHlUb1RhZy5iaW5kKG51bGwsc3R5bGUsb3B0aW9ucyk7cmVtb3ZlPSgpPT57cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTt9O311cGRhdGUob2JqKTtyZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUobmV3T2JqKXtpZihuZXdPYmope2lmKG5ld09iai5jc3M9PT1vYmouY3NzJiZuZXdPYmoubWVkaWE9PT1vYmoubWVkaWEmJm5ld09iai5zb3VyY2VNYXA9PT1vYmouc291cmNlTWFwKXtyZXR1cm47fXVwZGF0ZShvYmo9bmV3T2JqKTt9ZWxzZXtyZW1vdmUoKTt9fTt9bW9kdWxlLmV4cG9ydHM9KGxpc3Qsb3B0aW9ucyk9PntvcHRpb25zPW9wdGlvbnN8fHt9Oy8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuLy8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuaWYoIW9wdGlvbnMuc2luZ2xldG9uJiZ0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24hPT0nYm9vbGVhbicpe29wdGlvbnMuc2luZ2xldG9uPWlzT2xkSUUoKTt9bGlzdD1saXN0fHxbXTtsZXQgbGFzdElkZW50aWZpZXJzPW1vZHVsZXNUb0RvbShsaXN0LG9wdGlvbnMpO3JldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCl7bmV3TGlzdD1uZXdMaXN0fHxbXTtpZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3TGlzdCkhPT0nW29iamVjdCBBcnJheV0nKXtyZXR1cm47fWZvcihsZXQgaT0wO2k8bGFzdElkZW50aWZpZXJzLmxlbmd0aDtpKyspe2NvbnN0IGlkZW50aWZpZXI9bGFzdElkZW50aWZpZXJzW2ldO2NvbnN0IGluZGV4PWdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO3N0eWxlc0luRG9tW2luZGV4XS5yZWZlcmVuY2VzLS07fWNvbnN0IG5ld0xhc3RJZGVudGlmaWVycz1tb2R1bGVzVG9Eb20obmV3TGlzdCxvcHRpb25zKTtmb3IobGV0IGk9MDtpPGxhc3RJZGVudGlmaWVycy5sZW5ndGg7aSsrKXtjb25zdCBpZGVudGlmaWVyPWxhc3RJZGVudGlmaWVyc1tpXTtjb25zdCBpbmRleD1nZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtpZihzdHlsZXNJbkRvbVtpbmRleF0ucmVmZXJlbmNlcz09PTApe3N0eWxlc0luRG9tW2luZGV4XS51cGRhdGVyKCk7c3R5bGVzSW5Eb20uc3BsaWNlKGluZGV4LDEpO319bGFzdElkZW50aWZpZXJzPW5ld0xhc3RJZGVudGlmaWVyczt9O307XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanMubWFwIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IEhlYWQgZnJvbSAnLi4vbmV4dC1zZXJ2ZXIvbGliL2hlYWQnXG5pbXBvcnQgeyB0b0Jhc2U2NCB9IGZyb20gJy4uL25leHQtc2VydmVyL2xpYi90by1iYXNlLTY0J1xuaW1wb3J0IHtcbiAgSW1hZ2VDb25maWcsXG4gIGltYWdlQ29uZmlnRGVmYXVsdCxcbiAgTG9hZGVyVmFsdWUsXG4gIFZBTElEX0xPQURFUlMsXG59IGZyb20gJy4uL25leHQtc2VydmVyL3NlcnZlci9pbWFnZS1jb25maWcnXG5pbXBvcnQgeyB1c2VJbnRlcnNlY3Rpb24gfSBmcm9tICcuL3VzZS1pbnRlcnNlY3Rpb24nXG5cbmlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICA7KGdsb2JhbCBhcyBhbnkpLl9fTkVYVF9JTUFHRV9JTVBPUlRFRCA9IHRydWVcbn1cblxuY29uc3QgVkFMSURfTE9BRElOR19WQUxVRVMgPSBbJ2xhenknLCAnZWFnZXInLCB1bmRlZmluZWRdIGFzIGNvbnN0XG50eXBlIExvYWRpbmdWYWx1ZSA9IHR5cGVvZiBWQUxJRF9MT0FESU5HX1ZBTFVFU1tudW1iZXJdXG5cbmV4cG9ydCB0eXBlIEltYWdlTG9hZGVyID0gKHJlc29sdmVyUHJvcHM6IEltYWdlTG9hZGVyUHJvcHMpID0+IHN0cmluZ1xuXG5leHBvcnQgdHlwZSBJbWFnZUxvYWRlclByb3BzID0ge1xuICBzcmM6IHN0cmluZ1xuICB3aWR0aDogbnVtYmVyXG4gIHF1YWxpdHk/OiBudW1iZXJcbn1cblxudHlwZSBEZWZhdWx0SW1hZ2VMb2FkZXJQcm9wcyA9IEltYWdlTG9hZGVyUHJvcHMgJiB7IHJvb3Q6IHN0cmluZyB9XG5cbmNvbnN0IGxvYWRlcnMgPSBuZXcgTWFwPFxuICBMb2FkZXJWYWx1ZSxcbiAgKHByb3BzOiBEZWZhdWx0SW1hZ2VMb2FkZXJQcm9wcykgPT4gc3RyaW5nXG4+KFtcbiAgWydpbWdpeCcsIGltZ2l4TG9hZGVyXSxcbiAgWydjbG91ZGluYXJ5JywgY2xvdWRpbmFyeUxvYWRlcl0sXG4gIFsnYWthbWFpJywgYWthbWFpTG9hZGVyXSxcbiAgWydkZWZhdWx0JywgZGVmYXVsdExvYWRlcl0sXG5dKVxuXG5jb25zdCBWQUxJRF9MQVlPVVRfVkFMVUVTID0gW1xuICAnZmlsbCcsXG4gICdmaXhlZCcsXG4gICdpbnRyaW5zaWMnLFxuICAncmVzcG9uc2l2ZScsXG4gIHVuZGVmaW5lZCxcbl0gYXMgY29uc3RcbnR5cGUgTGF5b3V0VmFsdWUgPSB0eXBlb2YgVkFMSURfTEFZT1VUX1ZBTFVFU1tudW1iZXJdXG5cbnR5cGUgSW1nRWxlbWVudFN0eWxlID0gTm9uTnVsbGFibGU8SlNYLkludHJpbnNpY0VsZW1lbnRzWydpbWcnXVsnc3R5bGUnXT5cblxuZXhwb3J0IHR5cGUgSW1hZ2VQcm9wcyA9IE9taXQ8XG4gIEpTWC5JbnRyaW5zaWNFbGVtZW50c1snaW1nJ10sXG4gICdzcmMnIHwgJ3NyY1NldCcgfCAncmVmJyB8ICd3aWR0aCcgfCAnaGVpZ2h0JyB8ICdsb2FkaW5nJyB8ICdzdHlsZSdcbj4gJiB7XG4gIHNyYzogc3RyaW5nXG4gIGxvYWRlcj86IEltYWdlTG9hZGVyXG4gIHF1YWxpdHk/OiBudW1iZXIgfCBzdHJpbmdcbiAgcHJpb3JpdHk/OiBib29sZWFuXG4gIGxvYWRpbmc/OiBMb2FkaW5nVmFsdWVcbiAgdW5vcHRpbWl6ZWQ/OiBib29sZWFuXG4gIG9iamVjdEZpdD86IEltZ0VsZW1lbnRTdHlsZVsnb2JqZWN0Rml0J11cbiAgb2JqZWN0UG9zaXRpb24/OiBJbWdFbGVtZW50U3R5bGVbJ29iamVjdFBvc2l0aW9uJ11cbn0gJiAoXG4gICAgfCB7XG4gICAgICAgIHdpZHRoPzogbmV2ZXJcbiAgICAgICAgaGVpZ2h0PzogbmV2ZXJcbiAgICAgICAgLyoqIEBkZXByZWNhdGVkIFVzZSBgbGF5b3V0PVwiZmlsbFwiYCBpbnN0ZWFkICovXG4gICAgICAgIHVuc2l6ZWQ6IHRydWVcbiAgICAgIH1cbiAgICB8IHsgd2lkdGg/OiBuZXZlcjsgaGVpZ2h0PzogbmV2ZXI7IGxheW91dDogJ2ZpbGwnIH1cbiAgICB8IHtcbiAgICAgICAgd2lkdGg6IG51bWJlciB8IHN0cmluZ1xuICAgICAgICBoZWlnaHQ6IG51bWJlciB8IHN0cmluZ1xuICAgICAgICBsYXlvdXQ/OiBFeGNsdWRlPExheW91dFZhbHVlLCAnZmlsbCc+XG4gICAgICB9XG4gIClcblxuY29uc3Qge1xuICBkZXZpY2VTaXplczogY29uZmlnRGV2aWNlU2l6ZXMsXG4gIGltYWdlU2l6ZXM6IGNvbmZpZ0ltYWdlU2l6ZXMsXG4gIGxvYWRlcjogY29uZmlnTG9hZGVyLFxuICBwYXRoOiBjb25maWdQYXRoLFxuICBkb21haW5zOiBjb25maWdEb21haW5zLFxufSA9XG4gICgocHJvY2Vzcy5lbnYuX19ORVhUX0lNQUdFX09QVFMgYXMgYW55KSBhcyBJbWFnZUNvbmZpZykgfHwgaW1hZ2VDb25maWdEZWZhdWx0XG4vLyBzb3J0IHNtYWxsZXN0IHRvIGxhcmdlc3RcbmNvbnN0IGFsbFNpemVzID0gWy4uLmNvbmZpZ0RldmljZVNpemVzLCAuLi5jb25maWdJbWFnZVNpemVzXVxuY29uZmlnRGV2aWNlU2l6ZXMuc29ydCgoYSwgYikgPT4gYSAtIGIpXG5hbGxTaXplcy5zb3J0KChhLCBiKSA9PiBhIC0gYilcblxuZnVuY3Rpb24gZ2V0V2lkdGhzKFxuICB3aWR0aDogbnVtYmVyIHwgdW5kZWZpbmVkLFxuICBsYXlvdXQ6IExheW91dFZhbHVlLFxuICBzaXplczogc3RyaW5nIHwgdW5kZWZpbmVkXG4pOiB7IHdpZHRoczogbnVtYmVyW107IGtpbmQ6ICd3JyB8ICd4JyB9IHtcbiAgaWYgKHNpemVzICYmIChsYXlvdXQgPT09ICdmaWxsJyB8fCBsYXlvdXQgPT09ICdyZXNwb25zaXZlJykpIHtcbiAgICAvLyBGaW5kIGFsbCB0aGUgXCJ2d1wiIHBlcmNlbnQgc2l6ZXMgdXNlZCBpbiB0aGUgc2l6ZXMgcHJvcFxuICAgIGNvbnN0IHBlcmNlbnRTaXplcyA9IFsuLi5zaXplcy5tYXRjaEFsbCgvKF58XFxzKSgxP1xcZD9cXGQpdncvZyldLm1hcCgobSkgPT5cbiAgICAgIHBhcnNlSW50KG1bMl0pXG4gICAgKVxuICAgIGlmIChwZXJjZW50U2l6ZXMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBzbWFsbGVzdFJhdGlvID0gTWF0aC5taW4oLi4ucGVyY2VudFNpemVzKSAqIDAuMDFcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoczogYWxsU2l6ZXMuZmlsdGVyKFxuICAgICAgICAgIChzKSA9PiBzID49IGNvbmZpZ0RldmljZVNpemVzWzBdICogc21hbGxlc3RSYXRpb1xuICAgICAgICApLFxuICAgICAgICBraW5kOiAndycsXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHdpZHRoczogYWxsU2l6ZXMsIGtpbmQ6ICd3JyB9XG4gIH1cbiAgaWYgKFxuICAgIHR5cGVvZiB3aWR0aCAhPT0gJ251bWJlcicgfHxcbiAgICBsYXlvdXQgPT09ICdmaWxsJyB8fFxuICAgIGxheW91dCA9PT0gJ3Jlc3BvbnNpdmUnXG4gICkge1xuICAgIHJldHVybiB7IHdpZHRoczogY29uZmlnRGV2aWNlU2l6ZXMsIGtpbmQ6ICd3JyB9XG4gIH1cblxuICBjb25zdCB3aWR0aHMgPSBbXG4gICAgLi4ubmV3IFNldChcbiAgICAgIC8vID4gVGhpcyBtZWFucyB0aGF0IG1vc3QgT0xFRCBzY3JlZW5zIHRoYXQgc2F5IHRoZXkgYXJlIDN4IHJlc29sdXRpb24sXG4gICAgICAvLyA+IGFyZSBhY3R1YWxseSAzeCBpbiB0aGUgZ3JlZW4gY29sb3IsIGJ1dCBvbmx5IDEuNXggaW4gdGhlIHJlZCBhbmRcbiAgICAgIC8vID4gYmx1ZSBjb2xvcnMuIFNob3dpbmcgYSAzeCByZXNvbHV0aW9uIGltYWdlIGluIHRoZSBhcHAgdnMgYSAyeFxuICAgICAgLy8gPiByZXNvbHV0aW9uIGltYWdlIHdpbGwgYmUgdmlzdWFsbHkgdGhlIHNhbWUsIHRob3VnaCB0aGUgM3ggaW1hZ2VcbiAgICAgIC8vID4gdGFrZXMgc2lnbmlmaWNhbnRseSBtb3JlIGRhdGEuIEV2ZW4gdHJ1ZSAzeCByZXNvbHV0aW9uIHNjcmVlbnMgYXJlXG4gICAgICAvLyA+IHdhc3RlZnVsIGFzIHRoZSBodW1hbiBleWUgY2Fubm90IHNlZSB0aGF0IGxldmVsIG9mIGRldGFpbCB3aXRob3V0XG4gICAgICAvLyA+IHNvbWV0aGluZyBsaWtlIGEgbWFnbmlmeWluZyBnbGFzcy5cbiAgICAgIC8vIGh0dHBzOi8vYmxvZy50d2l0dGVyLmNvbS9lbmdpbmVlcmluZy9lbl91cy90b3BpY3MvaW5mcmFzdHJ1Y3R1cmUvMjAxOS9jYXBwaW5nLWltYWdlLWZpZGVsaXR5LW9uLXVsdHJhLWhpZ2gtcmVzb2x1dGlvbi1kZXZpY2VzLmh0bWxcbiAgICAgIFt3aWR0aCwgd2lkdGggKiAyIC8qLCB3aWR0aCAqIDMqL10ubWFwKFxuICAgICAgICAodykgPT4gYWxsU2l6ZXMuZmluZCgocCkgPT4gcCA+PSB3KSB8fCBhbGxTaXplc1thbGxTaXplcy5sZW5ndGggLSAxXVxuICAgICAgKVxuICAgICksXG4gIF1cbiAgcmV0dXJuIHsgd2lkdGhzLCBraW5kOiAneCcgfVxufVxuXG50eXBlIEdlbkltZ0F0dHJzRGF0YSA9IHtcbiAgc3JjOiBzdHJpbmdcbiAgdW5vcHRpbWl6ZWQ6IGJvb2xlYW5cbiAgbGF5b3V0OiBMYXlvdXRWYWx1ZVxuICBsb2FkZXI6IEltYWdlTG9hZGVyXG4gIHdpZHRoPzogbnVtYmVyXG4gIHF1YWxpdHk/OiBudW1iZXJcbiAgc2l6ZXM/OiBzdHJpbmdcbn1cblxudHlwZSBHZW5JbWdBdHRyc1Jlc3VsdCA9IHtcbiAgc3JjOiBzdHJpbmdcbiAgc3JjU2V0OiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgc2l6ZXM6IHN0cmluZyB8IHVuZGVmaW5lZFxufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUltZ0F0dHJzKHtcbiAgc3JjLFxuICB1bm9wdGltaXplZCxcbiAgbGF5b3V0LFxuICB3aWR0aCxcbiAgcXVhbGl0eSxcbiAgc2l6ZXMsXG4gIGxvYWRlcixcbn06IEdlbkltZ0F0dHJzRGF0YSk6IEdlbkltZ0F0dHJzUmVzdWx0IHtcbiAgaWYgKHVub3B0aW1pemVkKSB7XG4gICAgcmV0dXJuIHsgc3JjLCBzcmNTZXQ6IHVuZGVmaW5lZCwgc2l6ZXM6IHVuZGVmaW5lZCB9XG4gIH1cblxuICBjb25zdCB7IHdpZHRocywga2luZCB9ID0gZ2V0V2lkdGhzKHdpZHRoLCBsYXlvdXQsIHNpemVzKVxuICBjb25zdCBsYXN0ID0gd2lkdGhzLmxlbmd0aCAtIDFcblxuICByZXR1cm4ge1xuICAgIHNpemVzOiAhc2l6ZXMgJiYga2luZCA9PT0gJ3cnID8gJzEwMHZ3JyA6IHNpemVzLFxuICAgIHNyY1NldDogd2lkdGhzXG4gICAgICAubWFwKFxuICAgICAgICAodywgaSkgPT5cbiAgICAgICAgICBgJHtsb2FkZXIoeyBzcmMsIHF1YWxpdHksIHdpZHRoOiB3IH0pfSAke1xuICAgICAgICAgICAga2luZCA9PT0gJ3cnID8gdyA6IGkgKyAxXG4gICAgICAgICAgfSR7a2luZH1gXG4gICAgICApXG4gICAgICAuam9pbignLCAnKSxcblxuICAgIC8vIEl0J3MgaW50ZW5kZWQgdG8ga2VlcCBgc3JjYCB0aGUgbGFzdCBhdHRyaWJ1dGUgYmVjYXVzZSBSZWFjdCB1cGRhdGVzXG4gICAgLy8gYXR0cmlidXRlcyBpbiBvcmRlci4gSWYgd2Uga2VlcCBgc3JjYCB0aGUgZmlyc3Qgb25lLCBTYWZhcmkgd2lsbFxuICAgIC8vIGltbWVkaWF0ZWx5IHN0YXJ0IHRvIGZldGNoIGBzcmNgLCBiZWZvcmUgYHNpemVzYCBhbmQgYHNyY1NldGAgYXJlIGV2ZW5cbiAgICAvLyB1cGRhdGVkIGJ5IFJlYWN0LiBUaGF0IGNhdXNlcyBtdWx0aXBsZSB1bm5lY2Vzc2FyeSByZXF1ZXN0cyBpZiBgc3JjU2V0YFxuICAgIC8vIGFuZCBgc2l6ZXNgIGFyZSBkZWZpbmVkLlxuICAgIC8vIFRoaXMgYnVnIGNhbm5vdCBiZSByZXByb2R1Y2VkIGluIENocm9tZSBvciBGaXJlZm94LlxuICAgIHNyYzogbG9hZGVyKHsgc3JjLCBxdWFsaXR5LCB3aWR0aDogd2lkdGhzW2xhc3RdIH0pLFxuICB9XG59XG5cbmZ1bmN0aW9uIGdldEludCh4OiB1bmtub3duKTogbnVtYmVyIHwgdW5kZWZpbmVkIHtcbiAgaWYgKHR5cGVvZiB4ID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB4XG4gIH1cbiAgaWYgKHR5cGVvZiB4ID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBwYXJzZUludCh4LCAxMClcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkXG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRJbWFnZUxvYWRlcihsb2FkZXJQcm9wczogSW1hZ2VMb2FkZXJQcm9wcykge1xuICBjb25zdCBsb2FkID0gbG9hZGVycy5nZXQoY29uZmlnTG9hZGVyKVxuICBpZiAobG9hZCkge1xuICAgIHJldHVybiBsb2FkKHsgcm9vdDogY29uZmlnUGF0aCwgLi4ubG9hZGVyUHJvcHMgfSlcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgYFVua25vd24gXCJsb2FkZXJcIiBmb3VuZCBpbiBcIm5leHQuY29uZmlnLmpzXCIuIEV4cGVjdGVkOiAke1ZBTElEX0xPQURFUlMuam9pbihcbiAgICAgICcsICdcbiAgICApfS4gUmVjZWl2ZWQ6ICR7Y29uZmlnTG9hZGVyfWBcbiAgKVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBJbWFnZSh7XG4gIHNyYyxcbiAgc2l6ZXMsXG4gIHVub3B0aW1pemVkID0gZmFsc2UsXG4gIHByaW9yaXR5ID0gZmFsc2UsXG4gIGxvYWRpbmcsXG4gIGNsYXNzTmFtZSxcbiAgcXVhbGl0eSxcbiAgd2lkdGgsXG4gIGhlaWdodCxcbiAgb2JqZWN0Rml0LFxuICBvYmplY3RQb3NpdGlvbixcbiAgbG9hZGVyID0gZGVmYXVsdEltYWdlTG9hZGVyLFxuICAuLi5hbGxcbn06IEltYWdlUHJvcHMpIHtcbiAgbGV0IHJlc3Q6IFBhcnRpYWw8SW1hZ2VQcm9wcz4gPSBhbGxcbiAgbGV0IGxheW91dDogTm9uTnVsbGFibGU8TGF5b3V0VmFsdWU+ID0gc2l6ZXMgPyAncmVzcG9uc2l2ZScgOiAnaW50cmluc2ljJ1xuICBsZXQgdW5zaXplZCA9IGZhbHNlXG4gIGlmICgndW5zaXplZCcgaW4gcmVzdCkge1xuICAgIHVuc2l6ZWQgPSBCb29sZWFuKHJlc3QudW5zaXplZClcbiAgICAvLyBSZW1vdmUgcHJvcGVydHkgc28gaXQncyBub3Qgc3ByZWFkIGludG8gaW1hZ2U6XG4gICAgZGVsZXRlIHJlc3RbJ3Vuc2l6ZWQnXVxuICB9IGVsc2UgaWYgKCdsYXlvdXQnIGluIHJlc3QpIHtcbiAgICAvLyBPdmVycmlkZSBkZWZhdWx0IGxheW91dCBpZiB0aGUgdXNlciBzcGVjaWZpZWQgb25lOlxuICAgIGlmIChyZXN0LmxheW91dCkgbGF5b3V0ID0gcmVzdC5sYXlvdXRcblxuICAgIC8vIFJlbW92ZSBwcm9wZXJ0eSBzbyBpdCdzIG5vdCBzcHJlYWQgaW50byBpbWFnZTpcbiAgICBkZWxldGUgcmVzdFsnbGF5b3V0J11cbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKCFzcmMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEltYWdlIGlzIG1pc3NpbmcgcmVxdWlyZWQgXCJzcmNcIiBwcm9wZXJ0eS4gTWFrZSBzdXJlIHlvdSBwYXNzIFwic3JjXCIgaW4gcHJvcHMgdG8gdGhlIFxcYG5leHQvaW1hZ2VcXGAgY29tcG9uZW50LiBSZWNlaXZlZDogJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICB7IHdpZHRoLCBoZWlnaHQsIHF1YWxpdHkgfVxuICAgICAgICApfWBcbiAgICAgIClcbiAgICB9XG4gICAgaWYgKCFWQUxJRF9MQVlPVVRfVkFMVUVTLmluY2x1ZGVzKGxheW91dCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaGFzIGludmFsaWQgXCJsYXlvdXRcIiBwcm9wZXJ0eS4gUHJvdmlkZWQgXCIke2xheW91dH1cIiBzaG91bGQgYmUgb25lIG9mICR7VkFMSURfTEFZT1VUX1ZBTFVFUy5tYXAoXG4gICAgICAgICAgU3RyaW5nXG4gICAgICAgICkuam9pbignLCcpfS5gXG4gICAgICApXG4gICAgfVxuICAgIGlmICghVkFMSURfTE9BRElOR19WQUxVRVMuaW5jbHVkZXMobG9hZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaGFzIGludmFsaWQgXCJsb2FkaW5nXCIgcHJvcGVydHkuIFByb3ZpZGVkIFwiJHtsb2FkaW5nfVwiIHNob3VsZCBiZSBvbmUgb2YgJHtWQUxJRF9MT0FESU5HX1ZBTFVFUy5tYXAoXG4gICAgICAgICAgU3RyaW5nXG4gICAgICAgICkuam9pbignLCcpfS5gXG4gICAgICApXG4gICAgfVxuICAgIGlmIChwcmlvcml0eSAmJiBsb2FkaW5nID09PSAnbGF6eScpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaGFzIGJvdGggXCJwcmlvcml0eVwiIGFuZCBcImxvYWRpbmc9J2xhenknXCIgcHJvcGVydGllcy4gT25seSBvbmUgc2hvdWxkIGJlIHVzZWQuYFxuICAgICAgKVxuICAgIH1cbiAgICBpZiAodW5zaXplZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBoYXMgZGVwcmVjYXRlZCBcInVuc2l6ZWRcIiBwcm9wZXJ0eSwgd2hpY2ggd2FzIHJlbW92ZWQgaW4gZmF2b3Igb2YgdGhlIFwibGF5b3V0PSdmaWxsJ1wiIHByb3BlcnR5YFxuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIGxldCBpc0xhenkgPVxuICAgICFwcmlvcml0eSAmJiAobG9hZGluZyA9PT0gJ2xhenknIHx8IHR5cGVvZiBsb2FkaW5nID09PSAndW5kZWZpbmVkJylcbiAgaWYgKHNyYyAmJiBzcmMuc3RhcnRzV2l0aCgnZGF0YTonKSkge1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvQmFzaWNzX29mX0hUVFAvRGF0YV9VUklzXG4gICAgdW5vcHRpbWl6ZWQgPSB0cnVlXG4gICAgaXNMYXp5ID0gZmFsc2VcbiAgfVxuXG4gIGNvbnN0IFtzZXRSZWYsIGlzSW50ZXJzZWN0ZWRdID0gdXNlSW50ZXJzZWN0aW9uPEhUTUxJbWFnZUVsZW1lbnQ+KHtcbiAgICByb290TWFyZ2luOiAnMjAwcHgnLFxuICAgIGRpc2FibGVkOiAhaXNMYXp5LFxuICB9KVxuICBjb25zdCBpc1Zpc2libGUgPSAhaXNMYXp5IHx8IGlzSW50ZXJzZWN0ZWRcblxuICBjb25zdCB3aWR0aEludCA9IGdldEludCh3aWR0aClcbiAgY29uc3QgaGVpZ2h0SW50ID0gZ2V0SW50KGhlaWdodClcbiAgY29uc3QgcXVhbGl0eUludCA9IGdldEludChxdWFsaXR5KVxuXG4gIGxldCB3cmFwcGVyU3R5bGU6IEpTWC5JbnRyaW5zaWNFbGVtZW50c1snZGl2J11bJ3N0eWxlJ10gfCB1bmRlZmluZWRcbiAgbGV0IHNpemVyU3R5bGU6IEpTWC5JbnRyaW5zaWNFbGVtZW50c1snZGl2J11bJ3N0eWxlJ10gfCB1bmRlZmluZWRcbiAgbGV0IHNpemVyU3ZnOiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgbGV0IGltZ1N0eWxlOiBJbWdFbGVtZW50U3R5bGUgfCB1bmRlZmluZWQgPSB7XG4gICAgdmlzaWJpbGl0eTogaXNWaXNpYmxlID8gJ2luaGVyaXQnIDogJ2hpZGRlbicsXG5cbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICB0b3A6IDAsXG4gICAgbGVmdDogMCxcbiAgICBib3R0b206IDAsXG4gICAgcmlnaHQ6IDAsXG5cbiAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICBwYWRkaW5nOiAwLFxuICAgIGJvcmRlcjogJ25vbmUnLFxuICAgIG1hcmdpbjogJ2F1dG8nLFxuXG4gICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDAsXG4gICAgbWluV2lkdGg6ICcxMDAlJyxcbiAgICBtYXhXaWR0aDogJzEwMCUnLFxuICAgIG1pbkhlaWdodDogJzEwMCUnLFxuICAgIG1heEhlaWdodDogJzEwMCUnLFxuXG4gICAgb2JqZWN0Rml0LFxuICAgIG9iamVjdFBvc2l0aW9uLFxuICB9XG4gIGlmIChcbiAgICB0eXBlb2Ygd2lkdGhJbnQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGhlaWdodEludCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICBsYXlvdXQgIT09ICdmaWxsJ1xuICApIHtcbiAgICAvLyA8SW1hZ2Ugc3JjPVwiaS5wbmdcIiB3aWR0aD1cIjEwMFwiIGhlaWdodD1cIjEwMFwiIC8+XG4gICAgY29uc3QgcXVvdGllbnQgPSBoZWlnaHRJbnQgLyB3aWR0aEludFxuICAgIGNvbnN0IHBhZGRpbmdUb3AgPSBpc05hTihxdW90aWVudCkgPyAnMTAwJScgOiBgJHtxdW90aWVudCAqIDEwMH0lYFxuICAgIGlmIChsYXlvdXQgPT09ICdyZXNwb25zaXZlJykge1xuICAgICAgLy8gPEltYWdlIHNyYz1cImkucG5nXCIgd2lkdGg9XCIxMDBcIiBoZWlnaHQ9XCIxMDBcIiBsYXlvdXQ9XCJyZXNwb25zaXZlXCIgLz5cbiAgICAgIHdyYXBwZXJTdHlsZSA9IHtcbiAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcblxuICAgICAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICAgICAgbWFyZ2luOiAwLFxuICAgICAgfVxuICAgICAgc2l6ZXJTdHlsZSA9IHsgZGlzcGxheTogJ2Jsb2NrJywgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsIHBhZGRpbmdUb3AgfVxuICAgIH0gZWxzZSBpZiAobGF5b3V0ID09PSAnaW50cmluc2ljJykge1xuICAgICAgLy8gPEltYWdlIHNyYz1cImkucG5nXCIgd2lkdGg9XCIxMDBcIiBoZWlnaHQ9XCIxMDBcIiBsYXlvdXQ9XCJpbnRyaW5zaWNcIiAvPlxuICAgICAgd3JhcHBlclN0eWxlID0ge1xuICAgICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgICAgbWF4V2lkdGg6ICcxMDAlJyxcbiAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgICAgIG1hcmdpbjogMCxcbiAgICAgIH1cbiAgICAgIHNpemVyU3R5bGUgPSB7XG4gICAgICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgICAgICBkaXNwbGF5OiAnYmxvY2snLFxuICAgICAgICBtYXhXaWR0aDogJzEwMCUnLFxuICAgICAgfVxuICAgICAgc2l6ZXJTdmcgPSBgPHN2ZyB3aWR0aD1cIiR7d2lkdGhJbnR9XCIgaGVpZ2h0PVwiJHtoZWlnaHRJbnR9XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZlcnNpb249XCIxLjFcIi8+YFxuICAgIH0gZWxzZSBpZiAobGF5b3V0ID09PSAnZml4ZWQnKSB7XG4gICAgICAvLyA8SW1hZ2Ugc3JjPVwiaS5wbmdcIiB3aWR0aD1cIjEwMFwiIGhlaWdodD1cIjEwMFwiIGxheW91dD1cImZpeGVkXCIgLz5cbiAgICAgIHdyYXBwZXJTdHlsZSA9IHtcbiAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG4gICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICB3aWR0aDogd2lkdGhJbnQsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0SW50LFxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChcbiAgICB0eXBlb2Ygd2lkdGhJbnQgPT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGhlaWdodEludCA9PT0gJ3VuZGVmaW5lZCcgJiZcbiAgICBsYXlvdXQgPT09ICdmaWxsJ1xuICApIHtcbiAgICAvLyA8SW1hZ2Ugc3JjPVwiaS5wbmdcIiBsYXlvdXQ9XCJmaWxsXCIgLz5cbiAgICB3cmFwcGVyU3R5bGUgPSB7XG4gICAgICBkaXNwbGF5OiAnYmxvY2snLFxuICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuXG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIHRvcDogMCxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICBib3R0b206IDAsXG4gICAgICByaWdodDogMCxcblxuICAgICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgICBtYXJnaW46IDAsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIDxJbWFnZSBzcmM9XCJpLnBuZ1wiIC8+XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgbXVzdCB1c2UgXCJ3aWR0aFwiIGFuZCBcImhlaWdodFwiIHByb3BlcnRpZXMgb3IgXCJsYXlvdXQ9J2ZpbGwnXCIgcHJvcGVydHkuYFxuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIGxldCBpbWdBdHRyaWJ1dGVzOiBHZW5JbWdBdHRyc1Jlc3VsdCA9IHtcbiAgICBzcmM6XG4gICAgICAnZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQVFBQkFJQUFBQUFBQVAvLy95SDVCQUVBQUFBQUxBQUFBQUFCQUFFQUFBSUJSQUE3JyxcbiAgICBzcmNTZXQ6IHVuZGVmaW5lZCxcbiAgICBzaXplczogdW5kZWZpbmVkLFxuICB9XG5cbiAgaWYgKGlzVmlzaWJsZSkge1xuICAgIGltZ0F0dHJpYnV0ZXMgPSBnZW5lcmF0ZUltZ0F0dHJzKHtcbiAgICAgIHNyYyxcbiAgICAgIHVub3B0aW1pemVkLFxuICAgICAgbGF5b3V0LFxuICAgICAgd2lkdGg6IHdpZHRoSW50LFxuICAgICAgcXVhbGl0eTogcXVhbGl0eUludCxcbiAgICAgIHNpemVzLFxuICAgICAgbG9hZGVyLFxuICAgIH0pXG4gIH1cblxuICBpZiAodW5zaXplZCkge1xuICAgIHdyYXBwZXJTdHlsZSA9IHVuZGVmaW5lZFxuICAgIHNpemVyU3R5bGUgPSB1bmRlZmluZWRcbiAgICBpbWdTdHlsZSA9IHVuZGVmaW5lZFxuICB9XG4gIHJldHVybiAoXG4gICAgPGRpdiBzdHlsZT17d3JhcHBlclN0eWxlfT5cbiAgICAgIHtzaXplclN0eWxlID8gKFxuICAgICAgICA8ZGl2IHN0eWxlPXtzaXplclN0eWxlfT5cbiAgICAgICAgICB7c2l6ZXJTdmcgPyAoXG4gICAgICAgICAgICA8aW1nXG4gICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgbWF4V2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiAnYmxvY2snLFxuICAgICAgICAgICAgICAgIG1hcmdpbjogMCxcbiAgICAgICAgICAgICAgICBib3JkZXI6ICdub25lJyxcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICBhbHQ9XCJcIlxuICAgICAgICAgICAgICBhcmlhLWhpZGRlbj17dHJ1ZX1cbiAgICAgICAgICAgICAgcm9sZT1cInByZXNlbnRhdGlvblwiXG4gICAgICAgICAgICAgIHNyYz17YGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsJHt0b0Jhc2U2NChzaXplclN2Zyl9YH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgKSA6IG51bGx9XG4gICAgICAgIDwvZGl2PlxuICAgICAgKSA6IG51bGx9XG4gICAgICA8aW1nXG4gICAgICAgIHsuLi5yZXN0fVxuICAgICAgICB7Li4uaW1nQXR0cmlidXRlc31cbiAgICAgICAgZGVjb2Rpbmc9XCJhc3luY1wiXG4gICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lfVxuICAgICAgICByZWY9e3NldFJlZn1cbiAgICAgICAgc3R5bGU9e2ltZ1N0eWxlfVxuICAgICAgLz5cbiAgICAgIHtwcmlvcml0eSA/IChcbiAgICAgICAgLy8gTm90ZSBob3cgd2Ugb21pdCB0aGUgYGhyZWZgIGF0dHJpYnV0ZSwgYXMgaXQgd291bGQgb25seSBiZSByZWxldmFudFxuICAgICAgICAvLyBmb3IgYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCBgaW1hZ2VzcmNzZXRgLCBhbmQgaW4gdGhvc2UgY2FzZXNcbiAgICAgICAgLy8gaXQgd291bGQgbGlrZWx5IGNhdXNlIHRoZSBpbmNvcnJlY3QgaW1hZ2UgdG8gYmUgcHJlbG9hZGVkLlxuICAgICAgICAvL1xuICAgICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zZW1hbnRpY3MuaHRtbCNhdHRyLWxpbmstaW1hZ2VzcmNzZXRcbiAgICAgICAgPEhlYWQ+XG4gICAgICAgICAgPGxpbmtcbiAgICAgICAgICAgIGtleT17XG4gICAgICAgICAgICAgICdfX25pbWctJyArXG4gICAgICAgICAgICAgIGltZ0F0dHJpYnV0ZXMuc3JjICtcbiAgICAgICAgICAgICAgaW1nQXR0cmlidXRlcy5zcmNTZXQgK1xuICAgICAgICAgICAgICBpbWdBdHRyaWJ1dGVzLnNpemVzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWw9XCJwcmVsb2FkXCJcbiAgICAgICAgICAgIGFzPVwiaW1hZ2VcIlxuICAgICAgICAgICAgaHJlZj17aW1nQXR0cmlidXRlcy5zcmNTZXQgPyB1bmRlZmluZWQgOiBpbWdBdHRyaWJ1dGVzLnNyY31cbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmU6IGltYWdlc3Jjc2V0IGlzIG5vdCB5ZXQgaW4gdGhlIGxpbmsgZWxlbWVudCB0eXBlXG4gICAgICAgICAgICBpbWFnZXNyY3NldD17aW1nQXR0cmlidXRlcy5zcmNTZXR9XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlOiBpbWFnZXNpemVzIGlzIG5vdCB5ZXQgaW4gdGhlIGxpbmsgZWxlbWVudCB0eXBlXG4gICAgICAgICAgICBpbWFnZXNpemVzPXtpbWdBdHRyaWJ1dGVzLnNpemVzfVxuICAgICAgICAgID48L2xpbms+XG4gICAgICAgIDwvSGVhZD5cbiAgICAgICkgOiBudWxsfVxuICAgIDwvZGl2PlxuICApXG59XG5cbi8vQlVJTFQgSU4gTE9BREVSU1xuXG5mdW5jdGlvbiBub3JtYWxpemVTcmMoc3JjOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gc3JjWzBdID09PSAnLycgPyBzcmMuc2xpY2UoMSkgOiBzcmNcbn1cblxuZnVuY3Rpb24gaW1naXhMb2FkZXIoe1xuICByb290LFxuICBzcmMsXG4gIHdpZHRoLFxuICBxdWFsaXR5LFxufTogRGVmYXVsdEltYWdlTG9hZGVyUHJvcHMpOiBzdHJpbmcge1xuICAvLyBEZW1vOiBodHRwczovL3N0YXRpYy5pbWdpeC5uZXQvZGFpc3kucG5nP2Zvcm1hdD1hdXRvJmZpdD1tYXgmdz0zMDBcbiAgY29uc3QgcGFyYW1zID0gWydhdXRvPWZvcm1hdCcsICdmaXQ9bWF4JywgJ3c9JyArIHdpZHRoXVxuICBsZXQgcGFyYW1zU3RyaW5nID0gJydcbiAgaWYgKHF1YWxpdHkpIHtcbiAgICBwYXJhbXMucHVzaCgncT0nICsgcXVhbGl0eSlcbiAgfVxuXG4gIGlmIChwYXJhbXMubGVuZ3RoKSB7XG4gICAgcGFyYW1zU3RyaW5nID0gJz8nICsgcGFyYW1zLmpvaW4oJyYnKVxuICB9XG4gIHJldHVybiBgJHtyb290fSR7bm9ybWFsaXplU3JjKHNyYyl9JHtwYXJhbXNTdHJpbmd9YFxufVxuXG5mdW5jdGlvbiBha2FtYWlMb2FkZXIoeyByb290LCBzcmMsIHdpZHRoIH06IERlZmF1bHRJbWFnZUxvYWRlclByb3BzKTogc3RyaW5nIHtcbiAgcmV0dXJuIGAke3Jvb3R9JHtub3JtYWxpemVTcmMoc3JjKX0/aW13aWR0aD0ke3dpZHRofWBcbn1cblxuZnVuY3Rpb24gY2xvdWRpbmFyeUxvYWRlcih7XG4gIHJvb3QsXG4gIHNyYyxcbiAgd2lkdGgsXG4gIHF1YWxpdHksXG59OiBEZWZhdWx0SW1hZ2VMb2FkZXJQcm9wcyk6IHN0cmluZyB7XG4gIC8vIERlbW86IGh0dHBzOi8vcmVzLmNsb3VkaW5hcnkuY29tL2RlbW8vaW1hZ2UvdXBsb2FkL3dfMzAwLGNfbGltaXQscV9hdXRvL3R1cnRsZXMuanBnXG4gIGNvbnN0IHBhcmFtcyA9IFsnZl9hdXRvJywgJ2NfbGltaXQnLCAnd18nICsgd2lkdGgsICdxXycgKyAocXVhbGl0eSB8fCAnYXV0bycpXVxuICBsZXQgcGFyYW1zU3RyaW5nID0gcGFyYW1zLmpvaW4oJywnKSArICcvJ1xuICByZXR1cm4gYCR7cm9vdH0ke3BhcmFtc1N0cmluZ30ke25vcm1hbGl6ZVNyYyhzcmMpfWBcbn1cblxuZnVuY3Rpb24gZGVmYXVsdExvYWRlcih7XG4gIHJvb3QsXG4gIHNyYyxcbiAgd2lkdGgsXG4gIHF1YWxpdHksXG59OiBEZWZhdWx0SW1hZ2VMb2FkZXJQcm9wcyk6IHN0cmluZyB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY29uc3QgbWlzc2luZ1ZhbHVlcyA9IFtdXG5cbiAgICAvLyB0aGVzZSBzaG91bGQgYWx3YXlzIGJlIHByb3ZpZGVkIGJ1dCBtYWtlIHN1cmUgdGhleSBhcmVcbiAgICBpZiAoIXNyYykgbWlzc2luZ1ZhbHVlcy5wdXNoKCdzcmMnKVxuICAgIGlmICghd2lkdGgpIG1pc3NpbmdWYWx1ZXMucHVzaCgnd2lkdGgnKVxuXG4gICAgaWYgKG1pc3NpbmdWYWx1ZXMubGVuZ3RoID4gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgTmV4dCBJbWFnZSBPcHRpbWl6YXRpb24gcmVxdWlyZXMgJHttaXNzaW5nVmFsdWVzLmpvaW4oXG4gICAgICAgICAgJywgJ1xuICAgICAgICApfSB0byBiZSBwcm92aWRlZC4gTWFrZSBzdXJlIHlvdSBwYXNzIHRoZW0gYXMgcHJvcHMgdG8gdGhlIFxcYG5leHQvaW1hZ2VcXGAgY29tcG9uZW50LiBSZWNlaXZlZDogJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICB7IHNyYywgd2lkdGgsIHF1YWxpdHkgfVxuICAgICAgICApfWBcbiAgICAgIClcbiAgICB9XG5cbiAgICBpZiAoc3JjLnN0YXJ0c1dpdGgoJy8vJykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEZhaWxlZCB0byBwYXJzZSBzcmMgXCIke3NyY31cIiBvbiBcXGBuZXh0L2ltYWdlXFxgLCBwcm90b2NvbC1yZWxhdGl2ZSBVUkwgKC8vKSBtdXN0IGJlIGNoYW5nZWQgdG8gYW4gYWJzb2x1dGUgVVJMIChodHRwOi8vIG9yIGh0dHBzOi8vKWBcbiAgICAgIClcbiAgICB9XG5cbiAgICBpZiAoIXNyYy5zdGFydHNXaXRoKCcvJykgJiYgY29uZmlnRG9tYWlucykge1xuICAgICAgbGV0IHBhcnNlZFNyYzogVVJMXG4gICAgICB0cnkge1xuICAgICAgICBwYXJzZWRTcmMgPSBuZXcgVVJMKHNyYylcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBGYWlsZWQgdG8gcGFyc2Ugc3JjIFwiJHtzcmN9XCIgb24gXFxgbmV4dC9pbWFnZVxcYCwgaWYgdXNpbmcgcmVsYXRpdmUgaW1hZ2UgaXQgbXVzdCBzdGFydCB3aXRoIGEgbGVhZGluZyBzbGFzaCBcIi9cIiBvciBiZSBhbiBhYnNvbHV0ZSBVUkwgKGh0dHA6Ly8gb3IgaHR0cHM6Ly8pYFxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIGlmICghY29uZmlnRG9tYWlucy5pbmNsdWRlcyhwYXJzZWRTcmMuaG9zdG5hbWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgSW52YWxpZCBzcmMgcHJvcCAoJHtzcmN9KSBvbiBcXGBuZXh0L2ltYWdlXFxgLCBob3N0bmFtZSBcIiR7cGFyc2VkU3JjLmhvc3RuYW1lfVwiIGlzIG5vdCBjb25maWd1cmVkIHVuZGVyIGltYWdlcyBpbiB5b3VyIFxcYG5leHQuY29uZmlnLmpzXFxgXFxuYCArXG4gICAgICAgICAgICBgU2VlIG1vcmUgaW5mbzogaHR0cHM6Ly9lcnIuc2gvbmV4dC5qcy9uZXh0LWltYWdlLXVuY29uZmlndXJlZC1ob3N0YFxuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGAke3Jvb3R9P3VybD0ke2VuY29kZVVSSUNvbXBvbmVudChzcmMpfSZ3PSR7d2lkdGh9JnE9JHtxdWFsaXR5IHx8IDc1fWBcbn1cbiIsInR5cGUgUmVxdWVzdElkbGVDYWxsYmFja0hhbmRsZSA9IGFueVxudHlwZSBSZXF1ZXN0SWRsZUNhbGxiYWNrT3B0aW9ucyA9IHtcbiAgdGltZW91dDogbnVtYmVyXG59XG50eXBlIFJlcXVlc3RJZGxlQ2FsbGJhY2tEZWFkbGluZSA9IHtcbiAgcmVhZG9ubHkgZGlkVGltZW91dDogYm9vbGVhblxuICB0aW1lUmVtYWluaW5nOiAoKSA9PiBudW1iZXJcbn1cblxuZGVjbGFyZSBnbG9iYWwge1xuICBpbnRlcmZhY2UgV2luZG93IHtcbiAgICByZXF1ZXN0SWRsZUNhbGxiYWNrOiAoXG4gICAgICBjYWxsYmFjazogKGRlYWRsaW5lOiBSZXF1ZXN0SWRsZUNhbGxiYWNrRGVhZGxpbmUpID0+IHZvaWQsXG4gICAgICBvcHRzPzogUmVxdWVzdElkbGVDYWxsYmFja09wdGlvbnNcbiAgICApID0+IFJlcXVlc3RJZGxlQ2FsbGJhY2tIYW5kbGVcbiAgICBjYW5jZWxJZGxlQ2FsbGJhY2s6IChpZDogUmVxdWVzdElkbGVDYWxsYmFja0hhbmRsZSkgPT4gdm9pZFxuICB9XG59XG5cbmV4cG9ydCBjb25zdCByZXF1ZXN0SWRsZUNhbGxiYWNrID1cbiAgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmLnJlcXVlc3RJZGxlQ2FsbGJhY2spIHx8XG4gIGZ1bmN0aW9uIChcbiAgICBjYjogKGRlYWRsaW5lOiBSZXF1ZXN0SWRsZUNhbGxiYWNrRGVhZGxpbmUpID0+IHZvaWRcbiAgKTogTm9kZUpTLlRpbWVvdXQge1xuICAgIGxldCBzdGFydCA9IERhdGUubm93KClcbiAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBjYih7XG4gICAgICAgIGRpZFRpbWVvdXQ6IGZhbHNlLFxuICAgICAgICB0aW1lUmVtYWluaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIDUwIC0gKERhdGUubm93KCkgLSBzdGFydCkpXG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgIH0sIDEpXG4gIH1cblxuZXhwb3J0IGNvbnN0IGNhbmNlbElkbGVDYWxsYmFjayA9XG4gICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5jYW5jZWxJZGxlQ2FsbGJhY2spIHx8XG4gIGZ1bmN0aW9uIChpZDogUmVxdWVzdElkbGVDYWxsYmFja0hhbmRsZSkge1xuICAgIHJldHVybiBjbGVhclRpbWVvdXQoaWQpXG4gIH1cbiIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7XG4gIHJlcXVlc3RJZGxlQ2FsbGJhY2ssXG4gIGNhbmNlbElkbGVDYWxsYmFjayxcbn0gZnJvbSAnLi9yZXF1ZXN0LWlkbGUtY2FsbGJhY2snXG5cbnR5cGUgVXNlSW50ZXJzZWN0aW9uT2JzZXJ2ZXJJbml0ID0gUGljazxJbnRlcnNlY3Rpb25PYnNlcnZlckluaXQsICdyb290TWFyZ2luJz5cbnR5cGUgVXNlSW50ZXJzZWN0aW9uID0geyBkaXNhYmxlZD86IGJvb2xlYW4gfSAmIFVzZUludGVyc2VjdGlvbk9ic2VydmVySW5pdFxudHlwZSBPYnNlcnZlQ2FsbGJhY2sgPSAoaXNWaXNpYmxlOiBib29sZWFuKSA9PiB2b2lkXG50eXBlIE9ic2VydmVyID0ge1xuICBpZDogc3RyaW5nXG4gIG9ic2VydmVyOiBJbnRlcnNlY3Rpb25PYnNlcnZlclxuICBlbGVtZW50czogTWFwPEVsZW1lbnQsIE9ic2VydmVDYWxsYmFjaz5cbn1cblxuY29uc3QgaGFzSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSB0eXBlb2YgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnXG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VJbnRlcnNlY3Rpb248VCBleHRlbmRzIEVsZW1lbnQ+KHtcbiAgcm9vdE1hcmdpbixcbiAgZGlzYWJsZWQsXG59OiBVc2VJbnRlcnNlY3Rpb24pOiBbKGVsZW1lbnQ6IFQgfCBudWxsKSA9PiB2b2lkLCBib29sZWFuXSB7XG4gIGNvbnN0IGlzRGlzYWJsZWQ6IGJvb2xlYW4gPSBkaXNhYmxlZCB8fCAhaGFzSW50ZXJzZWN0aW9uT2JzZXJ2ZXJcblxuICBjb25zdCB1bm9ic2VydmUgPSB1c2VSZWY8RnVuY3Rpb24+KClcbiAgY29uc3QgW3Zpc2libGUsIHNldFZpc2libGVdID0gdXNlU3RhdGUoZmFsc2UpXG5cbiAgY29uc3Qgc2V0UmVmID0gdXNlQ2FsbGJhY2soXG4gICAgKGVsOiBUIHwgbnVsbCkgPT4ge1xuICAgICAgaWYgKHVub2JzZXJ2ZS5jdXJyZW50KSB7XG4gICAgICAgIHVub2JzZXJ2ZS5jdXJyZW50KClcbiAgICAgICAgdW5vYnNlcnZlLmN1cnJlbnQgPSB1bmRlZmluZWRcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRGlzYWJsZWQgfHwgdmlzaWJsZSkgcmV0dXJuXG5cbiAgICAgIGlmIChlbCAmJiBlbC50YWdOYW1lKSB7XG4gICAgICAgIHVub2JzZXJ2ZS5jdXJyZW50ID0gb2JzZXJ2ZShcbiAgICAgICAgICBlbCxcbiAgICAgICAgICAoaXNWaXNpYmxlKSA9PiBpc1Zpc2libGUgJiYgc2V0VmlzaWJsZShpc1Zpc2libGUpLFxuICAgICAgICAgIHsgcm9vdE1hcmdpbiB9XG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9LFxuICAgIFtpc0Rpc2FibGVkLCByb290TWFyZ2luLCB2aXNpYmxlXVxuICApXG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWhhc0ludGVyc2VjdGlvbk9ic2VydmVyKSB7XG4gICAgICBpZiAoIXZpc2libGUpIHtcbiAgICAgICAgY29uc3QgaWRsZUNhbGxiYWNrID0gcmVxdWVzdElkbGVDYWxsYmFjaygoKSA9PiBzZXRWaXNpYmxlKHRydWUpKVxuICAgICAgICByZXR1cm4gKCkgPT4gY2FuY2VsSWRsZUNhbGxiYWNrKGlkbGVDYWxsYmFjaylcbiAgICAgIH1cbiAgICB9XG4gIH0sIFt2aXNpYmxlXSlcblxuICByZXR1cm4gW3NldFJlZiwgdmlzaWJsZV1cbn1cblxuZnVuY3Rpb24gb2JzZXJ2ZShcbiAgZWxlbWVudDogRWxlbWVudCxcbiAgY2FsbGJhY2s6IE9ic2VydmVDYWxsYmFjayxcbiAgb3B0aW9uczogVXNlSW50ZXJzZWN0aW9uT2JzZXJ2ZXJJbml0XG4pOiAoKSA9PiB2b2lkIHtcbiAgY29uc3QgeyBpZCwgb2JzZXJ2ZXIsIGVsZW1lbnRzIH0gPSBjcmVhdGVPYnNlcnZlcihvcHRpb25zKVxuICBlbGVtZW50cy5zZXQoZWxlbWVudCwgY2FsbGJhY2spXG5cbiAgb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50KVxuICByZXR1cm4gZnVuY3Rpb24gdW5vYnNlcnZlKCk6IHZvaWQge1xuICAgIGVsZW1lbnRzLmRlbGV0ZShlbGVtZW50KVxuICAgIG9ic2VydmVyLnVub2JzZXJ2ZShlbGVtZW50KVxuXG4gICAgLy8gRGVzdHJveSBvYnNlcnZlciB3aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIHdhdGNoOlxuICAgIGlmIChlbGVtZW50cy5zaXplID09PSAwKSB7XG4gICAgICBvYnNlcnZlci5kaXNjb25uZWN0KClcbiAgICAgIG9ic2VydmVycy5kZWxldGUoaWQpXG4gICAgfVxuICB9XG59XG5cbmNvbnN0IG9ic2VydmVycyA9IG5ldyBNYXA8c3RyaW5nLCBPYnNlcnZlcj4oKVxuZnVuY3Rpb24gY3JlYXRlT2JzZXJ2ZXIob3B0aW9uczogVXNlSW50ZXJzZWN0aW9uT2JzZXJ2ZXJJbml0KTogT2JzZXJ2ZXIge1xuICBjb25zdCBpZCA9IG9wdGlvbnMucm9vdE1hcmdpbiB8fCAnJ1xuICBsZXQgaW5zdGFuY2UgPSBvYnNlcnZlcnMuZ2V0KGlkKVxuICBpZiAoaW5zdGFuY2UpIHtcbiAgICByZXR1cm4gaW5zdGFuY2VcbiAgfVxuXG4gIGNvbnN0IGVsZW1lbnRzID0gbmV3IE1hcDxFbGVtZW50LCBPYnNlcnZlQ2FsbGJhY2s+KClcbiAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoKGVudHJpZXMpID0+IHtcbiAgICBlbnRyaWVzLmZvckVhY2goKGVudHJ5KSA9PiB7XG4gICAgICBjb25zdCBjYWxsYmFjayA9IGVsZW1lbnRzLmdldChlbnRyeS50YXJnZXQpXG4gICAgICBjb25zdCBpc1Zpc2libGUgPSBlbnRyeS5pc0ludGVyc2VjdGluZyB8fCBlbnRyeS5pbnRlcnNlY3Rpb25SYXRpbyA+IDBcbiAgICAgIGlmIChjYWxsYmFjayAmJiBpc1Zpc2libGUpIHtcbiAgICAgICAgY2FsbGJhY2soaXNWaXNpYmxlKVxuICAgICAgfVxuICAgIH0pXG4gIH0sIG9wdGlvbnMpXG5cbiAgb2JzZXJ2ZXJzLnNldChcbiAgICBpZCxcbiAgICAoaW5zdGFuY2UgPSB7XG4gICAgICBpZCxcbiAgICAgIG9ic2VydmVyLFxuICAgICAgZWxlbWVudHMsXG4gICAgfSlcbiAgKVxuICByZXR1cm4gaW5zdGFuY2Vcbn1cbiIsIm1vZHVsZS5leHBvcnRzPWZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49ezc2MjpmdW5jdGlvbihuKXtuLmV4cG9ydHM9ZnVuY3Rpb24obil7dmFyIHQ9W107dC50b1N0cmluZz1mdW5jdGlvbiB0b1N0cmluZygpe3JldHVybiB0aGlzLm1hcChmdW5jdGlvbih0KXt2YXIgcj1jc3NXaXRoTWFwcGluZ1RvU3RyaW5nKHQsbik7aWYodFsyXSl7cmV0dXJuXCJAbWVkaWEgXCIuY29uY2F0KHRbMl0sXCIge1wiKS5jb25jYXQocixcIn1cIil9cmV0dXJuIHJ9KS5qb2luKFwiXCIpfTt0Lmk9ZnVuY3Rpb24obixyLG8pe2lmKHR5cGVvZiBuPT09XCJzdHJpbmdcIil7bj1bW251bGwsbixcIlwiXV19dmFyIGU9e307aWYobyl7Zm9yKHZhciBhPTA7YTx0aGlzLmxlbmd0aDthKyspe3ZhciBjPXRoaXNbYV1bMF07aWYoYyE9bnVsbCl7ZVtjXT10cnVlfX19Zm9yKHZhciBpPTA7aTxuLmxlbmd0aDtpKyspe3ZhciB1PVtdLmNvbmNhdChuW2ldKTtpZihvJiZlW3VbMF1dKXtjb250aW51ZX1pZihyKXtpZighdVsyXSl7dVsyXT1yfWVsc2V7dVsyXT1cIlwiLmNvbmNhdChyLFwiIGFuZCBcIikuY29uY2F0KHVbMl0pfX10LnB1c2godSl9fTtyZXR1cm4gdH07ZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhuLHQpe3ZhciByPW5bMV18fFwiXCI7dmFyIG89blszXTtpZighbyl7cmV0dXJuIHJ9aWYodCYmdHlwZW9mIGJ0b2E9PT1cImZ1bmN0aW9uXCIpe3ZhciBlPXRvQ29tbWVudChvKTt2YXIgYT1vLnNvdXJjZXMubWFwKGZ1bmN0aW9uKG4pe3JldHVyblwiLyojIHNvdXJjZVVSTD1cIi5jb25jYXQoby5zb3VyY2VSb290fHxcIlwiKS5jb25jYXQobixcIiAqL1wiKX0pO3JldHVybltyXS5jb25jYXQoYSkuY29uY2F0KFtlXSkuam9pbihcIlxcblwiKX1yZXR1cm5bcl0uam9pbihcIlxcblwiKX1mdW5jdGlvbiB0b0NvbW1lbnQobil7dmFyIHQ9YnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkobikpKSk7dmFyIHI9XCJzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxcIi5jb25jYXQodCk7cmV0dXJuXCIvKiMgXCIuY29uY2F0KHIsXCIgKi9cIil9fX07dmFyIHQ9e307ZnVuY3Rpb24gX19uY2N3cGNrX3JlcXVpcmVfXyhyKXtpZih0W3JdKXtyZXR1cm4gdFtyXS5leHBvcnRzfXZhciBvPXRbcl09e2V4cG9ydHM6e319O3ZhciBlPXRydWU7dHJ5e25bcl0obyxvLmV4cG9ydHMsX19uY2N3cGNrX3JlcXVpcmVfXyk7ZT1mYWxzZX1maW5hbGx5e2lmKGUpZGVsZXRlIHRbcl19cmV0dXJuIG8uZXhwb3J0c31fX25jY3dwY2tfcmVxdWlyZV9fLmFiPV9fZGlybmFtZStcIi9cIjtyZXR1cm4gX19uY2N3cGNrX3JlcXVpcmVfXyg3NjIpfSgpOyIsIi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2FwaS5qc1wiKTtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyh0cnVlKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxcclxcblZBUlMgRmlsZVxcclxcblxcclxcbkRlc2NyaXB0aW9uOlxcdFN0b3JlIFNDU1MgdmFycyBoZXJlXFxyXFxuXFxyXFxuXFxyXFxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyoqKioqIENvbG9yIFZhcmlhYmxlcyAqKioqKi9cXG4vKioqKiogTmFtZWQgQ29sb3JzICoqKioqL1xcbi8qKioqKiBGb250cyAqKioqKi9cXG4vKioqKiogRm9udCBTaXplcyAqKioqKi9cXG4vKioqKiogTGV0dGVyIFNwYWNpbmcgKioqKiovXFxuLyoqKioqIENvbnRlbnQgV2lkdGhzICoqKioqL1xcbi8qKioqKiBUcmFuc2l0aW9uIFRpbWluZ3MgKioqKiovXFxuLyoqKioqIFNoYWRvd3MgKioqKiovXFxuLyogc291cmNlOiBodHRwczovL2JydW1tLmFmL3NoYWRvd3MgKi9cXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcXHJcXG5NSVhJTlMgRmlsZVxcclxcblxcclxcbkRlc2NyaXB0aW9uOlxcdFN0b3JlIFNDU1MgbWl4aW5zIGhlcmVcXHJcXG5cXHJcXG5DYWxsOiBAaW5jbHVkZSBiYWNrZ3JvdW5kU3RhbmRhcmQ7XFxyXFxuXFxyXFxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXFxyXFxuTmVjcm8gQ3VsdCBaaW5lIENvbXBvbmVudFxcclxcblxcclxcblxcclxcbkNvbXBvbmVudCBOYW1lOiBcXHRGaWxtR3JhaW5GaWx0ZXJcXHJcXG5EZXNjcmlwdGlvbjpcXHRcXHRWSFMgc3R5bGUgZ3JhaW4gZmlsdGVyIHRoYXQgb3ZlcmxheXMgaXQncyBwYXJlbnQgZWxlbWVudC5cXHJcXG5cXHJcXG5cXHJcXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKioqKiogRklMTSBHUkFJTiBPVkVSTEFZICoqKioqL1xcbi5GaWxtR3JhaW5GaWx0ZXJfZmlsbUdyYWluRmlsdGVyX19mSWpoeTphZnRlciB7XFxuICBjb250ZW50OiBcXFwiXFxcIjtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgaGVpZ2h0OiA0MDAlO1xcbiAgbGVmdDogLTEwMCU7XFxuICBwb3NpdGlvbjogZml4ZWQ7XFxuICB0b3A6IC0xNTAlO1xcbiAgd2lkdGg6IDQwMCU7XFxuICB6LWluZGV4OiAxMDAwMDtcXG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbiAgYmFja2dyb3VuZDogdXJsKFxcXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQVY0QUFBRmVCQU1BQUFBL0JXb3BBQUFBQkdkQlRVRUFBTEdQQy94aEJRQUFBQUZ6VWtkQ0FLN09IT2tBQUFBd1VFeFVSUWNIQndrSkNRb0tDaEVSRVNFaElSTVRFd2tKQ1VkSFJ3Z0lDSTJOalE4UER6MDlQUW9LQ2kwdExlVGs1QWdJQ0o3bGhRZ0FBQUFRZEZKT1V3MEtFZ2NSQmdzRUVBRU9DUlVOQXhvRVFaai9BQUFnQUVsRVFWUjQyaFM3Y1ZSYTU1N3Z2UUVGc2sxNlFLSVlrdmJnbGhCbVMwWVFaU3MwamlGVUhkUlRyVFUweVRsNVVWUXNOQm5JRHV3QUV5Nml4L2lpblRianNZN3Rlck0yR3dTNjBjU0lnUlNxSnlGT2pxK2xZMDdxU1RyYTVLYlhrekNwYjEzblpycm1udFdidGZMdSt6OXJzZmV6bjkvditmNiszODhETEdSaUlUVHNhUnRidnI5aVpDSzdpOFZxckFyU01kaEZxRUVSNXBKN2wraENSUncxWkRoZlRCYXBuK3JxSEpCMGhiSDNCcU9RRVh4M3M0OW5EcW9nYUlDZDl6ZzFWYldudnIzTEtrNlQwYVRlQlExVTRackJkb0ZmM3hGbmswTit1VzRXRXdBTWU2ZmVWbFJTcWp5emZ1d3B5NkVzbnlUSTJwNE5ubzFsVDR5VjV6VjVFMXFUd2lFUnBYUWlneVVsUEgyVG9kTDJMYzNabHhUWUIvbjA4a1FlTUQ4eXVOdllIYkdQcldvT3ZadTBqZ2pLVUtkTXU2Y2h3WGhlQ0VJTVFYT08vdGE0MW1PRmlBaEthcEEyMWxhMmRiM3MzTDdPRXEreFpCazduU2dtSUFqM0Z6WXU2RDlZanZ5emw4UFlVV2xOazRLMXYveUxONjllM1hJTW0rd0VQdnVxbXdNUDZXdmZ1ZlY4WWQrbmd6T0g4K3EyejNvd2JNdWZYb0NNSUQxWStGVnU2M0N1UWpBd3hLelcyL3poazBMZDFxTk5FNllxY3kybmduUDVXenJzRjRka1VPeEx3TnhlVUhGcnI0NkZybWM4SDJCMDA3aC9CTXZUa2dUcnVxY1MxNGdVbDF4UTZWNHlkbE40VVNPcUh3c2M5Mk1qUTVZTlVwdkV1R2hVK3FKRkYrczIwVHIyVzY4V2tyNkh4eTZ6b1NnRDZRZ2xMMlJBU0loR054M2xTdktoOHJNeWpGaTVFYklVTDdmNzh0dEdDditxaWFuQkFxV0doMWNrVTVaUUU0UHIxZ0p3TmFwNlRhVjVEUnhuMmMwUzNYRWFQdTUxTjJCWTduNnk5RjB0a0RRdlZiN1dEYkR0cEJhODVSTXJ3ZFZ0SDBZZlRRM2hTaWpHVllVTHRxSkZKK0huaWhtSmhEVDJDSEhMR1EzTWpxRStobEdtdmc5cE54Rm16Z3hwc25DQjNBbHlEUW5HSTAxekI2bm9oMFpJMWpnTldjaHdtU05jODhQSkJBR1Z6YVdPWWI0K0oyUUE2OUdLQnE2dmcyVHFGQ21jMEJIbDk4TUNiYmhrSUd6VmdnUHltUFhES0NFdXdGREZkY0U5QU1RWGhPcm9hMXZ4eFJ2Rm9EOTlZekcraUtTQTBEMW82ZE9mNlg1SUI2ZThjWU0wS3pJdHdLZnR5RUt6Qy9hNFdKUG5WN2drenZnZnQwdmd1aFRPN2QwT2VmbW9XekptTVg4NDdMRUtMMEs2NGk5c3Z2cW9nVXdUemViUW9FcmpONWYvYUxKOXFEazJ5UmFhdjVoQ3BSTGhtZFgyZEdCbkV1VDR4TG1LMWQ0VTlxeVdSSTZRTFk5M2Y3VXpGdFVHWFNLU0hYdFFvRnF4WlpmTjBBbCs1VERmbHFDVmtOQ2ZTcUNJdzQ5d1BpbmplamFXNkkvUllxQmdiR1ZvQzZwSGRab1ZUQlU2ZUNEejBlM3hnMjdWYmF5NEs0UU45QmlnZmZJT3FiQ1k3T3RaYnNiZVkvU1Vrb1lSYmpQYTVhZ0grRnZGajdwamhZMkZzZTI0bzNueDdaY2E2Q2cySXAyTy9EbXJ5MThRQlVJbnZ2eVZ2ZllBTERjRXp3MWFucnNkTDFuQ3JabFZQV2JnNE16YUtrbkxvVzJZNzg3M3lNSjVmSGtJVnQvamNRM1JaZ3dGZmRCQmF3QlRTeTNZeWRMUG5IbVFrZkFqZTQ5TmduRnpBTmpreElqMUZSTFRoVElNdDQ4bWozWlB0eDA2ajlJOGRGMm9mZVZNS29QenIrek8xQlBIZnRRWnExVlJtQjNWUWdwNE1lblFWY2VlQzlLRWZ5aVloK3lja3RVLzZMNjFPRktFRnIxblN1K1Zab0p6STBGRmUwVjVCeUl6V2YxQmF4ZGpIQ3o1Q1RBK0dlSVdZVEtjclgwcjVaOHBUUURGYUw2N3ozU1Q5V2ttdUoxRkpKdks0ZXQ5Z0JreWJmTTZ1Q1JEM3RGVmtzNlFCdUY4QWE1UUZKTytET0IxYmdsYWJnc1dkY3lRSkM1ODkzM0JKalp6VUthMzdaZEtjS1YwbjlLM0Z2R29JTmhueE96amZ0N013VGU5MmlZdUpIMmM4Q01CTElwcXBMZm1ZamxNSmR6ZE9QbUZuWXVsa25hRjFaL3dhUUhBaE0yc2tEUmVlc2NxQVZnMTArZFdzbzNYbGs2MjJnZmJ0MHBWbWxhRklZcExrRGt5dUx0c3N2dndQLzU4d3JWbWt1cXdrR2FZLzZrd0owUDZZWVNRMUxsV1cxNmNMbVNkYjVxMnpzNUpvQXd3MFBzSmdzL2hrQi9pOG5mbnF4NUFNQ0E0aXZYQXM0NDdibTdCODlBdmJoTVN2anVJblJRdllKSzZIRG9qbGcxcHErZGJ0WVF1OGhrWllFUExabjV1b2JYc2ZPTmtLdXgwYURTUXliMDA1OWJvQU5BM2JGZEIwN3Z4ZkFIcVhhUE5Odm5CS0dEeEpOTG1HelI5bnlKdWJyYmg2SFZ3WU9iMkZ1VHRoa0Z0UFlEUDZJZFJvUGE4RUZ4N2Z6NWpYTWdhUTZ5M000TWpkcGJjdFl3UngzcDBBRnhrN3pDK20wK0h4N2l2MVNBbERBSW1sUTA3Ni8yamkzOXdLRjVQc29sZ1NyaGZZWHp1dXR1ZGY1MlhibXNOVTgrNzlJOGlDSmN5T05YR2xCUUdJWU5HRnp6SDRuWi93NXNMaVZvaWswbFplclppMUNvTm9tWWRjZzBxQlNjRzJHcElHK1lreWI2NHhScFE0Z2phVlN3b3MvcHBvTzQ2MEZYNE5WNHlmVFBENytBQzNBQm1Wc3h0aEtSZU10eVo2QXY1alJWOVlVc3FZdDl1N1lmcUZURkFpNzEvSFBVdFdYVSt6cWpUWHNLdjBzWGJEdVVhWEVHaTFjeHQrYTNxb0JWREtvOEtDdFE0c1dyUDI4aDdYQUxlaTdQTzZhQm1qZUF3NG1tVDRvWlhRMDJrdUpJdjZrRkMzOGlDZjQ2TWV6bWlaRVU1dHJESmxreGZ1UTlCRXBRMXRRMkpjQ1FYS2hFWlUzekI0VTBiTEFERjlLRVZRdmdqZjN1c0VUaTV5MEhzdzVSTGhJd1JTdFRPQk9RVlpWZnN5QTZSZ21Dc0J3dUZGY2pXbXQrSEJBRCtKQlBaaGhVRkRxaXpoWVZ5MlNHSjZmS2hqeUhOZ0pyZVRQOGEyWDN3bldIUG13K3RVSnkrVXZHWHdzZnVManJFY252UXhUNk5zQTJ1WDdLS2JRR1NkNU44TVIrcFBtbTYrRkJWWHhNcldZM1diL2kwbnp1TTcwTDRhOCtpZWRKQlYxRFFlSzBNYTVmcWhoTGxNdHArTmJzSnlMZzF5YjNIK2pXNzJzSzE3VWhISE0zTGdLd202NldTZkdmRkhiUmx3Sk5TbS9tTFhyMEtlbWd0UGFXek5GbkxTbkNnR21VNlZhSnZxcytMcjN4UWlnSUFTRVJVUW5YSnFqUkdEODU4alkxTlc2SGFkNWFzWGxCSHR2eGtScWl6cTZrQTJlS0tNQUhWZmFCZ3piUURqbmZPQWFKSGlLTGtRM1djRUt2Q2NxMUlxeWthTXFJUzlYMXRLeXBha0FqZFFDanl3U0RLN1JIdVQ4UmtFRTBwVXJGRW5ya2RRUUh3d1VIeit2dldpSXVCRmpmNThtVUEwYUFmbDBiRzAzTmhMVUkvc1k3elN1Q0FuZGFoZ1kyZnZUVVRCY2pyWE13SE5lZDgwNWpLbTZPendpY1pHdWxyYVBDalZYTVJHRTFDZW84MGNqSU8xTzArZHB4Y0Q4cDdKNmhOZGVLSDFaZDZ4QjA0TmVLbDU2dXl2WUpoN25GV2JxRUp1dk5FMnVpQW5lZVdOUkFTUEpkOEZYSHBRalJ0UCs2dmRXaG4vMGdLR0ZhaFBtMWxyaDFWd1orK3orWmpxQmVjL3JPUS9PLy9WblhvSEMzbXlZMlYyYjc2NWNHcEtxR3RDR3VEWUtTUzM1ZW5FOFJBbGcwaFNUN0tDNEdBMk8wSDhINS93bzhEdnNpT0NuODVlUkxDdXdwMjNQVy8rMXlnMmtmd3AraUhaU1RYYzg5V3dQbjJEUU9XeTVHc3lYLzRYNVV2d1JHUzJIUHN6ZEl0S2NMMjBYQ3pwU1J5NFBiM1RIM055dnUveStEM0c0cE84bDU1Y1F5VGdWb3YzOFVmYTc0SlFWZFZFckFKOUdVWXFQRGpCMWwvYldHbTZVUlNGcEx1cXZ6WHk3d2JBbjBVZ25rWXh2dnZQODNjRVJSaFN2N2ZYWDN1U0o1NzBSWEFaSzNmK29Nb0R3SEkzRmg1TytuenM3VnJPaU55TVFBcnVvR1lIRWw2U05VMHFjby9UaUxzNFFRSmJPcHF5cU1KWHV2TytUaFpwSGp6RDUrK0dzT2JmTWlJUnR6NVFhKzNHNUFBMVNWdjdTNVYxVTdTSmNoSjNmNDVrZ25TQ0lpaE9CN2xDWVJZZjIxSjhBT2MvVUFtZ2NLY0lXNUFRWDY1Q3U5OWVPMG5BcW0yaDNUSWtXODY0dFZLdlNyRzVIVml2QVc0KzVCcS81S005VTRzelVHK3l4cUhlbyswZmd1c1lKMDVvQVM3OXF2TFhrSTRyM3NWVkcyKzB6aEpoeWNCWklLU0ErSnVYUlJTYTJMZmN0UFhvMXF0Qm9Zczl4dXczNjgrb0E5Y2JCaC9PVk9ySlpIZFB3TkIxMGl6Q29UZW4xUjV5UWNFYTRJdXhNemg5cVJzNUVQOHgweXQrZHFxNlpONm14aFRnMUMrbTFTQWVEck50ZnRpb2JmdkpqK3g3TDcxZWxoK2dnano0bHNXT1JmanFuYU5EeDdZWi9kd255YlZpNDF6ekMrNnFYWXA4ZUdhNFhTVTdKQ3k1cjRIQ3NFR2VYek9ENXVxTkNOaytCOXVkMVc5NVhUdDg0Rkl5RUpjRjMvMEltbVZxRXcyQmgyeDlPQ3hlU0dqVU96UTZqWENIRFJ5b2tjRGtFeWlMRGREbFpmV2RGeU5vS3VWTDUydUpLMG14bjVERlhTUTY4SnF6TUZYa3NucUMwTEJpblM1ejRjcHNKWlNtYmNLQnBsOVpwSXBvOFF2WXRNTTFjOWlyMjk1OTc2aVo0Y1pIeFJ4KzBzL2szaFBZN20yWFIvQW9Hanpnd3ljd3VqNWNwdGZod0gwcURnUk5rTk1FeG9uTW8veWdpTUMwbkpmbUIzWmQxSVhVdVQvWXVVYjFRaU9BSFp1UjFBMUp4UVVYUy93WGo2TVBXTHoyTU9Jb3drM1dTRWh0bnZGTW1kVXBKT29QUk45cFQvUUlPa2pvV01sWXBSNFJNN0dFWlErckRlK3N5SW5vVHpJaTdqVC9VS09hRjJIOCtod1g1RTV6MFJudWVlRzhCQUxsWWZDMlo2bXNGa3pVSk9CWGJlS09zQ0N0b0VvandNOTJDM1U1ZEVFcGRWdWI3WVBDRzFBQlJLL1NERmJoNm15ajFoUGlRRnF1ZFpnSGMveE1zWTd0YTZHbXNCU1ZQakpGMVdyOGtVSjAvTjlETGZCbXp0dkNqbmh6VWtsRTNGRVJjYTlRazhPY1RFZXVveEVhVWhla1lGWTk0ZTBnT2o2a0tseVdITndYc0lETnlDSjg0TFFEY1dTcmhXc2o5dWo2OE81RldWYko0WnVzZ3JmMmtIeHRLQU00L1JFenZUVm9TbW85SGQzb3ViSVZHRjJwYmlwTjZmU2dSSkxOeXlTd2FkN0ltTlNBTGJCSWFvb1ZWTFRMRUlBdWxrUmJlOHRTbzhhYjI1SVRUMnpHcEUwTS9ybVYxaFY1SWNYMVQzUzFYQmJzd0VmYTdaZkd4NzRRS2gzZzRrdnF2ekcwSm1HemxrQzNzQVJXOEFIU0VXM3BqaFkxY040SlN1TVlZNVNEY3ZoQzlVcjBHdXJSN0dQNnA0STdjZlFsZk5DeStudlROK2Z2cWtselovL1AySFY0NjF3bmp1emgrMExtSGtwL2ZhMHpPaVF3OVZxOVRwMjdIenJOcXRIMm9ncDlHZ1QzeTBGeUFsNC94d1FaME82SVp3b1d0d2NpcElXQVg4VERXbER0U0V6bENWRUQ4LzkzRmw4YjJNVkJSYWJSS0VCa3BTS0xXODNqRmJ4V0Z0UlFWZ3hoKzlmL0taenIwZ2FOdWRmTHZWeEpDUVRhZVBaUE8wOXlRMkx4NWFmNTBSOVpsRkJQeFRXZFg1azZUTXF5NnBLUHhVYTBjU1ZWTmdoN21ZMnFETUxuenRpcWJrVmM5Yk1NT3RkakRpbmM3UXlBTDZSNjB2YnZ2NVJpeUc3SlpZa3QzYkxSOU12QWlWbzZBdWJDR3A5MUFKQ1E4bWRuSXlRdUZkT2IzNTZHT2p6ZUM5N29UQ0l5VFRlTnlxMXJJdjVVelZERUQ2aWtwQmhOazVUVE1iY1VZN3ZvVU9IK1ozMms4MWpaZWRLUC8wTE5ldmdQeDVyeXp5Y1ZKVXZya044OG9UYmJWcmdRanBONDJTL2wvMnRVTEgrb1RTZjZuYjl1eWE3Uldod25wUnVadGYzMFFldzZEM2dGVnFYY0w2ekF0RDFPdnEwcTl3dWlwZDg3WUNLM1BkTGErRCtRUStvaWVXQTNib2hNcnkvWmNrdE5aZTFDUjFlZlJ0RXE5a1hWWW40cmc5alQ4cXdLcmpZcHlWTmJ6Nll2aXgwUUV5MnhBTHc5ejdFVUxhT2xCNDcxYVdJS2l5eVlXZlY0WGFmYm1iVkpoRWxyUVVLcmh6U2JacGhRMzBuMjRzNE9NRUZDUTg3OC9DS3Fwa2V0TVUxczhUTVMxemJja2xtd2RKdFJIWklsSG5MUVVZWldONVI0R1N6TW5LT3pJelZBbnd6aDlILzEwWE5DL3FBNTdrS0FHQlVFNk1oUkFDNDZSTUI5V3J0amp3azMvZXBid2gvbUFOSVlyb0oxQ0J5d3JTMUI1a3ZsWStWTWR2QlZDbEtGcTRpSFhTamdDOHpHRkYvWG5qaHFDTFJPeGZFYm9yYk5ZMmYrRGFHeUQwcC81TEtYOC94U1RPNk9YK29lYXBReDFHRUhoRGhSTFhoQWFKOExkWDc2ME9wWWZuOHo2bVJFWHlzRVkxZGdEUFZNL2hSbGFYbHQyaURvdG9XRUJ5Ky93MHRqOGsrbTJpbjlNcUNDTzRQbU5BNTBPdkZTaGhkbm5raGdKWklrazNzNFBobTJwN2NXL0xWVXo5cUtIelJCNGJaZmF3cWxtZStBZUIzRkg3ZTV5b2pHdFFHbjlqcHFjdy8yWHFkbmlGLzY2ckxjUXBjSWtYcHpyeHdmam5wYWpVdzVnNm5nVVVSQkpGclVDYmdEbXRtYjhoSmVxMEdsMkthREJsaUpKTGIxeXZ1T01yUXJVdFdNbElEbFZYaFBjR3dzekpPbEN1bGp3di9kY0tBS1FpZGxqV3hYME9VM3hqWFFGb3dqS1hYQnlzYk5CS3l0OTBqSzVxREFUZHNJRjRSZkRUcFVIeTNETEJ5SlprMTRCYW1HbFNKV0pQU0xoQ0o3NmdZemhRQnIyQVlFYnVKY0tJeDY3UWRxWVJONzhTWWFlZTROc3M0Y2Y3dVAyWmdUZS9OUVhCaDlmNEx3aTkya2MwMXJGd0tvcjE5Q0kwV1hYdXB3UmxFT3NocEg3N25MaXZVbHBYd3p6ZjdBbXJPdEVQVS9WaHBTVzJhU1hZMks1R2NwVGR3d01oSlAvU1cxcG9KWXFrcytLRjN2TFVhZVVlZjliWEM3TUQzWWtNTGtEYlFCQzkxeGRXZTg5bUtPL0w5TjJUZXNhSXVaMlhaQitKMnJrYlgyNG1wOFhpaUtkRkhPekZKblAwZVVleHRCVmx5dnN2U3RWL2FrTDdoSmw0RnFpOEtxM0M2ZExxZmxWSUoxMThZZUtPNVBwNDh2dVB5ZzJ2LzFBYURNejh2Q0dzcndjWWFUSE1NRFJhS29qaHowVGdTOXlqVW5uVjJaSXZKMmRRVjBDRmZGalFkMFlZQVl3MU9tbEliSXhMK002aTduQ2pPcTgxeDVCbHlsdmxIV283ZVVBVUViWmR5cW1BM0kvZmxxNkZhZHlnV24zSmpHMzhpaGl2Ky9uTFc0cSt6MkRTRDFzeFBrOGo0VzI2U3Y0TTUzOEVsdlhTZ2VwSitkbTB6TVdRZ1FWMGZRb3g2eG9kdy9JUWIySy9ZYzZPRGlYMTc2ckVLYzRVMXNINzM3Umt2YXlGL3FuTG9VQlgyM1NWNXpVRFhnVisxTkg1UDhpZlR6L2hLQU14eGdRN3RVcis1VnBwczk4eHB2WDBFYXdwdGh3SlNscU9QS0tVTDUwMk9CbzFQclBOZ0hjNExEUk1BQThGT0ZXQ3AvQzFmRVdiekY1YWh3U08ydjU3SkRJbWNFd2J0WUNvK0wxU2tzYUdVem5LRUNaaTJsRkh0dzVPUmtHM2YxTVY2a0hWK0pSRjFmdm1IU2ZyVjNITXNBU001T2NnTWRFajFxVURCenNTQ2xxbERWT2pvZmJGMTJPbkE5WEt6bVdDUmVrL09oaXpiWmhNRjdsa1VsUFFXcGtsZ0tsRkhjRThzN2xUK3lUWWtZUzdpamdMeXYvM25LVVVxS3MzZ0k1RDJyNys0VzVsWm5uS3ptNS9QS1FBYWI0N1h2T05XTE1DWXVwcnM4YWJOcGdsb0Q1U25VMFljMlFDZDFIVmg3WHl3cG1IUFBhamdVZnltQ0xyMDZaMjROWUJRYjhHL0FLdUMvZXRsSFlEZzN2N1RXMk9YMEFRUVZyTFdwc3lNb1FBV29pVGRvTkkyZEIydVpHSGY1K2NFdldQTFRDaVNNazJoclcyaVBEaXZqOGFoQlFyM2pFQkZhZDZZcjhDRDJKb254aVMrMTNwNm1wa1gvalhISWFYTDYyUTlQWFA3VFJqMHg2WlFZck1hVEFCblZKbHFJV1pyeTNyUFNIZTFQY2piZkdLYStwZlhvc1hhbWY5MFpjR1JvVVBXMmsrWEEwOTJMVHdZaTRYZVNvMWUrK3JDTFF5VXRnWjNjaFlGdDMvWDJtci9udW0vVzVZMjVqNDRhUFh6dUs0L3pOaU5jek12bU1GM0llbUx1djRzaTRENHN4ajJEQ3FhZ1FteWZ1MHZPKzY1Nlc3cExRSnR4aVo4dUNFazFWRWlKN3U4bEQ4RllEUHd0Yjg1RWcyaS9HZGN0bDlhdGpWejU1eHdpejl6K09rT1pnZHo5TlUyd0V5L295TEQ0TXhMR0pEV0F4c1dlem9WUE05NmxRcWc5UUs0UjZ6WFYvWXExbWxLTW95eXhhNWZiWEVyTnFVRHFhRWhrVnByRUNXVkZobXhXbGhBL0JaVGxhY0RKMjVHSXlpc2prYURlYklNekhJMUVPV0tZcWJpaGhXUE1qb1VjMFA1YlN3TUhkT0Zlbms1Yyt1TjlqTkw0MUhmVVk0SWtVVk5YSm5PaVNMZlVTdFJ0WG9qamV4Z2hRTTJTYUFZa0dhaXZNcmJkS09kYXJEaUU3OHVQdzZNZ0VFNjJTVm91VVVVRldaaGM4d2hYQmRkdTVSVnNWQWlpRjgwWWNmSGRKZk80N05BK0ljZzcwbjlqckxGR09YdjFvM0ExT0VLV1RqaEVnVHdKZW1EMVZ1aHBzRWN3VXRpK090eDMxRk5yb0QrMi9IckVETmFaRmNnYlhoZUdjcU1DMWlmOEovYjhQWVA3ekdUUnpheHR1V1VrYVNMNVRqUzVqczc1MmpGYnZvMUE1MTVHMTVMZ3E5R28wRzNabkE4VEVEdy9wbURiT09jQ0NDR1dSZW1aWUFrM2kwU2VyWVhJbFZPRndTRFpFKzJ2bVh0YitVQ1U3ZjAzM0YzYmJ0bUdicjBUaE8wWko3LzI4a1VoSUJoM29TejVBSEJ6T3pyU2ZqOFdxL25TUWFoZFM4clFKK29MN1Iwc2RicWQvWjdSZGlKeXNNN3FreDBKUCt6cEJtM0xEU09DLzZVQzd2TmFGU0hQWjRuN2pnV0IvWm0xLzZ0M2V6TnYzZ1BGSmxtUXExb05qTXdRVUM2SllJSVpIbUd0Q0VLWXdwQjRIVlFWOXNkbzdlbUNSSVc4TmlBOFV4S3hIQStQVjZBVEFUMFBkcFN4UzkrcW0rYnZmOFRBVjhNR0xSSHg3MXkzRTNYU3VwU0FKSlQ4am5kaDc0VFUxK3VoaXNWaGo5cE5rZWhYaGNFTkZldUNCbzRFbDhEa01lUUcvaXUyejBIUDRGUzRvcm9RYXdhd3pTKzRXaGsydzVxajAzMmxQeWtWZXNVaE5Dd3ZWSzlCZ21qNFRROER2UXhEWDNNWkJ1MWwwRXdpeTFDVGVTcnVRS3Q2MUxLcUNMdTdxQnNiY3kxK3NocjFrTFNjRDJBbmJvaEFIcnRzcEJKUlExWmoyam1pc3l4U1hkYkJncHVVZU9LTDE3VWpsY25vajdLRCtmbk9nVTBJdGlDODNlUURnRUVOWFJZUUE0VVlJK0V4THU5L2o0TzVWUkREUVlTNEkrRDhZTEs1U2N2c3VnMFdseTNwWjNqTlJWczZEbEQzdVJKZ1ZiWER1dkpFci9yMVdPQ1N3U0krbXpCSTUxRHdqOWVJQ0I3dXpNOExaVjhRRnBxak5VcStOOTY2WkEvdnBNZ3cxYmhLU2ExZzNVS0VmQjA4ckZLT2l3Zkl2eVE5aHZNc3ozelV0dThrOE1XaEpqaGhnTm53M2EyNXRDV1dhUkZDaTloazlmZUNxZ0M0MkZzc2E0UUZtZ1BuUmQyUlB2cWl4UFJNYWJ3T0FnTkZsSm1rN1lWUWM3dDJ0YUl0aVJlankwRTVoLzMyakR0QWhTT3kyYktVT1RIMlBoZ1cvN3ZoTys5K252bUJISGlIMTVJVnhPcm42NVFYd21IK2ZkWDZuS0RObk8wb1FPQ2RLeUxHaDhFeTZqWlJkL041WG5jSktKSVlrMUFOS0ZkZTNtcENzS0pEUG53eDJNN3JveE92Tk10bXE3eHQwUnkxbnlDakE0ZHhzeFF3UWJUVE9PRVJKaExPTlUydkhWQ2pxRTlCODlUWDJTSk9nR3MwOG9vQXlVQ1NyRXRTcG9LZmMxb0hpVDJlTFlZVDlQWUJ5dUp0MitSRDllMWpaWFMxU0pQampvdjF2YWRqOGlJNW94THFMZmlhOEk4MWlRYVpWRlBjS05xN1c4bXhRNmQ2eTBCVFFETmhYVFJ0V1lxdnRpZmJvR1IrYnQyTHYvWGx6REFRR3BldldRc0FONFdHbUJaV0kyakd0aWlQNUF4MmFUU2NzWDUxMVJOL3ZwaUk3bmZveHBWK2VWTStPbUdOOWZSbHloU1lMbnUwbm00TTcyalFMRjJhdlFNSTZvZ3hqdXBEZGVlbFA2VGExV09vNXZwT1VZeDh1WnFueWFEMS8wbWV1bGQ3ZGhCenlTMjQ0Sk8vTXRqMHAzV21RTkZPemVYNzBIQmpnNzZMZm1lZFpNc1JQSmlWYUtPT1FnSEFMSXZEOVRHOUFwTXZFaThmTU5WWHcwaTg2d3RZQklFeVhzZ2Z4d1dPVGw5WmdLeVVHWEo1Zml2NjZVU2taOUtERGphbzNidThKWGN4RENHNy9RSG43UXl6MS9LUVdFRFRVRWY3aGVwaEJoSmhCbHQrK0hGb3o4Y3VySUZoR0lLakVScXlxZEszdnRKYS8yWkxtNEwrL2U5MjZ5K3dXSFl3WmtnNGk1Q1Evc3dWeXRrK2g0TnRqZE1IWWk0bGlVbDRsVDI0RlBpZldYZDcxY1pLYzNvZkNZTEt3N3ZkRk9KblZtRENGV2NWd1U3UHdwSjlJdkpHdUN6L2laUjJuZDJnb21qNGJsTWV3VWNWTlpldUNVNFpvT0cwM2lOZGlUWUEwVEdkU2h0VW1RaVU1QW92U0hJck8wellqZGhhampsY1dRK0dyZ1JzRy9nZTlKNDZxcURoeDJKczNtd0RDOW1sVGpFQ1JsRTFpdllta2JiWWtWRUx2Zk1pSkUyRFlNT1M4Tmh0cUkreW1WVkN0VUVEV3k1ZGVHU1NuTzB1T0M1dFpYSXdMRTVpQXhSMHJkVlVmSlZqc1FxNi80b3grQzlnVFBtWWYyVlFoK2dVRUhoZFRqT3N6RlJJMHB5cFhqRVpyeXdhaDYwY2J4Smd3RHlYN0xHdTJTNlF2SCt6VHB6SGlTSzlZeEFVcjRSNHhUUCtKdGlwQUEyazRBL2ZZK25PdHdsMkpUN0VYTThqMGFHZFBSeTBER1kwL3I4TkI3N0RNeDEreGk4bXNIVUtBYjZZbWJCR3JRY3RZUTVpcmlBT0h5ZFBab1lHQzhpUW4raWswYVppSUNrRFlBZ2lPWTFDeDdFUzFabGxsTjAvaC9iRmZrdUVqYURZWFdMRU5qbGdKQ3hZNnJTandjd0RMc3NDYmZYbTRkUEFmNzlubHcweGlISnpsNVU3OHEwanBXTG5KTXBHdDA0MjdQNjdLcFZnaGROOW1lam9oVjZxeElLUVNzVzU1cy94WlVhUkJQVEdKVTBGV3dlcWdmTmtWeFdwNkgxMGJhbHExaGREZVBObisxZ1duZTgxZmtwN0JNZGhmZzdrL0s2QS8rYitoZm4vaWxydHVkejJVYy8zWnVlaHlIUmN1ZCtyUHRYTm91bmNHeWxtc2p3eEcxUS9vN0RWMDlBSXY5QklFSkk4dmN2MmNrYXFCVERadXIxcWlHTkdFc1pBR2ROeTZDR2tjTThWbnhXS29KZ1JmQTNuRElIbGFIeUpxbmV3bXppMGxld0toUGJTeHA4a3QySDJrS3cva2NvUnQ1QVdhNTZjN0FUUXdteHB5YUxGUDYxRTl4ZSt5dnFSK0lkOXczKzBDYk5USDFzU1Z4QkhGVmZUN3E3djVvODhrZTVmNnVQaHFreEJWdUhWRElDZEVua1BDbXFwN3dMbGZRV0NKbzQxNm5oNnNUay9uVTROYWhhQm96YWtJNmZVM2FBUGovMVBmNDB0VHNqMmp5TnFzbWlVQ2dBOG1YNU8rbGk0d2NpWFFoZHlSc0p5dUtlNTZnKzE2Tmphb1NxL0FtT2dxdWdkQUY4NFM1ZDlFZm5OaUVxY0t1L3FZTDhyYlh1R0JIMEhMZzdVWktwcHJzcnl1eUVLZDNSRi9YdlNaWGJnSzZlYjU2UHQwSFNvRjVHUnFZbTI4THdWaFRwU0tkWkxxOWVxV0RLaVRCSEF4dU00MkVPRkJ4UjFDa21tZHFqblV3c1Q0anVjNGtBMUNMd3RYYU9ZWUQzWWxsaGdkTjI3UVVaVDA0NXFEOWRCRHhLNlMzMzBzN3pLbUR6U0UrR0pub0dTWUxPcmVseHFRaElDMDg1WFdXNFoyZkhpSXJja0ZiMDhFcXVKdk9XZFdoUjFBSko4Ny83aWRSWDB5TXU4VWFRRGtocU82dUdtWVdSRUxOdS9pdHNhZ3Jkd1ZCVTlPcjljUkpITU9mdm1wbVRNMG42NCsrK1RvV3I5VXJ3RGVMQXY2b0djeDdyTWxYUVpBZk5jK1Y1U2RuSHJ4eGlRRkV0Q0FJOUQweTc2M2U5Vnk5ampBc0o3WWYzZlZUdGVkeXlpa045NXpQR3dtR2ZqcHBSM1FUVWpEYlkxUXZpa0hmR2VQQ0hmRnNNVVFiQUFJSnQ0VFFlSmpqVG1wZmhvOC9QUXoraldpVmtqTExPdEFuTm8yL2V3dUpZcXJ6YmQxdW11UGF2MW1YTkM2eEhMc1JldjY3bzBTNnhoMkE3SHkzbUVzSmYvd0ZOK1pqOXJiUTZWUlRuMHV4OWhKYS9YZTVJQzRKSHhrU1BvaUlQK0VVaG9vS2lRYXp6SmprQVJMdDZaMEtsZGkwMzNoR25qOEFhWmxCR0haMEo2YVdRV1JmMTgxTk5vWEFmMVY0ZXVwdmxpbEIrbm02TUoxWVZ0U2V4ZDh1SW1NZnV5c0FNRmE3YzdMbDFuT3hzOXduMVNtN2VFb0NNR1I4UUsvT0hIYU1LbEVQNEJndUw1Z2NFelcrL2lFc3hkb0E1Rjg0VDFVSDdyN2VQcGdDQmRFVzFhMUpuR01vTDhCeEFDR0RUc0lWaWJiV2RKMWVReUNuQlNGeWFOZmJBdUNKRkFqeUZRQ1BKQndEYVhtRi81b3RVZ0JQYnVjbjdJeGU5OUtib1VkZWlsdFp5OE1ydU95aktIdDRhVzF0bTVVS2dmd1RuUmZmMG9oQkpIYlkyK3VPRXd4UnQwK29HZm5uTGVaR01uRi9CaXd3NVV5NnNTb2RUYThJekk1ckl3b1pFNjNRTkRhZUIvQ3Z6WDFNMmNkT0lwMWRLN0lJQUFDQUFTVVJCVkdxRnZ6M0VvMHdaZmFJUDEzaVBrQVBPcVltSVk0UFl0ZkQyVnh0eXNJLzJPcVpsYnVhcTdVeWt6NGxpZEFsc1d4UE9xcWdrRklMcUpSN2dSdFNpd0JhWDZBMUk5Y2tDVUcrMy9lcUNLSUdIVS93amtTdldzcXBldTk2ZEZhcWJaYk5SRTZnbzhadGp5cUcxRithZ3ZPUjlLMS9sUit5N3haMTc3KzZ3T1l4T1hJQTRYUVc2dmY3REtVQ3JaYVQ4WGR6cXhQWkhoN01QN1J6R3pJcmFIUFZ6OHdKNlpPcDRFbE9nSDkxV3N4eTBVdy9nbk1lc0FPTDlMSWRVWE56RTFLcVRtR05rQko1Qm1yZThXTUtKMGtYRENpSllWUy9RUWtaVmF5MXd0dVNxQXpsU0VINTlpUU9HbXl5WTREWFhVQUhkS05jcmFZcDJoZ3hHTzFYWndZdkxpZG4rMTRwUjZsQTNocG9xYmhrSlJ1WGZ1MHNMOC9YNmZsM3l4NS9pQXZBTHQ1eXBDTnFZbkFBaHlrdk8xVHUzZFRSOWJtNWhUWnh0ZHNxWUhGaWRJSFNBSmxDTk9TZVJ6d3JVTTJMQndLbStUbVZERHZIYU9YeWJoWU5IdTZJc3dmNTQ5ZmxWWXVVallibWRWQVU3c0NPZ0g2R0hpK041TFJuVE8wSVcwTmpXU3Vnb05PVFRwTlF5TXdMbEUvd2FnWmpBOHR0QlFnVExUNndSd20rek92cEx2dFlxWm56OGVRbVQzK0lQTVNQLzE5VTMvMjBMRXAzNEdLYXhHN0FGQ1ZlSWhXeU4zYXNuME0vKy9RQUVuWjJ3T0Q5clREbkhmWkRVNjRQT2NqdXcyZHg5ZnhNMFdyTHN4SnpWcmxiSi8rR0FZSjNDL0JCTE02WnN0QnhueEZUaVZlMnlNVlRjbWRzSmYwWEdXeVRvLzd5UXRaTm9FNUpSVnU3TWR6QkpRTk5BdG9uS1N3TUN2RDBOcTNydHhXUjAyWlREK3NHeUtzcUR5Qkw3dEpVUjFOZ3RHZHpSVDdaN3gydnBaRWlrYWhDVUhyOU90dTRRbVVEbEM5d25LckJLK3VaRW01Y3pRK1VUbk5CMHpkRURmek4xa3QrZGdRbzg4ejVSa3FBUzVraGJPbDd4VzZ3TGM1aDRUdzJvbHZUWFBXM1hqZ2kvL0MvbkZYdkIweERPd09iMkZCSGUvYmc2NnBNWXNMbXg0VVJYWENXbDZVN1lrSk5aaXpsTWprV3d2cVlUZ0ErRThXS0EreElJVWNsdnZNT2l5aTdGM1lSb014SFNLY2hIeWNWK3h2NTRNVGc2OTQzVDVYVXppdk5ncmFaQkRzdk5Yc3IyMHNCbWVHU2tnV3duZVhMcFEwSEZxT25pQ0VtbTMvcm5TSWNNbUhtMWZLUHVQaG0xNUIyalloUjFuMm1tOUhnWGhsYVR5SFUzcE9QeWJSMHhlZXVYdC9XVDEvZmZoSzZMblRrbDVWUnlSTllWU1ZjZVlwNVZQR0RIUVdrNE5HMFBWTUpNQTVNenhFaFkwcFBBaWN1WGxCZ2RmMFdIK2R1NHJyanVzaENEZWlTM1B2a0dRcHhUMkNsM1V4VGEyRGVlMFdSWmxVRVhyRjgvMXZPU3FQNlFqVFBsUG1ZZXpyZHJERVdjUGQvcWdVSnVKclNFTFRaMWhCRHh4enhmcEx2N2hkY3BENGtwalRaZENCTkxwTWVsa1FxMVJubzBPR1c0MzZyZ3BmQklqbFRTR005Z3U4OXJMOFU4VXhlRmk4M2FpL0RSVHpLQUtOa0cwMm1TYnpROUlteE1XaHMxWVE0bWtSM2QyUWFjVDZQWmhtNW9wYkNCMDRjNE1qcmpJcUxVUXJvK05sR3VRcjFzVERVQ05haXh6ZXExaGtmWWtXQ1BsM3NrQTJCRWt3NUY1RGRPcmVNazVNZHBNaW9rM3ZBcWtIVGZJbVVqWUlKUUV4UTV6cFlVaFZoMi9SWWxVelE2VU50VnJERkF4aFpXSVJEWm1SbDBhUHVRc1laK2dKQXdxanV2b0VSdDBxcEZhcEFVZGVCaDJvdEhxMVU2VVZ1d1o5RGxmU2JTUXQ0UUY5aGp4QksycHJvZVlMTDZ3SEtES2hOc200M3FUcnV5T0w2d3RIMTByeVVCbFB5OFlSYVIrcHBSWHl4Rk0rMTBhMkpZR3BranZJYWpTcXhIcDdYdHN5VXZycTkyNHhESlVCYmNIeE1OWUJZNmJOSHcxQ2ZhWnhwOEEzUG1Bb0hJMUY1OUJCVE5OQlFvUlowQmdpTTZEYlZGd1hJMXliTmx0YWFTaHBzZE02dFFIQ3QyVnNXSGQxT0FoeUxNamc5NEVsVVJoVnZUYk9mMWp5NEVyb05TQ1FPaVNMdjZka3dPS255QWpURi9GYk8yTXJZMS92V2xidmhFTi9TRk11SjJYazZxdEVsQjZCczEvYXcwM1MrNk5JNUdZd21XRy92Ri85UkVMdkFUdENIQisyMk41ODMvZFlFM0V1YngwTFhDbDZaRkNJSTNwUkRFUjM3TjBqUm9EWSt2SFd2VFFHUE45VlZua2ZQbDQ1SDNDRkd5L3R6cXpMTFA5QWt1RmVIb1lHNnl1L1JWaXJYMlczZmhTMGhQbnliQ1JNdkxBb3grVlhEMlhRUzVRUE9KUUlxYzBSVXdUOXVvQ2RTU2ljdElJSUE5ZVdQS0pXR0d0RUlaNzhCL25rZDl2VGdhMzJJZHVPVUc0T3NnZDJhWE5FZkVXWTdjNEhGMitRTHY3VHVDbVZXdzJSYkdLSlArMmlyTURmMzJIUzhEaGF5Wi9MYnBJM2V0RDh5dEFBNkd4TllicWJBRkpaT2MvSkl6d2lLMEJlYjFTZU5vSWR3VkFyUlFiVWZMWnY4c2hKOVF2MU5xSUNSQXFTck5yY1pkRWZQNTFibGJKd3ZHcms3VXVRQi9sSFl6SStreVd4aHVlamFNeldTeStjZVREa0NJelk5aXFTWWFlNWlrZFJ6NHo2cllUWmIvM2ViTGZ6aFhpa3B2T2FCcSt2dGR6K25KaHlxbEdKVS9JSUJzT2JEN2pwUXhoM1FBMzRxSUpsOEFxSllaNmdVOFJUL2ZuSjhyKy9paGVuUE1hNWpOdDFMSWhLSURUS2IxSE1NM2lzc1pIVDZXOGRoR0V0TlY4RHFNaFZ1V1hPR01tWjhDU1ZUU2d1REUyVWtNcXJsS1BTL0dmNGNKVStwU1FVQ1pENTlwQTNJZEp0N2EvWktSMHdLUUxJRGJBRTJpNGdYR1BVTWhHSVYzYzJaTDRxWDFEY0pYajc0MXFaQko3LzVaaVBXY2ZUNzFudjhiS3RIbTd6eUJGeUcvaFBORzFuRVlneUkzUmU5YnFUWDY0ZENQSXlFcTEwT2d2Q1JqMjNLcXErTHF1Yk1UMGRZZkQxVk9POGp5QzJjYnRwREx3Z1NSaFoyL3ZKTXpxbDZzdzJuSXo5aW0wWlI5QzdmbWxNSnV5MGJJNUFCOExaSDdVUkdTRTlpLzJ0SjI3eW8wU3c5dlA4d0ovUFlYTzkxbFU5djFXTzZYLyt1ajY0QVBpRlZQOXRWaUowN0NsYit5N0RpazB5bWorbHYrTzRPeFp6cW9nVzJneXF6Tmp5OFlaMFpWbnY3cGRucnpBMVdRN3Q5LzhXdjFkUkxBWkFYcG0yS3pUR0s1SHNLYkROcFV4SXo2TGFjaW5EKy9HR0VMNHdwRUlPcDFRNEcrN2FNTEVub212aHZtNVRDUnRUNU5oUUxOV09DWk4zQzhWNUFYaTI0WW56Wkp2ZmZxbmtrbGZwNHlzZnVPVEl3Vng1VVcwR1FEUWs2NFkrYlFwN1h1MmlQZC8zZjNGaUNLTm1KVFdDZkttaCt0YWJDbzEvdS91cWxmV3ZqdFB5LzNIcThIYjlFaGFmT2pickhlZGJaNzhFMmFLRzRvdk9vZ0JsSDg5UFl4RjlMRnFaWUZGM3RFWG1zR1ZrbEN3bXF6K2VwTmVTenU3dDF0enBBanhFTlZFTzBwVzRBWTZzV2pyOU9xZE44TzlQQXMrdnBQaHBIMkFxTFo0NjhzNDFsTjBXNHhtOXl6Q0EyRlQyTW9OVHNQbnFUOTRuK3F3WHpPMmZFRTNxV080amNjakZUZlRPU3pzanlhUXRFQndHeVk2Wm1xdWVkdlFpOVY5a0ZaTHN3YmI2eHF0aE1ZT1lKcElBclAwcEFGenN2N1RsTHozbGZ6c0d6ZlNXbGtaNkl1WjkrYlpPUVdKSUgwZ2lobWxjTGErbUt4SnhmYlNSWFVkWHN1WkM3OVN3TlFDTE9GbmlPUTZQRHp5VHdkTWtIdmJibDBFUlhkRTZycUZUYzhvR29mL2FOTDdqeGp5SnpkNzM4YjFyd1A3cUN4ajRYU1lHSGNUekwrdi8vc2psd21qZDJJWmxUM1NlTms1Y3VHSDE0WUMrWk5BMEFtclZlcmxrTVVqb2dnM1Q0cHJPOFBRSFcvOXpLd2hEbWNHMDF2dnZ0V3l5REdFUXg0WFdKbDJaZGY1K1o4UXNST25Ydy9ac0svcFh5a0NtR0JiSGhyU0VjMHR1dXZuRnA2M2owOXJnQjJyK3o3M2ZJTkxLK2tqREpJR1FYUGJZcHI1V2JDcjl2NEVLQkg0blo2SnRDRDE2dEhtSVlRZlJucGdaQTJobnlERE5nQTQ3bGJ2aWFJb1hjZzQ5SnM2VTAra2tONXArcWZIV3J6ejdBKytNcmU3TkpEZ05hREdxSlNVWWFBSTVOeW43Y0lLeFRCNC8zQzRodHpwRVU5cWl5NDJFdndKNXZZelFVL0NOVzAzU3RxVFFQZnNjZll5WDAzRTBoNjdNeVp6RzBYaFNreDloN3J4REQxRHFZc09ubENScGYwbnZSL28rL0JXY2VoYlA1K0JZajk0aTVFMUJla1JEU0J5V09uWnlHUllmV01qdGVmZWVCTDQrdTFIMGZHVzRSY3VsaEI5L3RFL2hnMmR3STdRUEhESi9pb012S3hWeGxrTStsNjM5Sms4MlhlREFCaUpaazduMmhmam5TSko1eXE2YWt0SXJOMC9qSCtTVVl4TEdkRFVsMFJCdGpWT2hscjUxMElUb3hCVU1iMC9CM1k3TWNwR3ptM0pBdTZ2L3RyVlFNeS80YXNxVTVlN2NIc3puRi83YVNjME5BNlNQWlEyV1V5S29VQnRnN0lLNER5bG83bjc4Vm9IS2NNbDBOQlZEcjRJRldnZmZnT2RMQ0dTdHJRdGIraFRBMTU2WHZTTWtkWTNsSUUwRnRyTWtqc0FGejJhWmpMOFZLaWh1YWNUSDQyTWdmMGNDdCtQdmk3NEt0WUxxdUJrMjBGRzFGTFgwOXNxTmhNVHVkY0wxcUF3U2s2ak1nWUt1UWtWTUNXNklKVk1ZVU04aEw4S00ycHF1OVNrK3ZpZjJCTm53dFR3WThlM1pHRHdmRllYaGc1OEJMUWs0VU1OV1hueDJVRERrM2dGQnZPKzZMeUQ1VVA4aDNLZ1JLeC9jUzQ5S3A5OXlGcVNsYzA1MmcvTEtPSFpjWGgvdUdPc2VWZlhVQTZkL05FZ0w3d2xvRm1IcFpUZ3NJRlg0YnFiRUJCMHM3RWdMMGpMY0hlODcwWjlZMmV0Kzg2TDhCUUU0L3dndEpETGpLNFkxdFZBa0Zza2VTWGxNOTdTN3hLS3BESnIvSW5HT3crVUJIQzk2Y2d2eG5XaHByMFhxVTJPdDNEbzhqZG9hUFZLSUh6VDBKaHhRTnczN1lmckVkVVFyZUdodXlHdE1iNXJ5b2w1QTBEN2ZXR0V4OXo2Y2V3QStXNE5ZZ3lPLzAyZjNIWmhRWkZqOUErSXpaMkZ3Rm56TnBBWjNla2h5Ym5meC9FZG13NnpQeU5hdmdNenc3R0FWd1MyYUVTSE5NRklkYTlhN0pOQjRsSUV1ZElEODBYbDJKS2haTjB4enhiQmg5TVFmWEIzUzhEeGV1VWhWek9kVVdJMmZzcmNnaUNwbWVraDl6czREMHJWRUNQdkNjTUJSbVhLZGpIK2ZGQndiYndkSzc2VklpRVJBK2k4c2lYTCtGb29ybGIwdEs0LzhtK3k0ZmV2SHQraFc4akllajlLQVh5VkF0ODhPdXo2cEJ1eWNhemlqVFFhM21Db3lSWVd6VXNQLzJaZHZocDBhSnpjcjNKWkdVOEpVSUFLWmRzVW1TZjNRZUpqQ2oxQnVvR2dYVEFNK2FWNnZ6SVpONVptMGlySUhtb2o2Vm9ENVA5UjR2dmk4MkVHTG53dDdiRDFqam9DNlNvcGF6UG5ub1VUb2tvdTk3ZFJLeXRXRUQzeUJlVElkb2NGR1JNTGtJYVk4dFJnVHRJb1duWlVjOWNPNlh3RWJSRXBEdm15cFo5YjFSbHZqRHJhMW9OcEs2VDg0ZzYzSE5Pei9qWWFqd0JlYWtaRTIxcE9aVDRMRE9iZDNUL1U0U1FGK1JLSjFFN01CY0hSOUlBMmVIRDE4cHFqbzNqV0wxQmVzd056RUVhc2VKVVN6TXFrZkpJbmo3Qng3QWpmbGs5OC83QkJTSFJMSTloK2E1cWpmZUVDdWZHRmw1c1AyTHI4aVQ3WjRJSjlpdU5XRTVwbnc2UVA2Y0pETGlwak9SUEdoM1pkN1RuclUrSGhlNHVOTEEzNDZmS3VFSEJiaFVsbHA1azN4ZFFUQmc0cSt1SW53R0tlUWxUcHkzVWdORkpvZEljd0ZyR0R0RzV4R2FKUktJR1d5ZjhjUWFHMllGY3cvTks2ZEgrb012MDVVOGFsZ3VXU1dQOWtTOVA1L2EyM0xrODFEL1V4ZEc4UDNuOXc1MzN3cXdjMjIvd0w1U0dJcjkvd2FvYzNhbUVpY2prZWhabU9aTG5HdytJcXpMOEQvN3FxYUZtRU9jUFB3RmpqVmZjbXdwZ3d4K0ZSTm9XMFlqd2xQQ0hmU0FkWmp6Qm9ZcS9TdnhOMjVua3pPcHB4MXJqM29wYlFHQ3ZCam9iM2JteWxRSHVWZjFxN3VReUp2SHRENzNSUGNLZ2YrVnFHUGRuYit5KytnVDJUM1VZK2dGcmNvc3JEWFFpSDhkVUt3WDVUOGdvMUdCVTRyem5sVkM1SFZKbEVUOHZlVG1vQ0JQTko2ZXJ5bTNhRFNvSmtZbzVVdC9kYzFrL2FZelg0SDVnLzl0LzRjeW1mQmtqR3lCUFBCUGg5T1d3NFBNVXlhOFphb0pweUF6VkF3UElqczEzVkFDSHhEK3cwTi8vckNCSmR2a09CZmROU09GNFhDOW9QUGZxdGxOV2hHMUplQjRIRldyb1NHS2c0aVUrQW80a0Y0bld2R0N4NTh1emREaks4S2o4VlA4OUVwanplakNaeEhDc1kvWTZHNlorVkJQaFVrUzZYRkh2V2xiNGtUNVoyQzV0Q1A5SDZkNW1HMGhxNmdsUm1PTWovdkxubDZQZG84NkpmdWtLTUhiTFRBWjZKQ2ZjL1JEZnZlNEZ3Mmx1UEVYUm5GN0RHY3BmZ2hvMGtaMTQ1NUNFSXdvRC9VSG5NNXlhajRGa2VzT3Y0ZmtyR25QTzQ1WnU2ZTJwYlFuLzZWSFBiMGlDRjA5QjBhWlh5d1ptS2t6MXNwRG1hZzc3RFRZMlVITExQbGNPTU5TNDFqNVNaeHVSTkxIZTArSmdUT25EU0I1WFJ1dmRBbnIvSXpLbnhBMWhRakh6Sy9OeEdzWFFxNk4rNUxwQXc3QUp5bDNaOG1kRk9XeUdjcFFGYjh4QUE2UXpwM2RYM0sxN3N2UVVtV3gySllIVDNVbDdCN00vU2J3MmYyemJWLzV4UWQ5M2plTXd3WGM2WkpCLzZabDBrK3JPUU1VdFY2VHozRjBVcWgzUHNyYVBYYm4yTXRGU2RrRVNycUNNMFMxdWJaV09zYTVnZEhCUG96MlAzeE8zK1dOQVIxK1M4TmlQazBSZ2hCRFByZlNheVNGbldrME1wdW91QkhnNTlhUDRPbzB6b284V3pCR3RQQ1dURkVSTzllVUJlK1lRN242RkFVRjdwMnhGbmFnRVVTcDFEempHVVBxN1ptMTZSK1gxdEo3RXliT3FaaXZKT2gvVW40cVNQb1o0RXNQYzFUaXkwQldaU0NzVWp4UXo2YVpZeHlJUG1xdE5UNnc3RmRTVmpKNnd3VVQzc1daV3pWSW9PN29WSlc4VkNtVkJMYWJTRGJkeisvb2tjZ0RTQWpXUzJubXN1anRRV1ZxU2JjM3A2bFRhWVd4YlNVU09WQXQ0ZnF3R2Y1QjNWRGJFQTlKVVl6dWg2S2hIYStlS3RlSHV6T20yd09TM0REVFdRVWxWeW8yMnpiVXkrOHVKUHlYNnRNM3BSYTB4elNXaWthclZrMUIrV3dEcm9JcVdSWHB5Q2dRTllBdjB1eDNJbFoyWmhoa1NScTVZK1QzUlhqTFhVeXZ6clhxcUpLa0lZTDNVVHkvdEdYdUJJMTlLLzNydEQwOEdDU3dsQ2I0SEJVb2tza0gyR2FBQ2lxaFFpZWpFT3o4OSs5K3lYTnpUM2kxTXB3MUZ5am82NjFuMmozUkkxM0tyUFU4TDFFMEV1cEg4Y2Q3enliNVBZTW5mdlRpUmtzaWhrWUswVC9wS1ovemg3eXNodi8vN3dUbUZwMmVobVkzTjZleXNLakF5RDh0REpFME9tcTRnVHdMZ1ZTdlVWSkJiaEh3WmYvV3AwNFdVbytGRjlGYS80YU92ZFhOZXJPTHJocDNKSG5DSnRJNFduTHVEZ3BERVpKZHFOVXRWbDlpeW83am4vS3RTMlJrb29ud09aSXVQMFVkVkltTzc5dktxSEp6MXFMVFMyWWE4NnVxZGtrdXU3Rkc3SHlrY1RtZzJnWm5ncjIrbjRMRTNucmZoM1JtSnVkN2owQTVKYU95b1NKcjFpWmhGeEpHMW44ZGhNS3dnOGc0ZDRORXpBTzdEekRoSmhscVZOT1ZSRDJhbFlSdGhkYXFlNGRaMU5LZkFRWmxXSzgxRTBENURnYkxpYnNjOUFLdGhFUlJuNk52VWZWb0d6aXhybXlzRDFUdTd0YXdjVVhEZGxSV3lmc2l1c3BQRTFad1ZBSlQxb2J0UGhtR0Z1UjFDaUJnbTBFcjZKRU1LSHNwSnFuQWFCdXB0UEZXOUhhLzR5OS85djd2aHQ0TzJFQXlBdEtYdHVLS0hIQ2txaEVHY1JyU3VxdE5VMUtSZ2EzVWtTZVd4bEJ2SDl1TEl2QWtrd3EyTG1uWTRUakY0RkNpSVhEZ2FmRVlSUERXaVFONWhjejFuVStsZnRLeUxkS2pmOE1WRU5VSGRtb08wRFNvdjBYby9BeFBHUFV1cVIwbFpKbFMwTWVZVlczMlNNTllUcTFZQjR6NmQ1Y0ZKbXZBNER0Qy82SEpTdEZ4a0l1cFBiK0RCOGI3VG4rbkFvNWppaDZzT0x3RnB2eWhzdERhRnFCelV5dDl4Ky9KVitpYWViUEE4Z3N3akltTk9PTFhkL0V4cmJuMWd1UTVPVDAyNUx1VzBQY21ta3FDODRMN2NTNDdER21NZklhSHYyNm1CUnIrUGx2NHd3SHh2MXdRQnQyNlQwb1B6VEQ5SmpSK2ppSDFMZEY4aG5vZlBPcUlWTDJhbEVUUkhGUjdFRmRvRklzcVZXZnBScS9VL0JLeG1hQnF6N3oxYUpWUjNDWnBvY29icnJZbG1qcG9JR0xGVVFLYUZsYk1ObnpCQ0QxR2lQRGR6eXkzVFNOTEQxMVlCUkVucnBKZForNDRXNW5zdWhFRkd5bEE3dmhpWkEwWGV4WWlLbThRV04zaDBpRVpwc3FNZVZBQnJvbzBWRWpGS3lqMDc4MW1LdlREbm8vSnZoZXI3MDAxSmVRSlhFOTZLYWM1UStEcjN2cEJOVG44bWlFMjFGUTZHVkY0OGViTnBkNWtzaUdrTU9pTW1qMElNT2dOWUNKdU43bi8vc25sQndreFdRVEZCckZzODNqak8zVHNNSVJkOUk2TGdEeUljalBvWkhjUmRsVm1VWlBkSTBzc3RNTVJDWmZzS0tSZ2ZINE1mdnBmaFhTY0ZnMXhIUkFhQVRYTXhDclhxbktYRFpxZ0xZcmh4L1pRU0pDVkYxNkt3QXFZMGlLNEZGK0Vid2c1T2dENXM1UU8xNkk2S3p5N2FIUmdyVDlDRklTK0FVK1pvTThaUllCcVpId2luak4wSFU5T3VWcVhvRzcyTklBYTd1d0RpOWhWMHBxd3dwZ3hsMUpqbGVXWGVLK0hFYnllNUo3V3ZlQXE2QmpvdEM0Ni9nQlNRWDVQSjFpMThzWFlTZ3MzOHllNEIzQnFaY2czU1FRMEVVd0hmUmFPbWlXVFpJQVpLTC8xZ0Z3VkViZEJGT2w5U040VzVWakdQSzkvNDN0bHRzL2JGVTNQTG9YZmdHSHYyMnRmckxHdmdLUStiUElYWlNKTno4amNWLzdZMWRneGJEeWdXaWV6Qjh6QkQyU0lkbUJ4NkZBZTFHMStkZTBNbGdnYWNncE1aeUFKb1NsRnNSbVJTUHNTT0VJUDh5MzNkMlZFU3hCTzQ3NFdNeE9PRkRTVzdWSlFranNhWWMwMk1SZE9jRXVCMk4relFWd2JISTgrdHdabE03eWxoTjRQMVpQaDRzN3haQlRWdnFiM0ZVVGhsd2tvQ1BpaE0raEVacEp0Tmcva1RuVEdzKzc4dVovMy9kSUZtNGZSSS93L1J6ZDgyWWg4L2xsTkIxWkV2RnZZYnVQNTR1ckJ4NHB0S2VEWlJYUXlxL1NCQ3RISUNxbG10SmJXNjEvaDZja0xnaFFxQUJObWxhQ0dSTklJZGFSRmlsYU1DMFo2bTlZeWF4Smw5Yk1aT2xZN05NSU9XRVlYQ21FUEFVQUN6WEpjVHl6YzRBTTVocEIwRDNjc0l5cGhmU2xlVGFGQk5raVBsMys4bitUMEZpNXVuMkFIcExVQ1ZGWk8rbFdoa1BuQ0NZdnplTGFVZ2tvS1o4SjRiZEpHR2g1UmdSM0NMYWlsRi95ZGJ5S2psVjBwTXFGa1FPRktxQW1JMzdBSUk2ZG9kVEpBK2IzWHhvOGRmZnZWREFHVFlEVjBRRDVqY1c3cFhzK3ZkMG8rQmJEaTlKVjNtaVBNVXM4UnAxNjVQU2sveHh4OHA3clZVTis5ME9FODJQTC9TNW9NQjZyWUhCZmNqRTd0ZjhyVGZ3NVk0eDQrbGx1WS9yNkd4dlFLWU0yb1ZBWDNPWjZKN21oVm83QTgydVM5TFNRUWx5MFlNTHNvYWJVM21wSmFleldpVExWR1JwcXhtY2FpRkhNV1kvK052UDdoMFRqZmMvOUtEbm1wOE02TVpwUit6UmFNVnpWM1hHcCsva3hsclBMNjBzN3Z4L05vS2QwOGk2dmRRZXNlMFYwNXFGVXpGVEZtT3E5WXc0aVhoRkJSV1YyTXlQelBVWlBuTkdndXRtMmc4RHdOVTFSdnk2cEVRcFNJWUt1S2xmMkJTRUh3R2ZXaGdMT0pJbm1wUTc2aUFqNDFMa0F0OGM3Q2Z5RWpaZDlxTEtpVlFnSjU5elFxUUh5cVcydFNCVTVwWjlvamZzellDcmFva0Jhb0dsSGdEL1AwZjZEQUgxOXQ4c1VLRzg1ZTMyN3crSnFOL0NQL1FtdDMzK054UXRuNW9PN3kyOUowWDRxdHplNC95Z1NHTGthM3dyZGh1ZHdnZXRqRThzaFUwYXFGMjc2eXg5NTlYRFJxbzF3cngyMmVQMzcxSStvSzV4MjJ6aTdXQzdYcHUyTndud21tZFBmQjdMeXlhejF0WWsyZXF5aWgwYnpsb0IwM25ZZ0dzNUl4bXdMWUswRGc0aUJQWnd3QVFqVlVqcWVwNHd2REdzOUNvTzl1UGl6L1J3bzQzN01Rb1p5WWkwSWlOS05iVzBOL2JPUk41QXVOcTZxcFdGKzVhcm01VitWNzZQcHp6WjZ0blRMN2VEbFI1cGdHb0d0RkFFbkFrNmpXRVBSOTFsT1ZlVWVxZWxhUFBYQ0lyTDNHUGF6RTVkVHN1Tk9MMUxJYkNxanZuZ2orYTB2L3hFdW1yMnlyZk1sUGo1dGlMNU16VkN1ZlU4ZWlZOFBvYjNReTVjbGxBRWEreUJ4Kzh2eTBWQ2NwNjNKQVhYYnRENEdwcnFUSjI4YUZ6eHdyRjZJTi92a28rUDVteE9FdUdwRWlCSjBGWkRkMmZIMTl5MjZqSjhaM2xJcysyYzRJZFBuS1VMaUd6RWg4eWlHSkJseDluNjZMdlg5UlFoTnYxWWxFSUVsYzIrSnJuSmJUaWdmR0tpRldYSVV6U2swR0Jkc1JpS0FCUzRiQ0xOZE55WjYrd205b3FEVEpwM2MxcE5PL2hxZUJOUExDM0MrcVZWdDRXQ0tzZWtXOTBrOUV3TjY3RStRdnJvbnFMYncxYTVjMytrZDc4NWkwcFZOdUhZUEZUNjBIcXNpaXE4Rm5zdzg4RnpYclVQTHk3UU1jTE1jSEF5WVltRTFWbGE2YWdhdG05cEJqSEllV291YlFtUzBycml0NXRZTGtrSUpUeENnd1FZQzdBT3Z6M1lVYmx3TmpYNlJGYWk3UHUvdWFGVEFiUFFWYlkwQ0kwNEh2OHFVRHhva242WGVuTUtodlhRZzFkWnA0NXYyUHZzWjJDaE41a0JVUTQvdVlMZjdCTlRTMGNwS1drQnVsci9NQ3ZiUTMwWkpjSjJqSlcrTllrUWJsU3NGMnZORkUzTDZiOTdVaC84T2FBa2tZNjI4aHdUMGdqQ2U5L0lHazNRRTE0MzNwRlVabGIybW9FbGZpSTJidFJadlhLZlVrMEJPZTdZQUVzTFQwUUpJQjJEVVhPcWQ1d2QzSHc5WWFKMWhhMGxKSmVBQmlPMHk1SVRCZU9qZnMzVXpCb3BxN0NkNEV6ZjNuM0FWd241eXpSV1R2dGpCSmtUSWhaRk1WNVVORnhqZEFPeWpNRXJxWDYzTnFxNEZmWElvNDYzbnhzMEFyVjYvczl1WFZxNTZ6MFE3NURVMGtybEJWSlRoK0J1TkxYMW02b0pJSXdHNUtjK0Zpa0N6Z0xLMTRpNjVHbnZwanRCVHQwcTZTYXdvZExPeEFiaS90OUJnRVc2NjJOVkNwMnRoTGd5UVdRSHZTQUtLR2pTMktxNGFvVlV6K0U0L3pqYmVYelN6bXpncEFNcTZBYjk2UU1tTjFGYWd3cnZIN29OZFNkZk9xbDE3MTNXejVxQ3hGbFBhR01NUGYvVS9UK1VXbmQrYjczNW9kZ3Qwa0xFbjhFTXoyNHBZUzdKUk1RWlVkb0hJUFUrS0JPZFl3aE1UTjVVQXhZYkRLUUhkaEJKbHhFYXhoaWI1dmxUYm0yOTJSdE5naDBZMXAvUlRKUVBTbjFaSHdzZlV3VG0zVEZTVTl6YmNKcFhlUHE1UFNaMVpYaldYbSs4MmZXeW9wWnd2N3V6L2Z6ZWI5ZUh5cGcrc3RLRGFiaUxQZ2d2VmFFRWU2V3hOQy9OM2JPaTlWTEQ3eU80dG5pRmoyWnZtZE8wM09pNDQ2SCtHU0Q3NjdhZXgzUGw0MkFXQk9HMSt6U1pRUjNmcTF1N3VsY2xsTWlOWTNJbHBKZEhPWUxWZUdlc0lKLzdiMlY0VDYweUFZTmZkOGw3ZEJqZWlVelpJUWxaMlBhSnJGVkZ2Q3pwbXpQcHRLelBlaVVUSEpCZHplVmRZMktNSFZqZnFNVjhjVysvMERmSVJ0eDJXSlV3bnJ0eHNVYk9pbnFqcU5iUGFnU2MvZHZkZEhVQ0ZYUjdwUmxURlBYeHlqeC91MytXWmZkaFUrS1ZBdHc2MG5EZDE2ZUpiY2xaOERocWhFTXArb0ZNS3lyT1FHT3hTL3pkZCswck04ZFo4ekg4L0FJc2dybUV3SG14VUxRQVJUSUc2LzRsbm9iK1FOUVJkMFBKaDhxV1BpMTJsT0xLM3U5Szdpc0UybEZmSU50cTdGSlpIaDdzUm9TcDJWTnRlTy8vZGUyaXExSVRTbmFIc1UrME9wbHNXRHJ5UllWVXJjUlA5NDVKMVZFZHc0Y2ZnK0plb2p2ZzNHWTFaWWh2WHVlR3lad0k3UC91Zkhsc1gxV2JLemx4NnR5VHUrRUE0NjAvSDFyYS93S3hYMzFwaHhGN3VPZXZ6WlMrNmJ5TGx2NjZEcloya2ZFbytHUTRlcVZZU3I4WkloOEpHWk1uMndUelN3ZlA1ZFpNWFpUMEtBYmdsc3llVG1QMDZUSWh6bUtLRllxT2ZLTlRoUGxSYTMwVU0vS1VZNHo0dzhwRmFaLzlsSVZibXhUTzZLV3Ntd1QxZGtoTzZwODBIMU52RmtPS1psb3FERGI4bXMxYzUrTFVCZmtvNHd4bGxxNlkvbDJBMkV2eThtUTNadGlzc2lHaE4yVVNDRWpKRDJaQk9FQS9jN1dlM3dJaWpSUGVmNTl4ZGdvRDFpalJtcjNqdkNlcUg4MFZHY3pwR3Rtei85eVZPV1Q4Z3FzWlZZYW5vMlhrWDQyWkZVTk1RRjdHcXlaQXRScFUxU1pMcEV2bnozTStaeXo2QUFBSUFCSlJFRlV3YTFtYnRVMHQ4dTdxeG5YSW5rYlZKaVlrWHA1Mk53WEFxSGVueDl6dDFUMERuYlJPb3N2SFY1bDBBTFdKODh6TWF1cTJiSEFidWFCQWRiRkQwQXh5Q2FQYjhDejdFanRrU1V5MnU2dk95ZVNYRmt0aXFrVGJwWndoQ25XZlpNemd5d1BraHhBbFpEUUI3akhlSjd3aFY5bE1yNFI3RWFkaVVoLzk4dkpBajVTSEczU1FHa2sxcWRxakorR0RqUjJDbGxieE9WTWdDUlBDa0VHL0tqT1NLRlcvelU1V2dSNkxUY2srU1ZxcVJoR0NCSVczSmlnWkpVT3hja2RUZjdqbi96NXpRYWJUSGJZVWRQMm5GSGtDazc1alFKTjBVWStFc3N4dnIvNmh4OEpBNEhQVnIxNGVYV2xNa2hNZnNGOCs0MHF5eEV1WTB6YmNIWEw4WFVDVElKbzVndGJObTRFOW9FM3Bjb2NZY0E2S1d0SFhtZXhMaDd5UGlwNFhIRXU4ZTFIOHVTNFVGblgwOC9FNnFjanlDVk5MK1NVWC94TE44bm45RlBpTHpzVnhRTDRvZmxCUGkyOG1RL3JUakVJdGRqcWo0Z3BuNlNHMTRkZ0F5SktTbktjSlNtZzgxZ2dLYlFvWHlBMzJ5Mzc2YUh4Y1k5YVNua2htc0ZFWGZBc252SkhTYXd3Mm51SW1TRmI4WGxoZHNJZG16dlJpcHZmWE9HVU9LNHdpQjdFaitLdTlYY3JUdENnK09IS2pUdU55SDNZODhrM2w4biswaGZwSDE2Umg2dDJqekg0NmJvT3dpMXc2Mm9KZFRvcjBkQVF0dm5yR2NEWVNYQTRZSVJNT0tUNWFrd0xsWlYrS3BUcWlqS0dOMXR2U0dYTEVYcHZ6dm9BT1RsUURwTk04VFE4ajFpc0lOWHZtNmh4bmYzaXdIOGJBQjFXb21OS3lndzArU3pxNVpyaGUvUnNjWHliTmVOZGsrcWlFVG9xVTZ3ZTdtQkU1Sjg3clRKeHZLSlVXZVE1K0RYeWhZZlFENGh3UHlYdXFXaG43b01qRmg0eHRXNHZtQzI5U0QrSjVadU5OWVN3eUhpL25mdCt5Y0JTTFRHVGlFVG5VZWlQaE1ldGFvUkRWUk5FbjY3OFhjUzFDTzZCR0s5QU9TcWVYYzAwalQybFVPSGJzMG1ub2x4Ky9JY1htR1dVUGxSSU45OEk0OGsrcTY3V1VPVnRpZUZDL1loOS82MFRKbFd6YlgydFFmM3pFOFQ5aXUxNU9BZk5TYmtEejQzU2JNL1BvODNWVXVoMGYvN0ZWNWZwbHJEYVV2Uit0dFVNZzA4amdpQzN4a3pFNzM5cWRGajc2Vy9VQ1E4N0pSVzV0dTRnQ1dySWJ1aFA5L3p0ZmRLM1ZBdFQyeUFpdlFMNi9WamFyZFUxbmpzVUxGZ0w5VTFjblR1a0VrRktSb2QvS25ydkZ5MzBFaTNvK2VnQlFFUlpka2lBMDllWmQ2T2orM0JtV0NDbjFjaDYzckZBU0FremtoMkF2R2NuaVB0WFZDMFo1Y3I1Um1jNTAxZTVsUStLdWlxcHFHcUl1Zm9UbHZJYnFzVndiRk1wWkVuKzEwM3pEVkFJSTlqUnV6d283WmN6M0d5a1htN0JRUkNmeE9MZzZnOUVFZ2tBdHloNThQMER5OEtXekVQTWhqNTNqVEhMSVFodnBmbVJwc1lEWWxXNFY1N0JUdnhseFMzS0owSXFyMDJTL0FEUlI0M0IwZnNwOG5SOWpjb1gzcVJ6UFdueTladjJVZjNnSHRGQzA4T1EyaC83SzhMQURMbCtvYXp5ZStLcU9pSUxpMllhaWttZHZKNDRzSStLd3RCUElCYjZ6azhFSERCWWtYUnJrckJqa0ZvRzZuaHdWN2VNM1MxV0pZVjZLSjEzaml4T3VpbDB0clRlRzZ5VzF2NzJwcktQbGtiOXBSL2hoZnRhVnRKOHRVUkdxSkVLaUxFcEJyMmZMbkNYUTBZaTZwc3AzeUVGSERqMVFjTUJhVjhDL2E2YzRKRlhNcWF4eXEyY0lJV3F6OFR0UGxMeVNZYU82N3hNcVc3ZEFjVWZOUHp6YlZvYkRyWmt3TWxBalBkNDVtVFBxdXBEYWxQQndmQS9OL2V3UERQaStvZzMrYWFlRXNYM3RqbDBTTWlsZGxmOGZsdDBjczBMQlp3QmZmNCt4MnRIT053bi9TWG5hTjBiZ040UENSRjk3RmQ3dTJKN0VOKytSeC9oQXl2Z1Vzdk9TdUFMU0xZVkdzejFoTnRqS1hmRG5GZURBZmJQNnlLd0V5VVg5RFV0VWdpbUY2LzRBK20xK3M3NTZJT2htZVV5b2xTM1dyQ3lkdGNhd2lVZElCQVhIS3dPbVY5ZmFRcGpOUWZ2K2FKUmdoZmF3bmxwS3puMDIxajZZQkZ4RWdjcFdSQWsvSmxJb2FYUytSZHRCcHNmdGZ1T3JtajQ4OTIyRmF4M0gvZ0tENDI5OXAyM1VOSlp2S0JzZG8yZlg0RWx5dDZHNmhKNDl3VWtnT0tMdVZJd0NjNmd1eVF0dlpJNDRQME52M25EbnJCcWttcVdPK2tvSWdURWxzRXRjT3BLdEF5NFdBSXl1S0o3Nm1zTWRUWmJNWUJ3Zzg0TVFrYWE2dHdKWEp4OFRFS2RJVGRrWFYyT1lzVHRreHVoUFRmeEprYk9OSXR6bUtMZlM2N05Fck00RnVRRFVZdjY2WTJBU0M3TjVhVXdPNXpwUlFHREU1VEQ3Y2o5SDBDTWxYa0dMM0hxQ3o4bGJzVGNsakVsajJFTjUxTDY5WGF5TEtkbDBaMGVQQktONUNPSHhzcjNJNysyMVVBN2hxb3MyWDVoSUE0cVluSHlnNGNxM1NJMTdIV1F2TVpnaXJ3SGd6eEx5Z3U2VTY5blh0bUE3d2R4L1hIZkpwTElNWkhSWjRUVk45ajE0WnVEQ2wvSmVaYnVOZlhFMmRpRnc2VWZaREtpZVprVXNGbEtvaFJaY25DM2JBMU1IYktLd2lNNHFsVXRnK3dvWkxnNm8vVE9rbk1Wd2JqVWszK21jN3l0S1M4WGxMUDB4NnVRaXJGcm16QmZ2QmJnK2JEOEYrVWRIbUh4UGYwSGpUVjJpR3E1T0FCdzdLZFFuUnllMWJZc2Q5Q3kyTGYxS2RrWjl4U1c0dHpqVzRzMGdIbFNBMFNEMUdNelRWNXJ4N3JHeUt1ZDFMTmtYOEpaUGlXSWFLT242OXZMN1pGdW1DSFVsVmcycjMxYmtlcGRIZlRLK2FPaTB6Y0hycVVrK1pCWnB5NmZwUDQrNDFWMlFqc3lTSFpKbGdtd05zeDlnSnIrSVRaR1RUajBmSkpvUnkvY2J4ZklCVmVyTWw0ckVKYXNSeWVmVHJOWjdjZHRFaWNkdHRXM2g0cWNxS3pwbW40ZWttWXZZWVR3S3kwaUNWcDF6WGc2N3VjUzlwMVI4RGE5ODhJV0RpZEJCbDhQSjVSVHA2a0FIZ0dxS2U2T3B0clIyL3o4TTJjVGJJU0dmUHpLOTY3MWliczUxdVM2Y3RoK0tRVUNzRTM1bUhiQ25UeUMvdTZRUXB5UDBDTXA2bk9jZzMwL1BDTVdhdzlwWmFqa3UwVCtod01zRzRzNS9NYUdpT20xOTlQem9meExNNWl5ZHh2V29aMjcxbWQzU0hDemVSWlRyeHlVTGo2QkZQM2RwZUxuRlZVM0gwTXZwd0w5TEFjVEZFL0tuckRYdFVrWDB3ejI4eGRjNDBHbDBuUHdHeXZudXJQQkRTQ1NXWkMyWVdiZ0poVEZCWjdjMGZiUGYvdkd1NWxNKzl1ckZaZjkvRHYzVU5jTWt2V2FGd3NSVVQ3QUdIVWwrQldJNDZZc3dwQ0hDdWU4NXc5WlFhdjJUK3FPOFBmUUhrbDlkWVk3Zm5WTUszc2VUdU54cE82SElmVy9EdWd5V2xxTFBPYzg1SFFLRSs1STdXVlRUaHp4MCtzNkY2SFo2QWZ6NStjWHowazJvWTRVSXVyRVNwWDkxc2lsZHRGN2VsRG5LWkhzVytOVmJOQ093RFJwN3B3U29DdVpFYUxwNWZUTWtuM2JIem92V1F3cWpxNzA3QTRxYUhVbWN4OFFJZG9rd3VySnJGYUdORElUMGVNVHlabzRzMDZFTWVMR3JDU2pGUFd3TmtoQTl5b1NaZ0owK0s3M1BteWVMRC9JdGZzUUpKSFdvaHlEdlVaNDVxd3VzNHBPRGlFcVhkSStUTVlUQkpTMnNrRmVRbkxQenVEWXVYTWtNNE9TZ1Mzb3ZKNXVjcjhtTitRbzNWdHZmdlorQnZ2Tmtnb3BDQkZ2eW00UmNheXJuMXRkcEZwdmtaTHRvcnFqa1daN0JtYWNmWHIvQkhqOUJXcVVOUXFWTHBHc0xxQUNzOHptcVFleWZkZUJ3YzJJUkJyZWtRWk1GN1FjRWNFTFdCRytqM3Y2OXVsUzFNY1QxeFBNTTNaTDlkcG5iM29uUlIzd1RwWElJQ09MMm9zSU1yY21qV1FaTFlkNUIxWkErSHZuQ2wram40V3RRQ1dEbnVwYW9Xbld3WG1mZHkwUXhhQWpraUNBUzZZUzMzZVpkcTFXNEJUNmwwTkk5SjVEMENGb0M1azUvYjVvVW5IeWlQaGV2blpvNjkrZXVYcVZDMTVuRmtNT3VRWU9sNjdlcXRseThGNGJHSlRIUnUwZm5uZ2swaEY5NkcrZlozd1NZVGFFWGJWekJIS1pGUEtCb2VucnoxK01uNm55U1U2RGhnNFZKN1dpQ01CUmxiRUxjZFFWK0NBRTgydDFUNktaYjRldVpIWFFaQ3lsUms2L2NqWThGN3ZpclNsOGxrbzh1Y1FVcmVYOURpVTlWUy9maHFyTHIyNnM2dnV2TzdVUWxSM0twV0F4Snd2ZzBZNXAxM3NqQUxrS0ZINWpmamZEQlVkVEFqdjNlVTZITDA2YkZNcGhGbWpPSzBvclBKc2htRU5sK2taOHF2QkJtTlZpWm5YRXZUeC8xSkZKbVV4ZCtoQXVReTRwSGJCTXQzcEd2Q21BOHd2Z3lZLzRBOXo1cEZwZ0l4TzQxU3VITWlmb2VzVkplaFAwL2hLZC9WU281eU44ejlNb295YmRid1l2VWQ3U1drajRZcysrMHpXY08yamREOTg0SVBhZ3c1SGxwSE1neHdhaUtGczNTbS9OeWZiL21naE8xN1NoeW54cDNwSDduTFBiZVRqZnAwc28weHU2dHZEYUsxZFZmUDdVc29Dd2hUMS9CUTA5U2t3akp2QThvQndBWndYRDQrNTZkZTI5Nm5xMEVLbkExL0l2L29OUTY0ZVRyZjhuWnQ0VjlqT0hOUFl5RDRhak9COTFOb1Z4T0NOZ1I5Y05rSW9rdEhxV1E4Z0FsZUdPVEwrVjY0NU82WFErUWYyT2tMUms3a0dacW1LZ05la3NJQ0RxbGgzeUFzcE1qbEhYU2lYakx5SGxPMlRaNUhxUW9CQ3A5NFMyVmpPdkNFeG1rUmZmbENMbFl3VklQdkw4RlRmL2drNG5Qbk5GVm8rZFdOMSt0a2tvS0t4VXA1djNKenk0MmVQb3JUZ1hJOWg2T2k0OWRXeTNqVHVtM2YvaHdFVjMra2FBRHUxNnNMdkszOXhMd0l1eVE4S0FtWjB1MkRKaWN4MkhiZk8rUWNYb0xRaG1xWVptd0xBRmE4MDN0TVEyS3M2eVh2dHRNOXBqYWMrWGhnbU5aNDVzaHFwdm5SV0JFR3lPUjJSN2k0WUJ5NXIzMHRLdSt3YWJOMUNLaUM2c1dyQWVKWnBlaHpuNTlWUkpGd3EzVlBpRTZPeWV6eUszRTBxWW9yT3J5MHVMYlFsaGRQYmptendxd2FtemJzbnBnREZxRHl0TEt3NnU5NXlDbE5aR0JTK2hDR3dGaHRPMzZldUd5YWxYRHN6bXM1NWZmRWtFSW5IU2ZycnNPbTZ4blNqZkU5VU9NZ2RMSDRwVXArODBPTmJ1RXYxeVRyZ3JMaWtsQXo3dXNSWE9xZkdjOEFHdGhaemxmN2daeFU0UUNrSjZZRGM3MmE0VVVKOC91WVNwOVVWdGlKUzlLcGxtODlHNlhCc3lpS1d3QTh1c25saEhWK2JVbmwvMmZpMlpGZlFKbjVOazFkNGRGVTRrdWVlU2dpTEZpOU5iN1FJaENmUHk4Ti84NjErLzFrbEhoRWlqNjlWblo1Y2ZoaUxwMHlhbEpvSy8xc2JuVEdkMy8xN0NjQjNMK0tXd1JWSFRpZC8vcDBFU2UvUFQzenlrVGIrNGM5aW1lOEY1dHpwRHdvR0lGOGhFb251ZVlSWkhCNXNCdndrVmhXeDZ6RW02Z3A2Y2VqSDYvY2RKbURQNFZ4K1M1eG9Ud1RJWkttV0diNGdjOUM1eEE5QmpQTWtNNVhaRlM2cTRIY1VQUi9jR2R5ckhKTUY3YWxRWFZ0QzNlYUVyekdoNGMzRThTTGlPbktMN3BNSWxiVHo3VkFrUzkyOVBiVFBydHdXVTc2MWNUOHgyYlYycFlCRThqeHArYS93QU9nMEdicWZYU29KbXVwdmgrVWNGcU5hdlNsUVJwS0VuK3hyVDc3TTRNOXNIMGVGSVU2aWdSNFM1dSs5QXU0czI2TjNuUlJzdkRwVDFucHJjdTc5K2tPallNWVRVNHZ5U21ZQld2SFJET2x5NXhZei93OGNRbU12VzN3TzVtWmJkSjlpdFhrMHdUTWh2RjBXQXlvSlJIRUZyaVBGU0ZCUnFodmZxeGp1bVdNY0ttT2c2cnlVVFVpTnJ0OXF5QmRhc3QyVTdzVFh3eXRodEZSZ1ViUkVZSWZNQ2JZTmJDUStIbk9GZ0V4ZWVKUjd3U0NXN01WdWlPTTF1NkcwczVnVWVITitra1Q1cHNXU2dDYlI4QWN6NWIxRFI3QWtleThZWStLd0s3YzE3OHo5MlNMbkJLNk94YVBBZFVVbDFZMG9uN3A0VWc4U25GQ0VUdmNNSXdta3BoL2MveFJadWcrdEdSN2xuU2w1UHF6ODZRQVBSbmNsRE9IMjBTWFBxN0RlNDY0QkplSHdTeFRnemFPVWp2L3R3RjJ3QjhYQmROaExxQ0huV0dJNk1LNGduZzBqeGRXYk0yY2xyaVYwT2ZaQVIwR2xqOUFwRHBUZEtDWVhIR1NyejJKSnlEakZ2TEdzQ3VUUzM5b0JrVFhjS2I0RmUxVDFVUUpiZzNHQUhxVGp1bU1YdWVlU3VEcjdsdmVmTFNGbDJMbHg2MFVuVHBpdVNIdVNMT3hGOVB2RmdkMjVPMUY2NTFmMytud3VSRjRNZGQ1SjBIUWpLQkRZUlU4Z3pON2hyM2FUR3lQRXFXSXBWclVCTGE0a2lXM1FucG5Jd1BIYXF3Q3JiRHF0ci8vSWZPU3IyUWNDRkYzam1WalRtaEYzMndyZUR1SWdaUUNONmx1dEtZazV2MlhSdG1HZHpTc0RYUThOTkJyU3VML1VXZGV3TFdMME1YQ3Z0MU0yVS83QzhkZURsMitxdnJzNWNrbXc1eDVWNDBSOSs4dGVmak55am85aU5vZ1BvUEVucDlOU3dQczdSQzliL3VrSTBiT2lxTG42Y0xRLzZFTk5SVHJjZ2xVVkhXYUJYcVJjSTY2MUp4V1JCUnMySURKc0NxUkhjMzFpWDQyL3V2YkpBSlJnSHZDTnVxL2doa0JzYUtCYVIzdnFrY2tBYWZrd3hXQ25BNmZMMFJ0NHJsdzNZTVgvc0FzTU0zeXQ0c0Vpb1I5STBSN2M0bCtaSDFObkdYbVFaZzQ2clJVS2ZLQzRaZUhuZXVvNVQ0bVhNZ1pOSjVYLy9aZjRzZ1UvblQyeHE2NzcxWjYzZ0JsVWZSd2JaSXFIMzNFMURXcWhEa3kwd2lhK3VNUERUOUptejI4L1VzNWR1REl2L1ZJVmFXV09yRGR0T3M3NXdVVGxOdTVHUnhWeXgvRFUxckEyRngycm8yY255N3pKMHkxdHhPcWt4OUVXRkl5RThuUnFxcnVFWThIdWQ2b2F1Y1BBb0ZCdEFNdjc1bTUrRUJmUDllTkZvNi9vRFlLblZqSVoxZDZRWXRQc0tIOXpCa3kxaHg5amhEOWpBN29waThLNURudi96SVdoRnV2NW56T0dPRU5mbFdYMDhrMzlKSlh2aGNubFZpTmxBbi85aXF0SWRKWnh3QU9aUFhCMm8rTy9sSlRrMWNsZDR5RTVObkZ0UnNMV3ladnhoZFVOd3NZcDFjRmJ2cWliVk11QzZQWjJHR1hNaUJTT0NaMVlUcFkwZEpLK2xQRGdhclhNY1dOSlZPb2lKSUtWTmtMamxTc1Y1WkZ2c3FEZ3J6YTkwejcyeDU3TmZ2UktJTEJrMG5kRTcyU1VJRkl1SW1MTDBmbGlJZjlhbUNqdDlTSmgwejJwbU94QklzR0F0Z1hEK3JCc2JIVkpMeVFnMkYrcGdvaU1LbmFtN3pIcngzWUJKYUJMcU1VMmtSc3lNVG43R0xtYXd4YXlwNjExMEl6RnBtdXRmV2tOcFN3OEdJdFpubktJYm1TaUZHaE5NYndkRnYxWG9tY3RpNGNtaTBvazUzNklheWRNVWhuM05LVTVDTFZ0cTJaYWZhUXZoektYOUpWQTZ5MkVjMVBkRG9UZEh5Ri9jQTI0VWlKSXRRYnIxK2YyUzZrWmp5VXZRcFQ0QkJ3YUpoc0h4SEZUcnBIdTRCM1dDZ0FZanU3aUFiQXdJMkN5blgzUnNwVDVIWWE5Y0prdCtreVh6OCtUTjJBZjdTL2F2d1B0L3ZMWWxSN1ROQ3hxQkdseG9hczgyWmlaUnNhQnY5bFFwQ0k3Njg4bDdLcWxDd2tPUFZ6VmRQT0E1SXNKanY4OHJmR3R0dEJsdktTLzIzUmVDVjJTWlZ2YWYvL1Q4QWJlVUFjNlgzMDhJdjNrbnJPYXNGRnJzSEpML3Nsc0JmTFZRUEFhQjBxS2FBU1BsMWZRU2FObEJXaktNaDhidGllQXM4VVBtK0t0L2x0Tkp3T3ByTDlwRVkvM2FPR2Q3dkZRUzVDdWpDL2Z4L2R1ZUxuVGRzNmFjZnZqT1UyblNQZXV4WlV5NzBBVFdHOWZXSjZ2RjNuLzdmd2pYMkxBUlUvQU5XaU53cjdUajlDSnZsckFuK2dpWmRMMnRIa3hPVmtYNW9abTNqclpJaUltcjMxKzVRNzh5UU90WmlrczVDTWh3M3Y2K2NLU25PMk05L3YyNWhyWVB6eDBhcjBJTjh4NElORTlwa3pxUmZQVndRWTVackc5S3VvOVRsckhHTWROVlJWbFFuV2djYUZBb01lcFFxWDVXczVCUFovQ2lOR0UzUXlYcHNmMjNERGdZM2lqQ0RtdUltUWs3Q1laYVA2OGx4U3ltLzQ1WXBZZnpaWTJ4UjBXTW8zVTRPTWRDODBqeVN0REtJVStjTE83ekM1R21SblZZcVVwbStUNVVJZURQaVR2K2FETU5MT21WY0NQT3B3K1NaSHVSQmpiUlhjM3VMT3BaTDlSVGcxYTlBSEJlRC9zaDlYREx6WVNjbXl2ODlmZ2pyMk1ualIydDNmRTVqanFLMDZjSW9vYTkwbFZmUkJCVDl5Syt6K3hsUm1DbnZJaDNXeE84a3R0MnFVbFZGTm5ndWNJZlFNbHo0aEZycHovYVA3ZWNqb012NmxwR1ZjOW5yckFicWlRbHpzUzhiM1dKVk1MZEJtS0JJNTFhSjNzUkgyMW1IR2dNQld1aUF5aDk2aUNaN29HR3FxT2ZmSzRyQmc3Ull0RzNtWkF3bktPODVJVVlHQzFoUUxhbmgra21zWjZPNkJvaCsrQzVlcHFNcjJzZUhuL3lwLzZyTS9tdlhFMkp6V0xNdlQzTC9PclJhdlpIOWNQNnNtUlE2Q3R2WHgxeDdYZ3VMUjdOdlB4RTdHWHJNOTh1NmF4ZVQvSTlQVTlIczJaRzRvYzRxcWJ3aHFud0gzVHZ1VEFURmVEVWNuOFBtR1VsaWFvM09tNGthTWpsMCs2ek5rOEd2Q2V4ZHhIUkxJWE5WTmhIZXBIUEI2NUZ2c250dWwvMW4yZjEvdmpFdDVLVCtNNzViRUdxd1hreU4xT2tqeXc2RkVhME1HL1drTUlndFBtN3hIQmY5QjZIeGpscHFHekJkeE1ZTVV4VTJBMVRtZGdqaFBwWjlRQ3lUSGNhZU5IZWVpVXh1VTBiWlJXQ1hDbXBSYU0zc2pxdE4ra29ZZnJETGR3RGQ2SHUrQ1YxU0VIdkJBaGM2NnYvbDZPVGVKelBpdmdZZ2E5ZkRyMEtNdjZTQjVVOTkwek1TUGxjQUFRSWdHVWhncno0dzR2eTNzd1NlRGNmNVFpSzUrMDNCL3B1YXBML3ZsTGdPbUtVcUsyaUZLZGJHQmRWbTB3bjByNUEzVDJsMFFVOXZXUXJvS2tHVmNRN1Q4SXdnSWZwSkc2dTZSdGV4MXRXV0FwSWhYYVRxaVI0RzlrYkh5N21Uc1RKbmZQK2x5R2lpOVJIWnYwZ0lPWmxYSTZWU3JIOXA0cG5RM0oveGJla1ZKWVFLRFZOTFljSm9rTXBJTFMweXl3dkEwRTRBcVRSRXZ1VHU4SC9nb2Z1dXBlTnhzVnhiZUlIUy94Q3l6NkNRSWhTTDcvUElPWllLenpyN3kraFJGdDN1SXRHNnBsb3NTd0VaRHFuazhKb2gwakJMNExBTkQzaVhycTlzM2Y5NXZ0aHExYWtMSEhyMndSNllORFNOVjQ3TGVPQStKQ3VtK1k2aFJYQmpqcThhTFBsN3M3NVdibVduRGdubWx2U0M4TVJCVlhRM0thekRqTEwxVy9YMlFLSU5zcktVYVZQbzFhZHRyNTI0T1pqdzRGWDFHN0wxb0lWS1RsM3lGcVA0VllJVlhyRWx3UDlTVFZSMkFnS2pZY2hvZFJZMndzSmhGcHhRbTVxc2djYXgwSW45TWRMdFJmbHNmTkxCQllCZ2hQQ0NRMWRkb2dndGU4RlczbzluK2JPNmRVamRFRitONFVpVUoxcEE5ZzlrdTRkOVNlYWNhRW9YemZDSjY1N3p2K29odGJuRm0yeDNJSU1RQmlUa3BSRjZXSEMwWWYzb0dGZk9WUE11RzdBTzQxZkNRMVQrb0dzT0tCdDNOVUl0Nm9ET3o2L3djS1RPTGgxSFV5T0loUEJlRkcvNCtCdFpSOWZmNTIvWjBucVVUOW9aRWI5U2R2ejhzbHl6ZTJqZHljL3IwWjNsV3NtZjJuWG5ZSThBK0xyRzVrZ0ZjTFozb0RWRUlEbTRtQWNuK3lCRC9kTWlXRHlqWm1vYkJsQkZ6a0dOWXR3NGFPdkFiS3B0N0V2b2cwblAraXZlam9xcmJCaFRpNSsyemNZSkFwdkRTeDZIQTk4c2JWZWtVOTZqNDRNYW5nbFFRZHhzSU1LdHpYSnludGo1NTZLMHFOTDFJcDUwSm5vWlBEZFFCOGZpT0trUVNOSHpPR2VZdGtaQ2taV2N2TldrWkJQbnQ1NC9zeVg1MDV4NWtmLzYxeEdkdE02dVpkWTZJYUlLVi9sWnRiQURxbVErcGFuaTJubzdXUUhKVHM4dy9HaDh2Smk5MnRNUnd6WHhWa3ljUzFWWXFkV1lIL2xBVE10ME1DY3JIczF1dkxPVFVKdWpKMFg2emtZZ01HcCt1dTVYaE5JWlBpUUFOZVp0WXViUnYvYndhM3FwUDVBSVBMUnh5TVBkVWZSSnR6UFNxR1l1ejVmUkNpRTlVWVFvaUlORHVzN1R5VlBJck5RVVcrRmJTU25kTzdEV1lTY0tFVHkzbDhDbnAzc2ZIY0w0aC8rOUFyMjdzMTBmajN5MXRXZVBmK1ZKTXowNno5dkphSEVQWmpoTDQ2a01nSENSRlIvS21RcHJFdTJ2TkxsN294RDVRUGh4TUNkMXVrU3Bic2x3eGtkNldhaThyeklORitxVkg2dmFUa2wyWFczTkRQb2xLRnE4SUFBdmJocVBTV0pGS3hoK1F4ai9zMFcxQnErQW92SHdDMmZ1VnZ6SUdCNVJQdEIyQWJDckdVd2crZXpmSHN0QjVVTTdNMXBVb3VwQ0JRTzVsK2IzU0dxem5BRzVWTFFmVUo5QXU1bGFPRUJMVVA1K2hMSFMvK1ZEUGJKWks5dExrSUErUVQrdmtUVmovTGpPU0svSGtKdFlvbXR3SzRmcmZ5V2EzcGZxby9ybGg0citSMzdHYUlwV3FCVXRieEFWVjNNOStSdzJwZDg2Mnh5OHVuS3Btem92UXhxeStqSzdVblFFdE90VHgxNHkyNUY5SHJLQW1LbURscTdNaE91L0M1akFMZVByMW01d3RnTkpKQzhXbTJRSjNENjVjMEU1Z2FrQ1ZzL29pQjE2NVBMUWo4NTRTQnRiNHl4d2NRK0ZXK2V5emJGaVpiWEhEdSttRlZDeU1qSjJ4Z1U0UTJ5WC84Yjhkdi9lR0w2bmxqOEFhVzVIazArZ3NaWEY5VzdDYWZVR1BkcVgzTXE0MzdEUTMxWmdnaHFZNVBheXNtS3JUc1ZaekVhOU5jeUsyT2d5eUVUNi8wZ1dRVGNHRWhOM1IzbTNuTU5EbzlUaXJTSWZNZWRZb3Z0V3ZtRjUrVDlhdE04R1g2aXBiS1dyZURVUVNURW1jWWNlMVo0Q092S29OT3Z0Y3lzWnZJQUQvN0tWUkNvR3YvdGovRUROK0dkYTVucE1xTGx3MUsyUkg3cktxR2Nrd2FoT0JRaGQvejVFZERNWm12ZFJ0alVCeHhLYkFSZGFKck5reWNmOTVGTTFGczJ6WituQ1pvT3VXdnh2K3gxMHYxcC9tbi9yRW9ablJkMEFsTWlkeE5CbGdDTUFRQUlWVk8weHIzZWw5SFhDMDlyd1ZVZTlMemNISk1ibThWNWZnYkhBZUJ3a0Uzc04rQkNpUG1wR2d4QXViWVJjdy9YK1ZuUTEzS21VRnJBSzlhYTJoWXB6SzNJbHoxVm8wV3ArdFBXUHgxVlYxTHgrbnhwTkxrNXJFVWhLTENESzQ5MUxTbVBQcjkvQVR3VmFoRWNPcWpmMlg5ZG1MZkw0czVuc0p0TDNoOWlYRTNocUZYa0RCc2ZERzVwNWhZdm95SGJwZmxUbS9GUXJ4aUpudkJUcUtNNy92Ri9nRDR4cTZnNk9mL081MmJtOEhOV1IwcFVSQnprMHhZaTZQayt3Z1FEZlVxSHpvYTJ1Z0NLUmIxV05XaDRDWGczRjNvdGhSV2VPSFdZR2ZJVVhudUlEUnlTRVVlWm43NjZQT1dyN1EzSnRUSDJHT0luZDVJOXk0RUJVZTgyQk9iakwzOWJyczdNN245R3FBZ0Z3NzBVd0hDalV5cVkvZTNlM0k1S043STQvbDJENmFxNkROSEh0V0x4NGQvYzMvbjZaKy9GTnVNNzlRNHI5ZndaRUl2WEVrZUtLSzd3RDg4b3RyYVo2SWdVcVVGZWdORHhHQmNPWCtFditDR1dGWkJtVExGQUJ6VlozQ0QvKy9IZUh5N1ZENGhHbnJ6OU9Id2lGVWdEbVJhdnBiSmRGaXZidEtRYVhyMzEvdWQ5SWo0Mm1oVkVRdnNSZEJpcmlnb1dya2VBejBueWk2K2g4QWtxNGVBcjZlSlI4WENvTGlnMHBjU3h5M2tFWDVGbE4wNlBYZ3d5bUNVMkhZZjJZNFhscFZMejJpRUZaOHFYaVhEbnBLZWxydXBHK0oyTGNuMjBtOGYvUjZZa0UxVmx2NWpteEswaFBqNU5DQlB6WSt2NENaYlFLdktYNE1iUi8zVElMSVdOZ05KcDMzOHJwWi80WWFuc1RreU56azZLbEZDblVMKzJCUGtRc24rNkh6dDIvMzl2aDNtaGNaaU0zelcwc0ZIajBJV1FlVEhGL21vU1dkMm5oZjRZWEVPNUh5UTVwYXdXMlZBL1VkZzhvRzhjZUdzOHFINWVjRWZLL0REbzJIK0x4YzdQTGgvL1RXVXY2dW1kbktEVVEwQTZNSW1hNDl5NXUrUC85MHJybHhSTlFveVBQMFd0ZFhhcVZSdUE0bDdvRi9jTXBiOTJFcWU3M1JNQXlvZ0s3RDdxTTdBTUJQaGRJaXMyMEhLaFdZK0dPN1VKQ2dsUGltck1qaDJpT1IwZG5hUXI1ZGV3Zzhuenp6LzhRRnZVcWRGaGhGWEljb3VWcGJyRGMyQlVCYS9lMUVGbi9KUkZmeUVpT1Y4aXh0TVArcEFBRmI1MlhrSW9tUk5qN0pzRDVWZ2J2VnBCckVVQ3lnaXExZjJwSnhMSUhNZ01FbTZtU0RpZjBZWmRaNTlYL3NBaTFJSUFHMVdleVlVSWQxTUlLbExBaVZ5dzVkZE9SejZwN0wxTFRpVTN0V1JONzRRN1QxT3dwVzRjcjBKR3VkSmNXMmhBYWtZYVFmZFF5MXUxU0JlZDZ5cUNsWHZwYjJmRFpSZy85L3IySTNFb3Z4RnF6YlZyWTRXSUdDT0ZsdDk4Q2hPUUNaM3ZIemtubGp4V3p2TlA2OWtoRGp2ditwVkltalIzQ2trTzBHTXpFN0t3eCswTGdPZE5GdjM4bGNObkFBQWdBRWxFUVZRRk1ybmk5MDV5OFZJU0Joa09sb05mdzN2N05sQ0pCY3dDTnFNTTRqNHhLT1VDbU9TaldKQUMzbTNBWGZWY0FnR2NCVzBZT3pkME1NVFRXem1IZ25KQlg1NGYvQ0oyZmpudkF5TURzeSsrZW55NkRMNmRUSHMyMWJlcW90MUtBanVRMFVjTi9ieHV6UlorT3BUL0FPRTN0cTNUSWM3M0VNbVlUUmVkRllHK3lHT1VhajZhMUppdmJ4SFZyVWFJaHhhNUxlQ3pvMFBLdWcyWkNJK3FFTzRubWYzUGJwZFgxeW5pZzg1NlpLb0VMNDBGbVNJYTFpSEczUmZxaFFHc2FqZk9NNEN5WmJLY0FNSEx2a3RHSU1aU3NsUitaaUtkdmpzRmtSRkVQL2hlWHFlQ2hCbDlZSUNmWWt1eGptSnlRWXB0d0Vna1J1Zm1NTTJVN2t1alliYkQvalFKMG1xblByaVB6K2RmMGpEZ2hKeHNucEVRME1oUmFXMXVMalFWYlhJNS9ZdDRBRzhnbk5HSHJadXJLd1hFMWxpTkdoMnQyS2hMdmY0WmVVSGt0MXp3UlJCV3U2L1doZXM4RHQrVWVHVk1PaHlOakg2eDlTYnk0WmJ3RW1ndXVnb3Z5dVV2VlAvbDU5bjNsd040T0pnRWJHYnNUVEt3OXFCNWkvamgvdVhEVldDWEFNeWpqZUo2ZEh5THJrYWV2elZXc3dsRGVxejR5SzlUSUVmZGtGdXQzSUNuT1lENjM5cGtodzQwTDZCeHpxQzdodWdSamNreU5OVHRqak9TTTBOV2xpb3Z1SCt4eG5mNVAzTkNta1ExTFVzUFBUamhYb0Rnc29LTlNkbEhzK2N5NHRNTVpiRk9OTkJBUFBha2dIM3c5aWdxekdZQ095UFhQRlhTVUwrUkZBaERoQzJXSXRUOTUyOHB3UWM5ejhGVTVtbUJBamc4YUsySUpJeDNGU1lxMmQrYm9WaVVyL1hRWlFZcEgyNGFJUndBYTQ4a29nT1Y1bExSYVBtYjJXZXAvcERoWUZxenZxbW5BUjBkYjNCd0RHNmFScXdvZ2tCMjRyU3Y4Z2VMOWZwV1BiRS9PakZuL3p3WGh3VFVrTHhlWlptM1ZLZlhEWCt0ZEdvYkRZNVNOTEFMU1AwaXkzSkwrdHNYM0NZM0FiRWhxVThmRDZmSExMM2VHUUFZRGs5ZnU3dFI0Q00raVRuS0ZIbFhOTkpkb2JieUxRWUlSL3RZUGpvN0c0WFJYVkozODV0TGhTKzJrTFE1N2hVMlVwNXFpeXJmdDE0dEJucE9pR3FPa0t0b0JzRlFnbjEvb040TjdmemFDd2svSEpjejVGbndYUUpaWXFqdFlDdXpOVGQra0ZHWGh1S2praURrdWpxelFzeFZ6bkUzZkN3aFNqQTh1WG56UGN4dXJNY0liS1lmallmcUJpeFBCazh6L2xKNzdKdWVoSUc0SE9zY28xY3JxMFRXUnJwTnJOUHBWK2w5dC9QT2s5c2xNNTl1QWh6SFZiQmg0QnpZYlNUa0xGc2dJaVhwRy82OEFVdFBoYnJ2bVd2bTVqdUxqeGlVUkI0NisvblVaR3hPOW9XK0RSR0R3S2FZOW4ycE1MNTI5azlzTHBPRDVjei85a2JrRHRmdXAxWWhId2Z3VjF5VnFsN1EzVVlHZWk1Qmlwck4rS0w3WW5YU1NEV2ZIMktpQzFBZjl3WnFqSXhnR2tCV1M4RDdxSGU5Tk5CcXY5M0oyNmtsdTEzOE9tS01MVnZaazhkWjdDajhmRTFzbHBtUzgyQ2VrS2s5c201UStTRkJtc2ZveXBERmxnTUJpdFFYV255RkVrYU5YQzVST2o5MXJrbGxVUlVrYTJqbk1OR053RW5WblNWdmU2UVZNbW9rUFdJakNJak1sU2hkQThBbGVHME5wSFAvZUZuRXV3T3RZRzJtUHRFd2lFeUhIRHNsWjVkb2NMc1l1RVRVRG15dXBFQUNlcldlaldpNU83TDFFSi9UL0NnQm1yaUJOVlNIK0JyeFpDbHJUazlyRFJXNTNORUgxcFZYUzBSRVVQYmlYQ05ZN2tUd05rZm1DNGlqYWVWQlNpeGxNRVZIbm1ycFZuQ0tKSnJmdGZnbnkrSDdWVXEwZG15d1oxa1k4RVZyZkNZaHlENWpBaFZyRXlFNWxIR2xIYjlrMDBIQURhbVB1dXp0MjJFRjUvcEN5L05LWjBoQVFLRC82alZTRmtnMW5PYWVSN2dFU05XZ25GRmdKdjdyNXphRU8wN1ZuZURSMm5KSG1RSGZtY3hWaDlXWjVOd0VrNDZiRXluZ05TUUU5cktrRFN5Q09TQTVSbWNEQzgrY3E4WGx2SGcwZm1ObEs5QVRMckdKMDVNWmlZM1YyNVQycWpHOVV6OFJMS1ZsSXVJdTAreDFNU1VQRUVhZnZtaGNIZ0V3c05lN3Vmb3NWNGhvRWQ5MmJlbTlPb29FSG53a2hPOWZFclYzbHRpd1hyKy8waGIxUUFXekNnN0lreUhKSGNhTE04aDlONThYVlkwd2s2bGE5enJCWXltU25pTWpjajBqZVl5aE1QZHZVaGdaZHpHOXovbk1BRmd5RWUxMllUWkJjMVhDNmkzY0JxVWx5Z25iVmhOOURQQXp2eGIxMDFSSmdWMFduVVRMZzlYWmVCUytTL0JUTEhTcmtIcG1WV3JEWkkyRHVTOHBSK2w3SHBzY0JaYnRla0ZLSExaSGRUMGk0WW9jWVRjRFNKWERib0NQb0ZrTlRJZTdralM3U2FRMEd5QmYrZmdKSjFoMnd6MUNSdk45aC9KUDRtVTRTelVueThPZUpEdW1LY3p3eWNxVGhMdmlyQmp1UnYrS3BFUHRuWlQ0K1N3c0RtRXF1TWxTZEl5dm8wYlNzUEQ1UlJlZWp4S3pGSGpTZEdzQkZnOUlEakdJSjBQWDlCWGpBRS8zNzZyNG5RS3haTlBXL0M5UzhQNC9Cb0k4OWMxWjNOYzhTL1JGRy91UUpWcnBlM244aDRvRnNLSkxNT2VWWjRISEp1Qi9vVzN1by8xek43V0Q3UTlGVEQzNFYwOURnRXp0MkNBcHNEcUJCeWRmZXNvTFlIdlF1b0dzTDFEMmtCTnlIZEd6MUJtM2ppalppTnJ5Z0djUGZVU2k3eDZlc3JLbXloMzNERDNOWENjNnNOY2V4ZkNXWmJqNVg3WTVMNjl0a01PcWk3akg1cy9xU1Z5V0VWVm5iejJLZ0xPbEJjbWJaa3BGUXRUd2h3cGVYMkRsMzFGaDVSN1FQWHNjK1lvRVVHbFRSQWZ2M3NwMXFxVFhzQU1mRmdkZmtsQVpNMXFTdzdHUG4vK1pLQnJmSTRVaWgrWmFIMEl5TUFpRVczM0RnMFJuVjIzTG9EQXpYVHpvMUdVUldmelRYYVlhSmwvRVJ0dk4vYXAxSTNnbzc0T1l0SUl4c0cvV2NjSmE1RzdTNkhSUmpINy9sL0lUaTFzMkFFS1BTdW9OQzJzWDJmTWowd1Z5cWZBdDV1eWtkTVVtdGpnV3d1N2txbXhaQ1pHbXJuTGlhRUJCUjNYVTZqYVlQRThPcVFMWGxZcjkvbTNaRXMxYStKTlRLV3Z0QjNZTGZOUkNHZ0V3aVhQL29OOStZWXU0V2dpeUd5WHE2RU5Jb09tL0EyYldVTFBTY0N5djlmRk9zdW9OdzdrTUl0MlAvTzFBa1ZxUEk0akU5bklMaGM3cmFGMGxzU2tCVnJ6TWlPRkMvZmRPSDJBRWgvTVU4a2I5QjRjSjNOUzE3U2RHbkdieG4zclhtWWlVUkMvdlBaQ1FHL1h0dzBSeXczUzJQcXRmTlRHVXM3YkI0bThPdU1XblpwWlh0NUZEdXBkKzFoZko4YmRlaWo5ZlhmYUh0T0NPdCtQbVRuUXkyWU5nRmU3NENDNnMvRlh6VUU3eldNUFRnYlM4bS84UWFwZ1ZydHQrQml0SHdzcC8rM1NuTnJGMTdzTmc4bFVrMEFJaHJQcHpIeGJLME5iM1k1TlNDUE5jaWNSZnZDTXRpWlNLZG13UFczS2Q2bHViVk1DWFpGV2p2eURORVowUlZTcThQRWppTUh2T1pleFN1clFDZDkvZkFqdlBzdmR6T0x3S3ZiWG5rSnljMStsV3RzYnRCVjgzb1pOZ1g5TEsrZFdiamo3YXE5bFl6ZEJhTHV6V2hiOUZJSW1TclVYb2FMcXY0cnk0cVNRMWVGVDVnRTdybUdBK0QzNi9GVHpxV3B1c2RUNWd0Q0orMFArY1ZZV0tFNzBQSkJvaHFnQlJIZXFtbFJ5OVNBa2J6YjFuM0ZXUzFHQ0hqNUdXUDUzVUQ5bmlBZHFvcDB5TVNUUVN6bCtRY1l0TjdQaUVzTVNlbk4vVnF2THBtMDQ1YjlPczhXb0xpRG83UmJKRTZMU09aZVc5ZlNlVHRtcklYWFJUa2J5aEhWR2NEcFFaZGZ6MHZUMlpVNXFTNFdtQVdnczZTT3pDTnBJeGFaUUZibm9hYzNObSt5YWZLZjJNMC9kLzRHU2hSbGhMbXBuTlR5NnFtWi8zYUE4UElPdE1xZS9TcHNoUTlUbTRoaFhTNWIzRzFRYjlRTDF2OWM5NEYrb0oyempjVGF4akV2bjd2NHZPYnpmZXBrazRXNTcvb2R4TjFSNG9qenk0cU82Y09xbVZGYlMrS2JwSHBNUTdsckJ6WEx5c0poV2c5Y3dHNWw2YjJXTDNEYjFPNnVIVFg1Y0kxMTNNd2F0cXNqdmdFQWJ1WkdyQmVxR3ZqbkFTcmlzd3k1Mk5vTFhPNDVwRjNHQ3JTNW1vbnB0NC9NeGN3OHk5L1pCZlZMMzdzUm1PVzFJd2V2cWVKN2U2N3dGTXZmQllCdWh4WGNtMzR0RHZuNTJ5eDYrWlQwOWx2Wkg4eEdPcERvdDJSNEhERkF6MGJ5RFo2ZjBORUJWdVB4UFU4UnhaS1RrcjVHaWxCY1h2ck96NytET1BEWHlHNHRmZUZUZU1FWnllVmlyN0RWQk1zQmMzNSt1TzZZek04bzFJMGNMdXk3bzZoM0puVVFvc0RoR2xxUW1DbUZrL3BNSVJGdHhocW5mRUxXNE92L2I5NjFwdy9iS2xvNTYraDJMVUJta3JucEQ5UkRzY3BaVUNaWWR5UWJidkh0SlV5ek9TMXRHbDQrZVhCOVVqeGhJRnpEQzZKVXFFYjN3WVFlNnFKOGdONXBrdFo4S2g5dHFSL3ZvT2tJMmhROEpPZEpmSVVaYS9CS2dmQ2lVblk0b2RoK1ZldU9LeXRsa2RLcHRMUE95TnBxU01ScnVwYUpPaG9sQWxMOEpmQzgyejljbDVIYVRkZmNVWFUydTV4TWxQYnY5Y2c0ZDRzbktWSHBPZmtoK0NIQURBWllKWmU5MTh2NHduUHFXQ1docmNQaEc0WGtvRFlHUytrWmljcGdzb3NwdjB0TWNudjdqZWhZaGN3ZDVLZ2dreDVndTI4ZzF2b2c4aDhma1A0YTN6RXF4cXlUVVFCbGxEY0xaU0lobTJpOFg5UVRSMnBxcThFTDBHMFFLb0pxNXR0a3VtUkhqdmJjcXJuQzREaFRzb0VzclBWaFNkcThUM1Y0d2hpVDd0aURpVmplNXNBYXN5N2RTTE4zU1c5aEpiN3pOQ2NYSkE5bU1WR25ZWFJ5WjIybEhwOGZPMWluaXlTN1Q2QysxeEdpb3NZRnJNSGxzcENndDFkZXFMY2dYQVBSZFdkNCtmUStlK2llWjZiOXBmMWp3eEFUMkRERUM4MzN4aUdpS3NoZjlqelRYZ0Yyc0RpYm5NT3ZPNVZTeXlsUlByS2IxNW5SOHN3bnRYTFVUUHNzSGRMU0x1Wk1WTnZuQ2h5S0VKYmRJbmN6NDhxODlIU3RvdXBmUndpWFdYSGozM1F1ODFIeDErNmUrMmtVbmt6QjJhSlNCYzdkeXpLM1VESXRkdlVOQlJGaWw3cFJGdlhkWHhrV05lWHdWRnIwN1EwTWVrU0VQenJuT21LU2hhQXhrVXNrQTNZVjJkaFl6ZWd3WDA0aWNyM1dYWGp3MnBJdEY0ek9tbzUvTUdQVUR2MzNSOFUxdE1jVnB2UDFSMWk0MnlVQ3JzL0dKS2QzdVduOFNWY3l0WWtIa3BwK0xzMjJCbkwrWERYLzJGRGhFS1ppYXBpWU9JRTZSZFZJRnpvdTFGcFlxV1RwMVN5bG41bDM1LzA4NnhvZzh6MHdYOE5PWWdSNWRLQmt4QUtjTzhLT2ZEVFVOSEpqQTdnVllEMDhrTWFCUDdvWS9wajZyMGJFdGlVNXRYbzJEWmt2c2J3RjlEVTVsWnBWeEx4L1lzaFV1NzQzbEFha29jUGh1bFhxQVkyQjNydGZncE4yZThNRUV6bEYyeHg5RSsxN0I1N2FjVVJCczV6UnZHZXdJbER0KzNONmFpYXlUQ2JlT2sxMjZzRkkxbHQ5YzV4a3h2aGpYSDdmOVdmUDlkaVl0UTBKR20ybmU1dTFBQUt2TnpzQlpWYXVTb0VTd042Y2Fjb0tvekdVczZIbDFiZHAwelJXc2NjWmdXSjNzYVhZRHhuUU5LZ2tXQ09kSXJGc0FtWHM5dTRsdmRpbzM3NU9JRjE3c3lpVE1nR29pMW9VVmduK1RHM3JQbHYyTUVPcGxTcXBsQ2hvbHdvY1FJNUM5ZUdGVzRWR3RKZmwvSjJSL2ppWGJxODNOL3dnWVNrM3ZiYkgrdStqa0hUSXVXbmtyNDZvT01NdlpveDAreVpPRkVhQXlXdkp0dDlqak1PMzZxZmIveUg0bDdsTzM2NUdrUk5qYndYOERCU0dKWGN6dFdtSFI0bDVUbG9COHZGaTdEQkMrNTRSdEc1YzFXQTlTN0w2YzZ0Zld4bm1STDJtZVZhb3VHQ2ZRWmRlcVFxdnNBV241MlJUejNRaWxJYUVzSUFscFAvRFZNanZsb21kU2FMVkNVQUs0ZVVHSVVoNDRtbnpRUzZyeDJIaXQvdHBoZGVTNVJvUGJ5YStjMDkyZFdGaDd3SXlZNWtDeXgra0pVdU9xbmxpOUZSajRYMTlmMG9DL2pWbHFIS1pTVVZvL3VlYVpjdTZrNGRIQSsvSmpHelM3M1Y2WEwwMEFDcFBNU0ttczlsQS9Zc05tK3VHeDdQc3crQ2RGaGgrWVEwYUxuRHR3TXByL0hlY0EyMGtsaVFyZ2ZHU1laTXhrRTlQQjlhRWVqZ3Zpbi8zZmU5aUkwSUFGOXJyTDZSWnB3YloxSEk3ZEs2OXlSNWlPdnVIdnZWMVZjVldpaVpqTXd4dE9vSzlqVC9JaUdocVVlWmR5QjBNL2ZPTC84MGkwcnFtVi9Lc1FyY1pqcmhHUHFRTXlKdnpibWkwUUgvL2ZmVHA4RytFcjllczRsTjBNdXRoUkN3a3hmREloeU5mN1ZqOXBrZ2FXMVZSM3kvRkFIMndKQjRHeHplakUvTndjTEZoVEo2dWEyN0d2dng0STVkV1NpTUJDbHhMdGZ1dmgxdmRISDNmajRXYnplR0I5OWpmNWhIekNRSmlPbWNVTEJFeFZ5UFhhMmpqdmZoU0xleFJ5ejlVdmdWQndwOXVYWnpYUSs4UHNXQmVOZU9ORVJkYjNxcjRkOWgrUmF4T3R4YWtYT0prZGVkZk1QRXh0TFZsbWxtK0VvOWx4VlM4Ni80bmtTVnBTZEpzVGFyQlNDckhrUGoxK29kMllYZCt5dEdtN1Znb3J4eDA5aVRSQkxXWmJtV1QyRk1WdGMxNnJjL1NxSTg3S09OWFFzbm12c1pEKzhiNk1aTzVMVTI5UDA3bHdmRXQrSHg2TVBmTTJsbFVIWlY4elc2MEd6OEl2ZkNRUkNVSnV3bzBZQlhUQ1YyVjl4NERPVm1iZks0akhnYUkwY05JQ3k0bmlBWWJsQ1NiMlI0ZGd4SGRoZ0kwY1FXTWFUV0FjSGhzRFFkTnNrTk45Tk1Zb2ZiT1BnUVJOalVMNjVWZUhYMEtqQjhVQndncEcycmhkK1NvSHREL3ZrbzB1VHpVSm9BcGhYQjdzc2ZSYy9nVnFXaUpJM1JjNXU5NE1vOCtLNVEyT2NlOG1jZlBMaVgrTlJaVlNKYzZzNDRYRnJYWlh2YitlQjdsS2ZxbCsvTExaKy9saEorNWFPanZncU5naXdpVGV6LzdQU0Q1MHFNb3V4V1pEbEFQcW5DeTFMV25QRVovbkhxZ3F4ZWVnR1hlNXBZNVg2VVFySWNGQytWVVRJTS9qd2FjQndJbzNQdVYwajZZZ0dRUUlGcm83Z0dpREgxNUJMZUxOZGQzNEpxVG1BSnUzeE9UUkFRR2ptNVp4N09Mc1VPazNjMkljSFlMQzhzQ05OK1MvT3pSWVIySHVXOUhjcjZOaEpPeXpXa3FPQ2lnM1FYNFRLaWI1R0R5WFd1MHFsL1NGZ0pWRUo1cmxUbmdHcFl2K25vQ3dMYjZtQlovMXExU0k4VVFoZWppbExta2d5SFVncmlqSGRBTnZOQUhlNHZkUGF2ejJBd1ByUjhCUzJ4bENjMENJbEt0TVVVRlNCVm1SVzNBM3ZMaHdxRElqTlZoRGt0Sks2cjJPcEFKUjBJaVVMT29zYllwbXYzYjBpWGdXOVViRFRrS0RxZGFkVTNXVkdaVGRidnZkUi93MXh3WUpzb3QyTURhQk5OVXk2WVNDS0RRUW16aldaaUIyeW40dFVDSm5QZFZ0K0lLT0VRd211eTBLcFBLQXZXcGg5Y0kxUXpyVDZob1FoRno1dk5IM3c0VXQ4bElieVlNSXZBRzFqMXRaVThFNVlWeWl5aGd2REErSFVJQytxOExGNHU4ZEdVYXNPV0hhcEtFTk9SNFVjblk3a1R5N09yUGlndXJaQUdXaERjTzJYUERrb0dRVERoMy9zc2dueldGT0VzRDd3cDNNTWxTVjRCMDFWemtRUUdZZlVIdCtWQmFCczJuQ3VLYXlHdUVmMDNGL2QybUFBcGtlS1c2V0ZOK1hONTVES0RZZjRidW1sOFRsYTJuZzVZM25ZMno4eWh5QWlQaDlURzMxRDdyMHYzVXlxNWFqZjFlNURKS25HRTM1bFMxZ0lUdTZpdHNyM1JkZWl2YWdEYk11eDJKRndjTjNqL3BJWnVEL1RJQ2ZOOHhIVWRkN3l5YzgwQ04xQ1phNjUraWpPSlhKUWxtdGo4UUZWV1VPODlQOXRPbGp1bHM5bjZ1eGdhWTdQY3FPaVY0cVpqdzB4dnF0a1V5dDRSb2YxdTlwaVo4R1FUYlJMNUY0Q3VYY0NmazlzNkl1bFNFV3Y5a01jWnVGZzd2bmQzNW5Sa05MMENOYjZDclQxaEpZN3Ivcm1reTg4YnFkb2RYRUFQT1NJYmtSVDcxeWtGYXNyTkV0ODRkRHczYWxPdlUrazFsdXp2dzcrN25iR0hnbHBhQjFBV3NnSHF4TmQ5VHQrZ2tSdjNnUWZ3TWhqUmZsbEwyZ0dsUjk3Mlhza2RvV0JIYmlaVXU0ZWlDQ2loL05hbEJKaE03SHBZcGVjZVFnUkpxaEF0eXE3T3FHcGlVUXBMS0pMR3ZQNzY0MHRTelY4aDlBUWpkUzNSOHd0Z3dSMXZ5TjFLY2NVN1ZvdEo1UXFTSXUwVWhMWHZHSE5mTzNPRXFFU1NsZXhLb2xLTmtUSlhoTmplSk9sTk81ZDRFQTBVT001UmIwY0tGN0F1NThEWXl3YjJMVWprbWZNeHNDZGJZQWNBbE93K0oxOUp0VnMyYlFncW9UU2tCR1VUTjRCNE1aWWYwenAxcE1IK2ljcnRONldXMDhTeGdkMU5lOVoycVJ4V1hsN1ZHbmdXVmR2OGVLWmlEVDFsSjI4L3BzbE5iQzFNNkRZNVhURnYveG9SekF0MHUrdjVkbUdOa1JWMk9xbm5XNmdtRVoxZE1qZ09iL1VCTVRTWURXTnRLbUdpbDJKbk9GOS9EZVkyNFVNQVJ5NGVscFVxQXM3ZWwrNW9FQ25Tc1lQcE1HWHFPc3RzTXo0U3ZibERWMUxCdFFUMG10S25mWmFxeUduOEUzWVg3U1hRZVM1cDlKT2dRZXp2YXdXZWV6RDYwWUlBaDNwaHUrUFBYMVNRcXRrb3VzS3NNdzFPdkRSWTVWZnRZMU83Vk1JUHoyQzZIWm0yYWhKNmRvLzRZenN1eU9WbHV5cW54Uy9GVXluUFc3TDJkM1ZEYnpMRlhKdjJjZFB2dzZGL3VuSHBZZFJ0Mmkvb3JKVUQ3WUZmM0FQKzhOVGdoQktkelZpUktIMmxrcWdtVkovUG5PWGFtUjRmcldrdzlLNGIwa3RWbVpBTnU0dzB6aU1uVjBtd0VybGozOEdLeDhxcm5yVU1nZ3hCNXFzaWZSSmg1dDVxOS9CL0dheVhGank3b2cxdkdmbE54ZFZuSWcrRE55cndOUmRxVXh4SDJkTTZrYndSMmEybnRjRTFvUVRSTFlUUUxKb0dsWEc2WUlvSWVmazVYQ09rbitRVzZpYzVYR2RjV25rcnBScWhPNXFuQlU3UEQzTC9CRGMrQXR0NGpRalBVK0xPMGFUSjRBOG0yRTBhZEw2cU5McTFRNTk4c1VDcHN4WnQrMkpoNm5vWDdaUGdTQkR5ZnVmdWtXZmlDYTNPZVUycUtDak53dXROdnlWMU9xYlBNbUZ0WkZJOG9DRnVqU0ZEWEJuZnRKYXF2WUdDNGdiSXJQTHpnSW1janIrSXBEb2xuNnBCQ0RJa3VuZ1EzSllwSm1LdWhHTHpldjQ4Z2pBcDNHaUozRElycVM0TzR3dkF0UXFZSmlac0ltMjhsOXNVMDI0Vy81b3MvekwzNE1rMlBpUjlTMFIyclg2d1BFOUxLcDV1R2VFK1ZaUWMzWnZlemRmdDJ4YzM0d3kzQ2FrN2NYSWs5aUZteGR1TjdSNTdSOE5OSnhMa0wzWUlORW1oam4xa05hdEZaM3dRcGdqb2drVEp0dmJCS1lHZTNPcHFER1pVL0c1QkdFZlBtVy9wbDNHd0xWTWx2RVNTUnVncXhHbVNOYyt6S0M4anRGeWg5alVXNDVUejBXcGlqRXRFRlE0MGNDVGZkUHRQdW5BVDhmVnJmMDVBS3BQOFo4REUxMEkyL0NxNENqbFg2MFVwMm1EMWVkLy9VZXNOS2JPY3dpZUhLSjVTYWYydmdmTXZaak4rSjdQcUIyL0JHNHh4Nkk5RVBRNEhCcklST1FtOStiNHBTd1ZGRDlOKzVYV0lzTmxNVEdCdHo3U1diNmZBMGw2MWtCaVZtT01oMEZ0QzNtN1VGbmxDWFhsaldFVTVvY2RwU3ZVUFVxa095ckc0THhneGtnVU9MUHJnc21uUmJibG5WYVNQUkZzS2Q4Y3dpRWhBdkJ2ZHIxZ3R0b2JIb2pxNjV5eUQ4ZG1GUVJERTJIa1IxR0NTV2dEWnRqdk9uYmZIbFozQ3dQK3lIMm81eUtlN2sycXZWc2ZyL2pFZDRrb0lleFhna1dKWkRBTlF5OHYzTm5iSVd4Q3VxSDQwbng4cFpwYjg3K1dIYkZqclNwS0F0Ymx6bVJxcXlyc3pFTStQWVNqaXNDY0NJbTlhWmc0Z3BrTyt2eTF0c01EQk1wNys0RVU2encrSnBrcjJUcXdqWHRsRTBGNVM4WUFGa2xlYVFtN0xmWjlHN1RyY3NUZlZFUWhlUVo3WWl2WEk0MTFOUWRkZ2dFOWl6Z3FJc0FHY2g2eDJBWEdNWGg1RDhOSGEvYzlrTjRRd1YvSkRRNGVCdklxYjluNmFWcTczSDlDcEVHSUtVZ21XWHZBWXJJclY4c2hzTXFSZW5xMjJYUXVzM0Q0L05HQUxBUnVRNTk4NFdpSkVVNVdUMVBKazV1bE5OaE9DbzNHVkVqSVd1QjNIMi9qQmo4QXFZVTdHVWJ4OFNDaUplazRxa2F6ZVI5dnN4U0cxLy96TDIvK0hmZkZQbTVVR0xETE5HT1A1TTVTVWowUmJON0EzTnJzTXJkTGRLd3hsQ3VWUW1iTXdaUU9XM1NXcW5vK0pDZ05ydzZwMHZtQmVpSmZKektZZzRxc0hWbTJ5MmJMSFZzc0loV0ZOVWdnR3RGTGF4Ym5oc0N0aThGY1VmVEd6b0xSREFmbmREdUtGSFFmMmc1QWtZSFlYSE5IQitRVEQwZGhRTENXc2IyejAxRWN6Q1d4dGd3ZDRLd3h5bXJhdld6cE9zQ2tvOWZ3bHFVaWpManhQMTVIYVVPMFJoYUYwdldPRGdiWVh0U0txUWM3R3dkWWJpUVRyN0RwalNYUm5BTGlEVGNFODBGZjRhRm1PaXZNVTgycXNnWHpTb2hhYVFjSE1HRTAyTVVLeHM3TEtKWU1UbG1DS2RaUkpkOHFHSldBNVNCeXdQTmk0Nlh1RDQ5aFI1SkliNzFwREhBTnVLcmVaN0tXR0V0RHdvdnFQQnNpanJCa3JkalJCbHVvMWs2Q3BYZ2dkMGxKUTlpNVVEc2Y0cjduOWFqTlVvSEIrZEdDNHY2NEE5c2ZPL3NXR0NaRlMxdWVuZ3JTZFRQbHY2dHRoMkErR3pHemZqRmZYek0xNG1LTXVXb3VENjhRUnVEMGNaMzdjQlF1WWNkK0sxcGdHRGxzS1ZNS2NlM1hkajVnSnp4Ynp2dUdITzRMcTJnczJKbFRPVm8rVXhGNC9CTGtJOEZHbmxodzREUDM2ZnVsaGpJaWZBV0VYQkREZTZzbHhBNnByNGlLSThvRW9Va2h0RTRhYXNkNkVMUkFyVWZ0dW5zc1ZRQW8yTGxCUXA1MFNObWdZRUk3QmRpUkRGS01aSGlIK0tCTnZiMU9lTWVyVnFxL0tZMFZ0bWVsZ3k1MzZGakRaVkZaZDlmdTZIc2x0MnRuUm5yRGNpM0xRS2lmWC9yNEozdkJGTE5CTGVWMEo5VkxVOUxtRFRwNW9oOE1YTEdYL3V5MGNzZlRLa0sycEd6K1RpK0NwbUN0Tk9RZ0N2ODhFMjlnV2dDSTFLSEpCeE9ScnVmSHZ6OEc2L2t0eTZ5eEg4ZEI4THZNQ0lnT3cwRUF0d1dWVXFJMFBFVjZ4OElhRUdTa3J5dHI1a0ErRnNXNmtqM0xaSWRaNXF0Z29tenR0alVhL2Y4cGV1T290TTU4MzNzREtoUk5CeVNLd1U0T2JnbmhiTWtKaUxJVkdvOUZ4dmlpVHJYVWtKaVpMZ1NERnBJY3lBN3NBQk5lSk1ad1NIcW51ZDZVWS9PdXJNMEdnVzVOYXNSSUl0VnJxWlBKc25TWlNXd3lKMmw3MnVNMHZLbXJ2SE84WFhPNmVydzM3OVAvK2tmL1lHVzU5MzZlMysvNy9YeEF1VVYxaTNwTU41ZDIxWGhUR2JET2d5b0hxb3JqRzNveTRlRkkwSExZbnc2YnN1ZkthdlBEaERTaGZOalFzZWZVM2ZkcXFKblJJZHlDSHBEdWZ2Vi81ejNuZ2ZYTlBTZEZrVmwvQnNLVUdsRVVVMnVyZ2RkZVZKekhOZEVHSFZXcWpxMmlQbnpqNE9tZ3J0bnpBNjRLOFFvcDcweXRGNC84RWh6UjJYdzcxMHBlSE5mR1gvOUJHcEhwZ0xyeUdGNkp2c0VudjVMN1FGRXFla2tTWDl5YXpRcldmbERRMUFNWmJiVHd1ckJNUE80UExNMUFMQWtnMzc2UmE4T3VTRkJTVXlOMGFGT2Y5N2hiWmtFUW5WWjRKZmNmcDlyc2syVUlCQjQwdi9mSjJQY3JhWXo5d3Bvb0hOQXF5SUN3QUwxQnN3YUVsVy8xWVFZNlBJVExqa3kzRDVyNTJFNXBsdmJVY0xWVEgrL3hVOGN3cHlKVE1OMVlhQi9VMStYSnFlRUtUcnIrUjdyWW5oaU1yZVRTR0VaVXN3TTN3cFZraTVWZjJIenBPSkdzRmp1TTJnYzUyWXJPeVdiMERxbUFGblZVRWpyaUVYMnBDWlp0a1VJQVFGRlVIdk1BZFd0VXcyWGY5S05oZm5oYWlxQ0thU0VMaG9OVFFiUUp2a2Y1UFJla3J0VmsyK2tJKzloNGxtZVNCSVY1U0ZyQ0VGQlVIQWUvVjV1MjEvUk4xNWxBZDhpNExzbU5Scngvd28xeWJtVDg1SE5YYm9vVVA5RzJWUzZpMDFTSG1mN3lSOXV4clBYa09rUDJUaHJ6Q2hXOUhlWmJ2ZWFqb0pNOUU1SVNYY2lZWVdjc3dsS3RVbGNpck1xb2NqNUVkUSszMGhiajJ0ZXoyMkExam5zNVJ1cjh1MGdBbGxTT09BRVBvYWNXQU95bFMzWTRQaTBtQVErT2p3RWJRNnpwbitrOWJVM0w5WHlhMjVHRm5vaitGQnlBdHF3WEhKbWlMQzFWT2J4UFVmNEhlK0JDZmR2RWdjODNPR3NpN1VDeGJ5SGlOcHo1dGZ2TUM3RDRMSW45SzJlempXZ1FRblJtZVZhWDAzNCtBMFQyNFBBU1BZU1g5aU5oOXh5OGU3YnpGMXNBN1VZbDZuVzdzSjJyeE9VTHMwU0psV3FOL2VvdllqcUNhOHVRclhkZnl1c1hPRHIyaUgxb1BaRHJFL291aWVlVGRRdUJlK1JqajFnQVJsWmRLem14ZStkZ2dyc2ZtNjRBQUNBQVNVUkJWRjdVcVhDQUFmZW9tUjlXc3FUcDFnMVNDTVYwdGw3R0djYTJBcmZYNHNNTUw4VllGMytYYTV1d3c3WXlHcU9BUWZ5d2RZQWwvRUkzMW9nM3ZJUTdTdkd2WDhOdnYrVFlNVGcybjhFNXJJaGhWdWpvbEkwK3ZmOWNHZHQ2QytQaDlLNC91SFFjNnFIYlFlb3FybENvRTkrSjA2ZDhuaXdtT2NMaEdacit3ejUxVmdnTVp4TG9VZVRNS3VoN0E5anZKUFlBVE1oWUZnUEdxSmRJekFIbzJDaDRlODBIMGs2QkZyQ0wwNnBXdG5RWDZ0TDJRUnhSV203NHRuSTc2dlNlOU9xTVdzVDY5SkhwSGsyaFN2VnFJaW1GNHBZaW5KS0pvR01jQWYrYUF2MjJCTTBvME1abkNYM2Y4RVZ2SkV5KzAxaVZpODR1SjNmTWlIaUR5ZTNNOCtyTldGY05PSFJtdU9pQ01RVDMrdDJLdnAxRG5tNitaMFFaQndjVDkzZ2RKcndxaWJmTUFTV2RBdXhNZ2dURE1ScmhtWEtpZElDQjl5Yk8rSG5ydGtlTlhOOHp3SGs0Z3BmOTRLclpvU1RpS3NtUm8rVHFCZ1JrellxSmZGVnlVbFdkbmcxcWN5dnJKeDFrcEJjcGNaL2E1OWVmdUgrbjUwaWhmL245RHpoMkpzWjBIRmpHcDR2elJpOUJXeVRpNzU0UGExNTJmdmdqbnRPSmhrN0JvenBLOGhUVGZZRm80Q2krNUJRa1REZEhYK2d1aERrYzlnaldWZWZaRlh0WUhpcDYzUGMxbjhCWjFyb0YzMDIyZDNXZFZud05zNWVXZmVwNUFhU01xVit5YSsyTWNCYy9OUUdLVDNIQ2FOQ1hpWjhoNkdEQzZ4RGl3QS82UFVUb0JSRW5WRUhnc2dPdHdDOU9neC9OdzZYRE9BTTNuS294Y3JsYURoUzlOcnZsb0pBK1g5UGUwNEZWbWNqVjZ2MVJ3SVVUdUxJWmQreWVKc1dWb2gyYWZRcHc3UnBGOGJJWDJkRDBKM2lQbGw5d055RTdROXRSaFRNVGM5S0dCOUE1NEtacStYSWdBSmVTUXA3OWgwWXZXS3ZJbUJyK2M5eStpLzd5Nlc3N0RibEF1dXIyaEJ6RmNuU2lRWExwb1ordHFUbjYxcGsvMm9VR1FJSkdCVUhhVG9qbDFoZUYyRzdLM2RTd3phaTg2VllhMVZrMTdVcGNiZmdPU1k0eUY4WTRyTHBaMFB2UzdCb3Z1d2Nsc3gxUEhXUXF5NXRlTlZ3enBvMFlkMjFFelRVRG9BamxXd0RzTi9YKzNHcVN2T3ZEeXNaMnlGbnR2WDBhVVZxZldlTk9LcTJKQnlrcXlKczlyd2xkNzhvdGZmM0RnTExUdGZWTnkvUTdSNjVoM1BtcDlXTFZTVXp4K3kwc0V3Y3hUYXk1WHdOYjdyNnF2WWVxV1crL3dzQ3RxVUgrdlBFU0FqV2hlUDFLQmw5Z05qM1lTbDkvUGhFZTVtZnRKKzA1VWZPN0dyanJ4ck9EOWxlMkJpT3FKYzFrZjFKYXB3YXY3R1BsTmZhWDFoSjJnL1dSZEo4SlBwL1BvQk1rTzVBVzl2NFN2RHRoeGpwUVVibmZsd0tJZlFydDI1VGVnV2JXa09LR3dCaDdvRXBJZkhHakJEeENtcUhCVnRMU1RiWXJVUHJvbld2aE12MDl5a2lsTStsLzNJcE5LdFZvMk1NTVc1T1gvdlk3cHZiVzlESW0xYWZJQVpKdk9iQzJERTFoSWVwWUQzK0RZNGlacTBSRDF3cW5KMGVoSlZLYWhlalpkekxOSjNDU2dpV0JWdDhYUVJpMXJOTUdENGJaTWFIOXBNWUx4NU5TNlRiMHRNSmRkZDM5MFNycWFnWFh5QUJEdzd3ZFloSE16WkN6UkxQa21TeTRHRjZteko2OXRLb0tCdXBNV0tkWGgzdTdIV3dKdTF0N2N6cTR4eE5QRjhKb0EvWnh2NjQzUkdrWW1MUTlCdkNrQkFkNEhEVmJSaXFLcTVBUFJ3RGZESndJYWx5WmRjZ01OaldPVmhxcTFvOUdoMk1YdkJHUExqN1RvaUdGOHpwTG93R2pUblNrQXNLU1VnQnBqVGZxQjlPT2xoNXJFQkdjSEQ2OVNyMjJFeFJ0TWhqajV3OXdxOW9vc3VHQitHS3JUNVprWEZLa3E3aVdMdk9jRUtNcU5tdkREVDl5b2g0SndHZWYrRytuUmJ2c29oa0ttaXE2eHkxaFQvWW9vb080dWF3aUFsaG91a3FZS1lPRFVpU2pySFhvSTZvY25LQXpyNmxzMHlOanc0eDQ0NG1oWjN3dmhEa1EvdW4vZmQvbWF3cXNVSmJKaGl3M2xuaTJ5MnBMWTQrdmJTVGVES3p3TUlrTnFBMTd4TDVLY0dvQzFuRXVTYkFTdyt0dGdxRXdXZFJwdVpvTmdobTM0bEpjSTMyWSsrcUxTYXhrNFlNdnNIT3pXL1JzcUxUTHZuM0hKY0s3SnAvandFSjRPYmlDemdiUHZ3cHJ6bmtUcjhMSk5HKzgyTEc2UDkwdFphcENBVkFkZUVLVDZpaVlNQXllMjdBQzNibnk3WjFSbkEyMFRoVUNYalJzTEtnaVBnaW5BNkNjTklGdWtCSnFEU0VBYWtwZU1kN29CVHZmeE1UeGZRSUVBQ3ZTc3RHRHB3bjJIWDFCQmtxSkJEdUlPZ0orK2cxMk9HTVV0WlY4bjMzYS91YlFzeHE4OU44KzdjUnluaTBSOWprR3NKeXJyNjdxVG5ZOVp3M053Q2UxUFVzOWs2Wm1Sd0RZU3hXWGNxdU9wSUpwWDRCMTZXZTY1TG1kWDY3ZXNqUWhsYXRjdDJlU0xIbzhJd2lSbi83bEJiZEZDeVI3eS8wUm1iOTE0cEE4UHNQWWZJZ1hvTFJ5b0JFL2ZzN1dNRkpKYVI2Vzc4TXpqL29xMGZFMkYzdXE3MUwybUJaVklTMzE4WlE4U0tTc2dEZXc3NHVJVExyckc2bFlkVTZ0VDN0RlMvT2JtbmdjSzh4Tll0QVh5Mi8xd3YzYk5lRTBScXRFSzh0R0tQTjArMDRHUVQ5cG1kbGh2VEY3QzBTNWYvRUhibmx1MnlBd0h3blBSRWkzS3c2YVZaclZRa01Ib1I0Uk5ELzdBUFBlNTVWbjJhc0F5akkwUE9SaVB5MG5wTmxJUlE4UjAwYWYxZUp5cUJwM0pIMHFqWWhNaklkMjU2dHU0T3RhaCtpTzQ3WHlFQWpnU3RJa1d3c2xYam41L2t1bWMyQ096ODRZWTZYNi9lQXZFTmtVNG0xNTc4WENEQkFzeGhJdU1LM1Z0aEpZSkJZcForTE5NaTh6RE00dXhFTGdSV0NLVFRKbGUrZ0VjNDVDTElOcmUwTVk2MFdpSnpyaHRqYS9pUnNyZUZlSlVjQnAvV0dlb2xXQm0yb0JQejVTaEZScXhHN2xDZkx1cTZzRmF6SW5MUlgvVmpPcWJjY1F3Z1FaYzBObExUTFlPRHFncXhlVy9lU1VBcWxOa2dGMEFOQ1g0Q1NmWFA3TGhVTmpwbFpWT3cyZjREaW83ck5adEJQRHphcVZqYUd6YmE4Z0E2d0RQNzJmZytIdVJkMW9OY213TGcwck1zYjBJbHAwNXpoQmlzNjlOOXBLOTArL1dDYjRLcXdiVi9OZEJBZG8vbERaQmNmSWUwT0RVM2poOWtqZkFRWkdrTmJ0RW9BbnlVTHhFZzVqWFdnU1dTVlViUU5jWEQ4RURpRWlScVVDaURFYjROcFRVVERra1I0c3I0eE1JNEtIMUR3cC9lRm1qTytTOUxMWEEvNHhGeEhpemNjZGFGVkh5WHE3VmNIQTJDcWl1eDltVktheEpjOHFSc0hINmxkay9nT0lVa3Y3OE81bWV3NDNNWVRxamw1dzQyS25KTFl1Z2cwamNsTHM1VnphdWc0K2J2S2ZmMjgrR2k0anJwdXhyNXI0N3lkY21tZ2hpZWhMbWoyclZ1cEpwZlJQWEhLTW8wbmVXR2U4c2lMd2R3bnBLMTYveldDM2NZYlloY1lxb1VrU3VVazBRWk11UkZIKzhTcy9mUC9WNVlOenJTQkNuYmNLOHpzcEt2RFplNkhpYXo3bDBHVk5nS202Nkx5NlhDWUpXYXhnYy9yZDZsU2hmc1M3ZjV1UFViSWg2bG1ONy9rL2Z1d3RYc05QcEFqNnZXRWhZQUNESjJaRStTUWcvZlNWSDhDZDhienoyMUs2TGkwWGRMb0IzV1JORkNSYTVuRDdVSDQ2dXlpaEh0SHcxMzlRNkFvdTM5ZE1ESHdvcVMvdksweHg5ckZCVFdEbDlNZWpDdGFSUTBRSERpWmYwbmJQUHgrWFF2c0VJY2piVHRJT3RPZExJTHdLYWI1cTdoTkFVS2xwVlU4YWdHT1JnWlBYMHlSeEJNZTBBRlhkWnYvVm9GYUhGT3JyOHB3VW96OTlUQVVMeG55WFFYU093NmJTZWZvWXEydnZiVWZDUVZRK1ZUK0pBWXRHZkpndjlQajc3K0lWbTJiUUNMWkdaVm1yR1NRQUhVVis4MkVKVEY1a1c0TTViWHcwS2pQM2NSaU9RQlorMlpORmNVNkpsUjFiSFo4eWVQeDRmQjN1Mm1QNWZrVXJINXFUUUZxcFJJTHJBQ29zMHlpblRUanBkMXl0em5iMGFQR2NoRWVtWWpxUmRjcFluYThLVmMrTWFtOE5ETGFyaElBRVB1YWJGWHZUK1JGVktncjIvaC94WnhnR2pMdndBNWJpY2l5Q2w5Y2RMOXRCcmtYUWRnRFovZjA4dWRzeW0yVjk0b3JQUmF4RVpkUEhQVFJWNUQ3ZjBSVjRUVkYvRDVtdklFa0VlZ3FNM2xhQ3l4bzVzMHBaSngxK3A1NktwWlMwQUVQbWxpVjVsTm5XOVEvWTkrMkxORmRzR1JyTXdSSnNaTEhiSFdZckZBWjMrZExjcXZ4ZzRkbmtnVkNHSmFtV2gxU2hqQVhkWEM0M3ZkREEwcGZLTzZTN1RpM3pNZzhrT3c5K1hYTW9TYkM2K2IrWmZNMVhHSC81K045T0lXRFA0UjdQSkptejdBNWIyUi9QZGo3L1ZqZU1OdVdRNUFVQTltM04zT1o1YW9HTVRYS3psSjdUbkhSMGJVM2hmV1FIMDh1Y29PdkFUQXIybDllQ3R4VS9mNWdJa1V1dWl2Sy85cHU1WDdTei9ybXdBSjY3VW56RUVSaUR5aXJ3WVp6L1JTcmFFN1FDNlBEQURNQUZpSEg2M2pmNG0wVncyMis3Z2U3bHhYSytGbGV5NEh0cW4vY0JMSDZ2dlNxbkN5UkR3OElIajEyVFVtZUZJRzRyZlBjUEtwQXhkVEIzTWpkT0VMdVBSK3RGZ1hPM0xYY093eUZBWVVyUFJPY2VPdmZycEZGNkFyUUdvMVppNEFENGJ5QVcxKzQrWHFOWHlGdVNQY0RxbVZzRjFsdmo2MExTVDhObDE0bVNWUFFOUnJKRDlQb2Z4L24yK05QeTBLcGI0SVhvYnB6dXc3cEtvaTZBclo3ZTBySjFhRThubG1USWZGNEwrWW05SktXczdCS2VlS2xBYzhDcjRVeitSQ1RrbUtyL3dRckJjTkhxWURUREMyRDhuWngybnV2eitlcEIzUXlETkN1cUtmTkM0bDhRY3N5S0tzalFhR3A2R1p3eDJDQUNLQ3dmcVU0NVNVMEVKSStQQnN4a0tGank0ZDR5SVlmMkpoQzJoRWdoWGF5bTArTEg3N0VTaWp5b01Ga0tja2pkd1p2TzFXSmpjbWxiZmJZa0JSaFVGbTlJNi9QNEplbUNrUnNqNzBsYitYWkFsK1RaVDI2RXpJTzFXTkZvVjIzQkswci9WbHNaRTQvclV2RkdycEt4MFBaR1docGFYRkdTSC9jVEFJeFhDY0RhZXV2Qk05cWErdVVycFFxQUtRRHpXSFpyeW4xYWFDVFRTVm9nTlVCR2RqNGNBOE9yeFNPL2ZBUmFlaUdpOGkwNjVmZjk3bTlrUnlnK21EQkplUFJmWFoySDExWVpEb2xURGR4b0VwRVozQ2pQdHZ2S1Y2MEs2UWUvVHp4RGNOUG5VV2pLS25uSDl5eXVqejFkSHUvU0h2UE9SQlJZZkVBOFhyS1FFejFsZmh1SXJ3dDk5YUlPNGhFSEJtTnBzUDY4emxlTnRrNmpZazlNMjZFTDhXVU1nU1FXck5iZTJabmVDZTg1VmVPemp6bjJHUUhza2UrSmxKaUdGZ0x2TUR3UmJkbGtUc1BVWE05Y2Y5NmozUE5LYWdSbnAzejA1RlI2VThyMFpLK3Y2elJSbjZKM3lkVFpxQ2JvMGg4SHMxeENXdWNRUGo5c2UxSWhRNllqdXB1VWZoQjRrWC9vZ2Z4RlNPenB2TWd3TGM0cVNaMFpOUTYzOW13TnRCNTlOQXpBMkxpZUF6M1ZwbjRKc293bGxUdUFtamtlU3VwMmZ4M3JDS0pQSFl0YVNpUkhUWVN4T2xNKzlLQ1RmRmllcXowRHpxc00yYjdVYllRV2NaQmE2b2htZ0hxNGs0QmZUeVRMbzNPSXBVVEJVa1JtbkpPRndSSWVKRWdvRk5NdGpvQ3RTelRhRFh4OVpnNG94a2xJMXRiMVhGUVd5bkFDdWtxNXBJSlR2VERhYWRmSmRNYlZON055SU4rKy9rQTBDbmVienRHQkZGQVRHbXVBUVpwT2xsenFBVitsalJLOG9TM0p0dEVtRHBTWWZRS0E1V2Fla3ZBM3JMSGl6TFBKcTkyT25NOHJsWmdMN2xPZEMxbk54NmR6TlNxemZSL2E5YzRSejhGODd1VHhFSVJ2T3hXRENKblVqTGpmRnpycEt6alpuVnJZZFlVUEFoZUJ5ZThTR0RucFpWUmxYbDhlRkVVdTNhMDZNcEhmait6d3lhYXEyazRsM3QzWC8rS1A3OTB6clB2eWdCZ09XenNYN3JFWWo2RmlYMzlvaHVTWGZOY2NNMExJWEFkMVBjVk9LeDJCcjhMMEdtQU5USis5NDRXNmxvRWJoS1pHcnkzaWUwN0RFcDVBS3RabUJqS1ptWnh2d1Fiejg2OGRGckV2ZHRWNjJjVjVKNXZLaWVDaHBuTVRGQWh0VHBXdjZIMVBMQlEzMlc0cFNmTFBDUFVNdXQ3dm5uQU8zcnUxL3ovZXI4bDN2VFEzTFE1NVJGMWlWVHo5aTg3ZHAxWXhMb3FWYml6WGQwL0tuR3QzWlpLU0UzazkrRlRKY1p3ZUVSenpRZEdNblk4TFNvdWlHRFdRaVhnUWp2azVwNlVCa3lid2o1Ymp2Sm1wbnlmam9wb3JQQlpoVFhGeFplSXFTS0Q0WjFlVG9CekQ2WWdmKzJpcGtvY25TN1M2VWxuTmMyODFhcGZFMWtaTURHb2VGd3pSNlorcVNtV2xrZjd1U2dnMDN5VThrNUNoTjZhc3hXb3dGQjBwKy9IMkNscGZtL2xvRHpVLzFRVzAwRGNEM2RYL1Z1ZUlORFlXbVVkNnlMdXVlUzNjWGYrSkhtUGptaVZNb1pTTzNFYmprRTZuZHVkN3BhYi9ySWZHY0VXVFA1MDNWRjJvdnltdDVUYmRzOTF2b1RBYlcvclA4dkZrVGtldGIvTkpNSzB4N3YvMCt6WTE2eHk3U05RNDltOU1wNkNsdjZhUzNRME1ZZ2VzRVpZa3BtT2VPVGIxL1pMcGc3SXpmeXZrYjJlalRVSjQ2a0duSFY3SVhtL3pSSVgvTG94MTdQN294N2RBTktMNDNld1JEL1BBT25ObjEzSU1qaXJPd3ZFaUhUNVN0bXJBbTdKbThqcDczNy8vMFVFQkJRWmZCV0Jwd3RuVUZ2ajdaY3pqdkxtS294MG9IcTYwSk5zMmcvTkExaUJsNHJJT2RGYk1QdWdOcGpnMEh0M1dTckkvYmpDRE4zZTYzTTkzNEpvNDVCR0NzeHhoUVF1TkFrT1ZxQjNNdC9lWitQaFJ5eWJRSW51eGtLOWZjeGQzUkFTdGNoTEo0RmJtYmZiazJkWE5RUFlKNHluK1c1MkFXRVNNbFF5VFFqTVZ0Ny9UZC95Z1hTeDNIejVmM25rb1B5SkR2cjF6R1ZrVWVkTlZGTVVPQmxyc1NGQWpUS2JvUWhzMGRlSitDY2FZcXhrZnhkRndpWmNGK3IvWDIrWkNBd2ExYmQxOHRvUEx3QzBGbFNKQ3gzTklmUGRIeHdpVGhIbVpYZXhWUU96czFSRktCb1lsdGt5YkhlVU93K255Yk5SaEJwK1plVzBFR3dBYXlrb05qRmJ0T1hRUHJXSXNwcURxQldnSW05cUVZNnVLcC9yTWdPQWRielYrV3p3c1I5YkZ6MFpUN0lleTgvVkQ5UmNPTDljdkNaNGFaL2RlcTE1Z25KMTBDWThtd2JmOWl0UmYxRTdoZ3BFQ2xOR1N6SEUvdWRYUzVCQWVyY0VvTmh6UUpONDBHekJOOFlMZlp4OTY5d1BmWnNwSnhHYlcvaFBLRDFJZGtwSWEzTXExbGZSVnZWaHNCYXdMWEVKcTcrR0xRMWRqdGRjZXVKL1RiU2JSMU93OWRRalZxVVFjS1orTUN1NzF5UTF2dGs3K0Q2RzZ5T3g3bzI1enRYSlVFNzBpYXNua2ZTWllwTDg0MTc3UTBSRzlIVEovV0NONFozTnIvOHRnWjd6L3YvQU42b2hWZXF5dVlPeng2M0Q2SFZXY2NuTGV5a00waDdEeGNwMUo3TU5rMGxWUUZJeGJ1SXBHUEV3VGhKYnlaWC9EQnNBV2ZDTTJrR2dJWnZuV1c3aU1QRjhGbjNRcEJsdHhVMjdsbURNbU5QVHZXNGRQS3B1dnlkbExneFllaW1teXVwOVhyc1VQdGtQa0tsR2owaEdzb2ZBSkdzUXdYQWxCNWxjLzdhbGJTS1YzSmhHZnQzU1Ewa3FyUmV2WjJPZXdHeU93Q3VXNWV2bTJobURCUHUzUUFrR1d0UDNqVnEzZExJQkRZek8rY2lUa2pXYmNFTGVYb0lXWjA0azhFRXJEeVpIeVZqWEVmemJVUzVRTVpHNlYzZldDZisrNE9rYWRPNDR3S20vcERld0hiVVpCZXdic0RHWmlGdWxMRTJjSFNxK1VHcE12TDZBNGZYSEpGVmZnUFRydFBFRmg4ZXJqVzZVVWo4VjhQMkxWN0haZHhBV0ppWjRwYTRvMWRqTTl5K1BSZFE5OWwrdU8rMGVzQWxFdzN2QXJkbk00Tlo1V21xc2dKTFhPaVRzN01WSnlBa3E5c3ZMSjc5SUVoMzEvUUMyTFFCdmFiaDhrbDlEYmNlY2FZTm1HTWxXaTNXK0kyTks2NzlvbGxiY3lKb2tRdXg4Y0RMMFF6dzhpK3c5dWdnbmFkVTBTbU9oZkI3NGFLdkFPYnJxZ0xqaVRibWRsNVVQU1F1VytDb2Q1QlJkckNyM0N3R2JldGdmMnpSZUhVeFBPUGpLQ3M1aDVZd1ludjFyRUVpNyt0UytRYVdTcHNEbSs5dzNkbmtJVnhmYjl5N0w4bktjRlgwU2VqWkIxQmJicmJYdDd1VVMzcExnY3d1LytKaTErUHZ5c0xvbTNXUEhmMy9WQlRTL0dlb0ZaRENqRGhHK01qQzVkTHBHTnRqWkpXZmNzUmpJZVBON0cvYzNIYTh0SE16cHAyNXNIeWRzWFhWdDBFWHR0ckU0R0Jrb1Zqamo4OUhOVHgzV0p0eVBPMlYrTEdkMjlTeklsUkwzNzZRUm9yMGcvbzNPSUk5ZXVmU3N5MkJGMy9Xczkyc2JxQmFJNTcxMmtCNlZabjg4T3RBcXplOGN0QzlJUW1jRG1nL3kzWE5tdzRjTWZBR0F6emZHU2trckFBQmhWd0JvYzhja2dmcm5mTnczRmJEeklPQnJIYzlkNVJuS3N0UjRSbGVLVmVvVmlUdnN6bnhlMHl5L1Y5djUrVC9JK3V0NEt0WHVLcFJiYitJL0FlQ291UWxqVnllRElsV0F1WkZhdlQ4RXpZNHJnMnEvQmVqN0l2T21WcnBTdlp0Qit5dnFRSHJJWTFCbkYwdzJyOEtpUnB1eDJndTRKejdmNVZCR1QzbVAwbWRJR2pIV3VCMjFBeU5YRzZtZVM3cndlNUt6S2YrQ3c0ZEtCZmhHeThDV3VNSVZnbUVITHlPRmQ5dVVySk8rMkRZSWVoazFETVhyMCt0eklJNUE5VDFZazBYeTQ0YXZ0TjVhaFhSK3Vqa3BjMjBQVnowNnVDZDhDYnhPaFFhYWdRSVhoYmNCUVlmN2x4OGpsTEZ5ajl5MFZURER6KzF5QTZkWEEyeng1ejFwZFFBdi9pYjY3c0xFZzNnQSttbWpoZENjMCtIYnZnRS9PcklkRmQvSm9ub3doV1JVY2RkY0RlUnZPMnRXdzF3UCt6MVg3alhDakFPOTg3cEMyQXFnK1cvdlVYQUJZSk5OS0g5MU1YZ2lmcy9OOXB5NEdnYkpXVjNMN0lGME5wOWxsNXpFbXBpR00vcXFoR2Q0Z2tMZ0ZRbHFEYkduK2RwVE5Pamt2STlDckVieGt1UFJvcyt6bWRJMUhUQ2tlK0RPTklMa0lHTVRxcUljUE5MTkpaaGpnd2VSbGljdFJYK0hydUpyY2w2bzZXWEJrWHZNK21jSzlsRkdEREM5dGhFcmd4YVFrNkk5T09GZ2FtUHdycGdHMUZtdm9mdGZlL09PTnZIOEdMT1dxY3UyeUxUYVZDSlBvWVVtMFN0djE2dzN1OUs0Tkc5Z2ZqNE9keTJBZFBhTzFCUUozTGllY3BQQXBvUnpBTGpUb1NsS1g3dTZjdkdKVEU5YVM2YjFZMVlYd1lpdGVPdmYwdVpOanNVcXFGVVhtd2F3eE1uRGt0RTZvcURhb3Bpd0RxTE5DOFMzN0NGYkVQMVNpc00yYlhVajh1U3g5YTBQZjNtZnRERmNoZzkyVi90UzhlRkNiVU1VUVN4U2pxUi9BeWY5NFkyVUlrSjdIckpjdTVGVlQ4aUtkQnJnanJEb3VHRGdVRzJKOW5NQ3lJS1JwdTZuc212UytYRjRIZmNNbU9KcXVNZUM1MHRRVm1zRE43V0FoM0ZpMW95TVp1RWlILzNCYVZER05kdFpuY3pWOXN4ODRkT3RvZEphQmdwTHZWK1dkeitlTTFBdUo2RFUzWmsxTUNEWmcwUkpRRng0QzJ4czFoMUdPRkZGd1ozNXdTTDh4cFZ6WjVNWEUrcEhMWUduLzlPdVBBUW5aL3VUQytBNEdQZHFmeFlkaC9HTFppZHByMDRHcGp2N0V4UC96djRPQ2thcmFONFR2M1RzWC9rS01KVVhsTlNSeUloVUxSVGdsRXB1TkhJVW1GTDNzZG8rb1hWRzJ1c0RJY3l0RGQ3empZb2VXamlnbDhQd2Z3OE5DQWZRbmppaWk2SVVUbkJtNCthYTZVVzRNTnQzb0R6WDNDL0hqVzdFNGg5TGhtS0NFWlFOVExCYXNpMzRUSS9qN1A4YnBtVVQ0eVU2SnZsaTI4bWQrdVhBUWFYaUJhSE9jdTNuYTVWQVU4MWxUY3AwcTRVMWVWMmo4V0EwT2UzS1piQkVnTk5ENlJkcklIRklscm95RmpnQ0REYjB1d3lsbE0zYW1zcnNhUnYzSkpBUnNLZEIxeFNMUko5T1pvZ29PaEdCOXFoQTNLWkNvL1VWNHU3c242c3BGVmJwbUI2YUo2N0RBRWQ1UkRxMHlicDhFVUJLN3BOR0ZtRUtDM0VXbm9sZGMzekxYcG9JcFcwZ3hHUEZxaGdCLzArMFZxV0F6V2g4U01BSWlEU2hIaWI2OFJKekRTcFFhNGRuMGdJT0wxTzhGckFFVk1vQkpuaUJIOXl0K0tnY0hrWWdNWHUyYnB5eXBnR1lFbDhlQWF1R3B0eldpTjdVa0k3SXNRMEJDSzc1dkd1azFlQWp6elNGcVRXQUtXZGdWYUVKb0ErU090QXQwbHZYTm5yVzlwMXZST2Jjc0NDakxoc25UOEI3N0RobVZGT0s5cEtTbGQzalZBWnQzTkYveGY4UWNKNkM2RGJ6OGdqZnRhWDcrbmlGK0RkZ2FoODArVXpHZ2V5VEI3VlFOcGI5OVpGZ0Fzd2lSSmxyeDdMNy9IMzk2V2hWVjFkbmxBUkF0dm0rTXo0RHBKK3luQ3lld0U2Z3JwOWJxb3RnYVVsR0UwZCsrQ29PY1RTVGJySnFHYUszT0lzN2FsbzZkVnVDL1ZZYTZ2UkUzWFFoMEtGWFVpQklpYjN6cnIweDVLYTFWT3pDa1NyOExtQldES1Rnb0FvY3hqbTJoMjNvbnJGWWtRNkd6TjhMVVlCQStyK3FzWDNLODdIcm9nblF5Tm56Q2VCTWNabFYrYkVqcGpTNTRPd2FDTXhXS3pMeXF4b250MzR0MU44cW9FcjhqU1FpZXRCNkZZaUpRbnRKRTFCYnBuak4rWSt4K3gvN0p5djB2dHB2cE13bHZxaThJQWxzVlhuVjI5MndaQkYxUFRUUEtWdTVmWk9QTmRwelNxU09BRGwzR2FQNDdoREVuNGxiUEIwTm9neC84UkhocXZ1QzVad0U5VmcwaThkUGZrdTBnVjU3UWV1TXo5eFlpbmd0WUlCU1Rmb0FwMTR1ZDFVOVNQSm5XRDVFaFNSN1UrWTBWcC85NFpiSEZ4YlVBQWo1Q3hJQWZzTm0rZGw0WmRmUkdGSkdOUzBPSDI4d0ZmUmNjZ21PdHdZWElwWkc1WUh2c29RWnVIUG5GaSsyTDZya1BxaFNvdE5IM1VScytBL3RqR21nRjYxdy9sNSt3SjZheHZTNThPSVRJQm1qdUQ0ZmNILzYxWlJacGFWcXBrblRBb1FBeURKTnQrV3JTQUlNcHRJVjEwSVBTS2pXQUxBUzhVN1ZubXRtbDlLNVZXK1d1OE9XREt0NHZkZU1qdnU4bGpWWkNpZ2VFbWFId2gzKzRzdUllRC9CbGZRSk5Gcml1KzA4ZS94RWF1ZGJ3OHpVZ0E2TXlQbDdBcEFpVmszNUFhc1NoMzJZRGlkUE44aU9tUFpzNXVmU3hwbmlOOXljTjY2RHFTeU80WVZ3WFFxdVloQVplOCtQUzdZcUZxQ0xGeWlWK01kYnN5ZEdtcDFDY1cxMEVmaXp5bXkyd1Z0S0FWQ0pHcTFvdEIvVlQrcDd3REZUQzBOTmYxQnp0clExWDBlZzV0bEJiN0RRNmJzeU5xQ25iWUhTRFNJSVpTdUY0NHBvdm56eW03OHY0cGwreSs1WEFoNXJsWTlYSlJ5MUFqM0pmT3NKKzdPdzZWODUwREFIUkxCeTZBN3dkdEhjdjRNM3ZaYUpZek9ucnFtM3dDMEtsREZ6QTFqTFc2eHdoZENjQy9Va2c0VGRjY0Z5Uml1SXFwc3lpQ0Z4NGRSVWR6ejA5UVhENDVYY0g0OUIxWGYzV280T0ZKempPeGlwSmNROEJxRHF2K2VpOFJnTk96KzBaeDJtb2dGWjB6ekdxK1RSYzZSMzZIckdSRmt2SUc0K3hkYnpGOVdPR2duY3FqOXU3QVZjUElNTWFDKy92d3cwTk9sU1BLcXlhSEFKSDFWMWlVMDFUaldWd1JRY2V4Mmg0UUw1YjBiZkFqbTdjOXg0YnJKdkxGc0hOY2FlSkhheVkvUWZYaWNhNUFIUkxRNlJCV1E4N2VIajlOWU1NYnFrcWRrcXUzUlpmVTRHSHF1dS96cHk3Y3NJS3dtcTE5b2NIUHZkR1p4Rk9oVGR4YXVXK0RZU3JIR3hOV2lqTHlHTkhXQXpGWlZISEQ3NEoxNEE2cUpOZ0wxWEprSlJBdXlhdGV5RDA5YlRuSnk3OThaODZIUlIrck1ybmVJbzN6bWxmZWlOME1EL2RFY2dPcjZSZ0JrbUh0L3ZycUtydWZMSFhTdndTM3FHaEFTQ3NySVBJRk9VMGNBV2JMZFZFKy9wL1RXN0NrUUMwTkhDVUhUdVlWNGxKMmJKcFM2WFRHWHg0QVR4di9aMm5jK2FXL3BXRm9aMEh2d1cxbW5RbEZmdjBGNTk2TGp4QXpGcUZ6ZUJicEE2OFZ2VHBxU1g4N0gzVzJ5cTBYamhiWnoyNlRna0IyYlRsOW95V0NFeDFsY0RKWEZ0djlmR2ErZEo1SUxTT2FUWG4zczFGT1pEV3pMRm4wenJQMk5iWlRzNTFNdXZRM3NOc3VPcXhRT3ZYNG9lVEsydzBNUFhvS20xMFNkOGxkdGs0VEM4bGlQejMvNlJ2WnNjcW9ZUkNsa051NFo2UGh5Mmg1RThiMHlJZThKeER2UmZPTXM0QTd0dURYRHZBK1RibnE0UjRza01MQXZKbm8xMGhYaHhMNGJ4TWNPZHJzZHI2b2ZBQkRXV09NVlRpNzM2Q3VXUnJhcEFYYWxIZUg1UWdGUmE4Z1NZVjhZRlVWazR1S2V5TUxGMVNiSDh4cVI0bU9xS1hjMDhqN3cvbHZFOEJyZk9ueXpvZHVrRGpGTk03YUpWNFBmc24xVHg4WFhjVEhmektRekNmQVRXaWduZFlmUHFUQlN3cHJJWTZ3VHlldVVtNTlvNnZOTzFTWkRWY3F3QUFJQUJKUkVGVVBEK3NFVFltWTQvdHRRWDJjT2U4SlNCaTl0UEtEaGE4Rllla25iWnYwYU9WSUVQY1A3UnBqdEhjY3gzd1UxcWwvekp5SHh4TmtvRE1xUXVFb0xFcjFQdzJ3OXZkSkdwekxUMFA2Nm11RHpiOTFmVGNrUC9OWGNobHYyRXhoN2E4Y2dJYzZOaHhydXhPVURIY2ZJaENBSFVRVExBN2d0U2VjTmd2b0dvYU5NS3F3S3JDRy8yN2x6QnJzRWdrYWZHVVJBNmsrQjdDRC9VR284b3hUemJVbm9FcFdzWHp3OG5QVXFCYmdmZTVQV3UveHRaRnhEeFF1MmlYeHFsYzdTRW9GZ0VOODJOR0ZLUmJzK1pycjN6bWltTVdEVnRpQWJQbnh6MmpiYk9NdUh1L21RMk0zVGFsUlp1aTc5NWdKNk9IbHdzTElpUE02NERReUx2bXRldUVUNjFCR1pqK2RyemRzM0xNN2FWU0FCdWNQSWJyTXdRd09BOVU1aWF4RGhDNW40Y01EYzJBK1FpMGF6TWlIWGhraTNRbG5DZ1doM3FIMjd4V3VoRDZzclFvRzU5cUpJbTRXanU4ejMyVklRRHpsdnJWeHArWERMR0hqbVR1NE5YcFhCU3U3RXBYUGVUWTZOa25jVTRibGhvbnVqcWtPbW50Y1Bxd2FMVytSZGU0SDhpQWdRNUdPZHJ0eW8wNDJVSCsrQ2dxWjZkNDZtUkVuU051QXVFRzJQVmtocng2RnNHd0l3d1Ewa2t2ME13bVJzT052RzJqS29mODhoNHZiTHFIWmpLRTcreVFpNm5IZXloakVhVnJ4Z1FkdXVIMmZCVWszcFIwYjhDN3NFV3VUTnBwcFRTZHpxUEk2WU1UNzJzUS92QlkwNHA3WjlheXY3YklTcHUzK0tiaFhROHFaRFlWTFAwaFRaL2VPdUl3RjhaSFlXci9QUmlPVk1hbzdJazhyTkdkdDBzMjNxN2ZjZWxYejFaeWJveHJ1T1ppTThQcHZQN0VpZmtYZjJzQ291cVVHVjkvUXNsMVdsemgweGh0NW8yU3RIZGE4dnYvczhtc2I0UWwrQjZQb1FIQjZ4eWo1Z0tGbTVabWVKaC9obUsvdks0WURNYnBRNjlDLytXTk55NzQwVWE3TkhIMkRxNGEwcU51eDJ0dTNwazJUWFNCZUtxeGhLVGNuUFkrMVZ4a0JkU2RoRk0rb1A2aUR0dWhNSGpPK2M2R2RxVHJSVVJNTkFESUJDcGU3RXZnUUJRU3FHRlR3ck0rNGw2VzVIQVdMWUtCWGd4TXRmZXhic3pDK3pCYkw3dVBJaFRUcTJPSFY2aVFXK3N3czg3MWp6eUxJL1dmL3JuR3hLOGsvVllHTmpyVXZ5cUxkZFdTK2tqbHplWUdzVHhKdnpHOTJUbGMrejlyL1ZDZEFnQ2hXb0cvT3lmRzNST2U0aXZ2M0RxME54eFN0VXdqa0NMelFBdSsrTmU3b3BaR2J2MG40Ym1vd2pwVzJZVlVZQTh0c24rOUtpTGZPZmkxRnZycWlVSkJGQlpzKzBEN1FoQWs2eWF3NlNsZzJzQzU1TUl5Ry9FMlVnSTR0c0lMREUwRFh3cmNDM0Yzd0crWnNwUHZhYVZpOTAxc1B0RFpsSlhUZ2plaHJyaVY1dEQ0VFRmc29LWXQwczVMYTYyeUVRckh5OGFNeVdBME9mZUo1KzVIcTNXUVFzL0tTWkNXaWF0Sm1PbnNVOEhZU2tEQzlDYmpQbERhYjNIcEVNeUM0Tk1NTTczNTN6OCtPaG9CbU9XU21iVXR3Y3Y3dGYvWG1TMUI1Y1hOZ09EbGhSTDMwWTBRK2JmVEp6ZmZQczVhU1Q5MmFTUkRNa1BCSk4xYmo3UjRXd0dJbERVbUFrbU1Wa1BPU2xFMk1xMWNhODR2YWk2RXd3TUNaS1lqMTlZRWQ2dTFpa3dJb0cyUmxwa2xGNlVWNGFEK3B5ZlBBVEFEcUpBakpwcFVxTTZDK3gvRVoveXVqcWRpZmh2bnVYN1ZhMFRNY2pwc3BDaE1SRkZkRW9wK2JoVEh0N0VBb2lJaW5uM1dSSTlDTU1SNVhQOENHWmlYUldmdTh4YzRWUER4Z1hreFJodzZSejRxbGhIMzRkWkdlUWc0eU9kVEFMVURWTVZ3dDVFOTBuZS9MSEdkazZwV05YZklSeFZqVmpkRzBuYS9vYTRSeEcraUEva253TW0rQXUyQWpDVzhubmllNXNOUzVWUzNRajcwdlJudjVaMTZJU1IyUDBGL2t5aGRCRkRWcGhXSTBYbnFBdW9SOXdPdzgxQlBpTlhNVWNIMzRVNEhUS2pweUtYYzI1V0ZBbXlmV3ZHMFVzWlJCRERsS0JSc3BzaVJReWh3Z2l5OFBLeUNrYWNOVTR6ZnR2WXlyYzlxRDRXR0k0L0RzcXBzVUpjY0VCQit2S29VcGdMc0dvT0ZudEJRdm93TFRTb29aMVRwZG5BdjFWVGhCSmtselA3OEU4Wk9mMGdGbm5XdUFycWVtVHBSeWxDTnBmT0JGby9ZSFphWGI0SHlOWFdycVJ2OTZQejQyejFzcUVqWUlBUmdrNlJXSS9iWmE5NW5WZ0xDdXVZcnNyMDVMNHNGNEpNVG0wc0Z6MGxxTTVBUjBwRzVHMlUvcVpDcnpBbmNtWHpDcHdjNmk5akJFQVYrMTJKNnZJU0dkYlFvZVFXREkzNVZ4UHg2TlJCZllLU3Y0c0xMd2RaR0hOc1p6NG1XTkJVcWJjUm9hKzduemFlN0FKY2lrNVJLQWx2MjBKZ0Q1VFRjS0h2TmNCdDVBTy9idnpJNVRseHpTdmt1cE9Ca0YwLzA2NllSVGVMQms3VVA4a2RrVjZHeU9zK2tIU0hoWUt5OW5tbTRVcVE1V0M5V3BHaUdtYmdjcEtkeXpZcjVndWx0NkZuRUduV3l5SmZXUkVtcUNBR24yVkNuTTltUVJRWVJzM2VBNmtIY2lnLy8yaHN4eW9lOE5QUUx5bzl1U3FnU2V0VEltMTQrekVCOHZmaWZnV3Q2S3V0V0FjYzlEM0R3UzZ5Nm5ZK0FIeFZSMjZ6SnRQR3RUZmorVUovMzBjOHpQa0ZyaGhnOEJwSThTRkhqanE2Vm4vTTd4NW1lRzNOQyttNjNIWXBCN0NIUGxDa0xRaWRhM1lkN0p2cW00YnJ5RWYxTkJsanNud05lNXYwQW9HalRMbkdmTVdjdjRvTWRER2xNVWpvc0tsWmxTeTBLd3A1YlZaYmV5cWU0L2RsR3llOVhoOFZTaU1zUm90TWR3a2FIQlBJTDRDZVQwMzVCc3dXRDhGYVFBQmJsYUZ6c3RSM1JkK0dPNGxrejBQZzZGSzJ1SVlkb2lIVmlIWmJ3bmVyVVRPREdndkZZUVdlYXpKUE45SlcrUU5ZUDhTQ01aQmgzdXhpT1ZDTjlId0h0eGhZQzI3SG85RFlNZWxRZ1R3QlNGbERTOW9RdWNmemgzY0MrbTdoR0lvcmpqNzRCQ21KZGtJaGxucENQTHpOaXJBK3dyeS9NY0FLckJTOG8wRFI2TmFFYzB3VXNtMElWNzl4M2lGVml0Z0l0ajN6dHkwUmVvVWMzQ1BaWklDNlJqRjdhNWw4SlpJVk5zR1JYdnhNQTRtTjN5Q2NNZWF3OWNHbWxaM3RYL2NmWDhvT0o0elVxSjZCajQrWE1zd2hGVDJERzlGa1N2cFE5NGkza3JRTGc0b1o2YldleXVUcVd3bWJSb1dXbHg1ZGxvQjBkVllGa2JkZG9FQWEzd0k0NExlOGlsK1cydWZOcXVYWHhWMjgrQmhZYSsxZE5wam81T0NuRWgvMjBvc0FLT3hmMVdyc1g0Z1FkVGMxSzZwck1mclZhd0R6RXZ2N2NiR2ZNby9YNzVBYlF6b1E3ZlR0Ykxlb1lZLzNnVmR0Tm52ZlNaSURoakVWVmlrNDZEN2pzNXdNdGViVmlTbWxUOEtFOFBXSytIVS91ZGdCbzJQMEt1WXFnZ0pNSm1QUFNrS3BWQnJCWWd3WnZYd2k5TFVraThpVE5rbjZsbEhZMEYydG5KNE9qclkyY2RJTjBsU1ArOTc5WEd3NHA2NXBPK0EyRnMybndZaWlCckxFc01CcVU1WDVVNVppZTRPU3pGRFVOVm9DU1pSVWxRZFhlU1NBdnVkVitXa2k3SlJ2ek1IdUE5NjQwdytZcXZEVktiY0kxNWdCUmt6WXlFWTYxcVJwUDJxR09VdlRaR2dQMUtGYmx1cTl2WUM0aWx2Q1Vza3ZWRFBtTFJZcnZaYTM5S0dnRStWb3RLUGdsdmpVK3VtblZvbXhRUnJvd1orWkFjZm4rM0lYVDdOcUNnOFk5QVBJWnEzUmtlQ3I3NnFjc3Zrc08yTk5neUVBTWdMaWd4R2F5d1B1M0kzUlJ0QnpXV1NoVVZTTDh1MCt3RGtKREJPREUzTktNTnRxdmJWMUE4QWU3TGdlaTQwSlNBNjhjdVR5Ni9vZFhRVFNXb1F3TW5YNnBmTS9FSVUwOFpDaThzdFdZdk1tbWFwVDBIMlU2V1hGNE1GR1V1V1ZSNVhpbUxQSmtyVGJxV250eFl3Wnc0UFpEZEtSbEkzb1d0czAzT3hoV25xQTA4SnJCSVlHNUgvd3VrTnZWcEFteDIrZFcvdWtQYXN0d1Y3YVVldldUSXNYcndzNEZIRUFKZTgwa2VROGY3Wkp1Y1pPMDhweFl1ZU81NTNHdkRmMTZ6eUFJQXdvWEh4ZkE3VEdsMUVTSEMyVXZYNG1sTDlVZWRXV2xZUC9XOEpvS21NMVJsNVFYYkxIRGo3VkdpL1N4eXloUFVjOGRQTFJIMzNaRmdhclZySFp0NWkwVkc0NVFWT3JpcTh1YzRnKzNZbzlpSVg0L05GMGpxK0M5dXNYY1FEZU9rWUM4QUQvMHlnT0lJVlVPNTE2YVJnS0JWU3Z5MGQrN3hvYTF5dzNtdi9zL005Zm1DQ0tKQmdQN3NPWUdxWkFyMEpFNWZnK1Z6RTdOb0lxZkRXZTQvY0xnWTZkVHZNakVHeGpLZUI4MTVEcW1NbU9qdGx5aytwQTJzRm8xNVAxU29SN3lMbjJkNjRzZHV5SVY1Z2dGbFc2NjZLa1pOZU1LdkltUFlnT0tqSnhZRnpvekFoMExpYytjYU1jMW5HSVhjVnc4REdMNEVPei90Ny8vN2V1ZkVwaDYwU0l0YnE0L2QyMVcvSjNrblRtUkJES1FpZG5ZRmxjZ2ZLc2NmaWhmMUJ5aDM4aG4zTDNEeU0xQWF3ellBOFNPM05lMVNWVW4zcEdjVW1vTm8yQklKWXRYVzZhekFUTmNtalNPR2tqUlF4NkczeXZJUUFWOXJGNDArZ2g4WGtwOUdRVlVnY2ZmWHpueS9qNXc2Z2lDRnNQUlA4UDcvenI5NHNZQ28zd0ZoTVNVazFmT25lN2NXTmRORFNNbnRLTDFHOGRydjhFSG1sWWQva2NDS0tPVTdob2tSYU9UMXhZaUFVVmlnNGZhNzNyRzlCcFJkaUNtL2VkVHR3TCs2blEvVHhreC9MYnp1Y0dyYmNNTS9hOGxyZDNHYzVpK3pWNDYrTE02M1RyV0IyS1lJNXdrYnlGUkRtQW53WGNzckJCWFMxVFQ2MVExS2hSZThoRDNxZWcza29iLzViR2U4OHJOSnNHS3U0cmFvZVVaOG5pNWp0bjA0bE1IUEZBNW1CTnloMDZKeUtrbmgwREc3RGlqeEZodFZuRWorQ0RGSUNzZnNkdHdCZVBvSXcvMDdVWUlGVERwYktHKzZqWGxqTi90U2w4SmNxdXZ3RW5kTWZyTXgrWEhLc25vY3hQekc4TEhiZ0VFRzgzSFBiYWVZeHBaZDJORlB6aG41N1A3VjNVbHllUU5zbzhicUJDNG05cG1hNXhGenQwemZYUUdPeXFnaHNvbFJZeXFUbzdJd28xdTBJQmlldUVDWUNMcDVyYVBXV200TkhIbFM4eHEzbVZmK3hTclBISTZSWkVsVDh0aHNNdkQ1T3VoWkNaa1ZxQk9mWEVZZ3hpVUhRR05xM0d4cHpRRDNVNEpHT00zWnZXd2hOV05CMDFNWmZONElJRjVLY2pHdDJPNS9kbkVHL3UrWmVzcUlXL3R0VXVERWh6OExReWdHb0ZvYUNPbVU3ejEvZGJyUDZUbUIzN3hrNVo5c3F3TmpOOUlNSFVUK3lhVWJvL3dXYTJzeHZPT0JoazRvUEdEbDkvazVUVGphOGJnZVdBbCsycFdJaGtwZ0kxY0V4eTRtSitjeU9zVnVLMExCYlprV0NKdHh3QmpXNktrV1pQeFcyR2ZMSDA2WFhWUzBDdUMxOXRrN2NlbjZpQmVTWDRRTnhLOTBwR0ZjM1B6bzZuOWUwOGp5bHZ6ZEgrb1FsYjE4Uy91MWM3eUZSd3F1WGF5VVdEdUNXRjFINDIxOGlSVmF6OHA0K3pFV1MzMWVvM2hETUlDaFFESEM1MVcvdGRUa2x3bmZVeU9VcjlmamwyM1draStGTFFpbndJZHBJVC9qRllFU2l6TENxQm4wd1JMeWIzUDVCZStWZ3JWU2kwRkRlRjRwaWdUd2VuUmN1TTdDelFaWDFhcEVVbjN5Q3VoUU9MTTB4RU1jSkhOQzVNTHFHdy9BaDBUZ2Zta1NheTNvcXJJZEY2OElMMXJXaTN2ekJ4Z1NHWmlhNS84a3lSRThpNnFqTnExdmQ5QzZYRXFjUEgxYzFZcXBDYTN2NXpxYlFlcTdWYUs3d3JFNlh5MC8wVk1tMEY2aDNPL1BrM3NhSVIvLzFwdVZLSU9WR2lyNXlYcGhodzg1dmJRanY4dnZaV01IaDJ5YXpSTDliV3pKV00zdzN2SFFUMVIwNFpqbHBRWEVOalMvVGRGODQwcXByNW5MVXYvKzhOd0x0ZnBzdFp1Qk5KTkxkOHFZZ1hMR2dJWkpTeFlsQlFaY0xjcVNNTVpkTjY2TGh1NFdQRGxyMzhOdjVBS1FTeE1XbHQvUGRraDNGaWlYSzB2dnNnV2Z5K0o0MkY2VElldlQybWYzWGk5YmFJODFxNFBRYU82UjIrZC9WYzdkZEk1UGdWaUh2aWxuR1RvOUVvNlR3cC9DNzdGUS9sNlpxeEk0bjQvRWxSYU5GMDNjSUFaZUNCeDFvYXBYbjVtdUJVVExWMXBmN0RrWUF4S2Rqbnhxc25MYXo5dGZQVUF6b3BhZWIzaTV5WXJ2RlJ3U1lDc29RNHFUVjU4TUZJZm9jaEVsVmd2ZzF1UHRzMXRIZEw1TmxMK2pRSElDcXdpV3R2TkFGSUZTd1JSaXB0ZWVKR3QrZDVQMENxSm90d1F4Tk95OTJscW41ZUw3V0FFYktwUmxmYTBzZlZkRDZ1Nk9VOGduQ1dpVHY1bHBYUmhUYWdIVEFJanhJcVhzRWRMOVRNVlRweTlJTEx4Wnp0RytzQnFQV2JqSG9WRlhPcFdzaWpIekt2Tm5nUjlQWExUYkJLRHNVV3BmSENMb0VyZGd3NkVrYWNueHFWYUlSUWZ2amgzL3YrTlN1R0U3R2NqMWtWWHJXclZxMDE3Uk9lOFBEeFZwRWpHM1M0NHdvRWc4TTZOQWdvcmgwcWhISUZPSjhnaG43dHVTcVJtc2FOU3FDQjZoMlkvUG96MFpZaStEOFVtc1lJS1ZneUhMRU1xRWJ0RFFsUU1QblV1YkFOMVNuOXAwamFUa3FQeFoydTJXbFhtbUJ2WkRPM29wTjlpRWRTVVFsdTJ6Y1RybzcxcE9pa2VGdmNBZnNCVzh6ZktYR0NzY2tEcm1MVGVCQ3JGd0hVQ0lsc0hIOVY4citzQWx3WVh3ZmltUkswRkdOUjNuc3B5NlF5SGMzMWVHV0NFSTZTaHJlQk50bmJRNk1HMjV3ZmFDcHoreWRFZWNJUThjNFJOOGduV2tlbTludHJMVnFFS2NYc1ZGS2ZFVVJ1T041bEJIcDRUSldkcUorekMvVk9RWXZzdjU5My84dllDL2JWTGNDUUVCT09VMmZmZEpQSnVEcW9wWTI3d3dKcjdXNDBvVmYwNnZPenViVnJSU0dKeGxlaEY4K25vbitFVXdPSEUzcTRYdThzdGdhVkhFRWJOZzZFUlU4N3M2WHhHVU5BdmhmaDBsSE9kMXRTZEwybGtVWmUwL2tZbmw5U0oxV3hMcXZIVnU5SldZM2FleUkyMm9ncERVWWpQYVZSZHhOL1lKVmYwMUp4aXlvaGtQTmFpUXFqWmJBbk10bFd2dzFEVTZLcWRlSGRMQ2d4MnEvL2pScE1vNHZmb0pJemJ0SjB3VXRYYStUNmkrTGUvcVJDSW8vMGNCSGJ6WmhYRnJKZm9hT3BoQ2N6ZWYvN1BvcFZybU5FUm03S1A2ZjJIVW95Sk11bjIvVzBJajlFNEFDdyt6ZzUwZTc1TXdsUzJzV3lrZkN4aW4xclU4WkowT0hhdndpVWhBM2R2eDRGQThwVlBCM1hKN1UzcEN3QlBLbW1jeXc0bGZSdUJ6MTFwQU5hREJzMHFKRGdLRDEwV2Flay94a1JQU25nTnJkd0tmSzVHWVY5aFUxOCtpanJRNlI4ME5SdnJ3dWI2Q0tpdHF1QVZlNjVpK2hQUUUxZUJZeTFvVTFYTXhzSDhkMTJzYnVXeVM2Y1pUeWdkK2x5QUszVnltNkprL1hQdWtRYnB5djBjOUVUYmVpUmZqaGhNUW1jTVJQK1JTMXVNZ1YvVWpsd093QjBoU3JEcjNXM0dxUzNvMEIvT09Hc09hSVJGK0VPbnp2ZWcvYzlqMG5VSi9kTlR6T2NUOWR1N01lOFVkNmJZQkFkRUNsYWtyMG8wZk5EVmVVYUVzSGQvVzRGM0lUR2lXTUQveXdyRDV3SjNXaDVxNVVRUGdITU0yR3hDN1plV015UTM0dU51VkI5NWR4OUU3V2MrV2JvZHVMRlplMjBSb0l3cDN2UmRuSVBtNlorZXlRckViUHFGSzAvMTd2ZWdNbEdJTm85b3Z5UmZPTVhERmo5bitxNFNGekEwU1QvQXBuWjE5ckMxSFJvUTBnRUFvYWdkbUU1YlVKOHM4VVlFMEJhQVk0Q0k0ZVFINzJYNWVIaWdPZ05WQ3Qrb0dXOG56WFRSS25EZzFBc2oraE5QS0dLZVJwY1lLVUNXMTNsTE10UElmSFNuNW1QdklxcFVhNEJvR3F4L1ZmY2hIbnNCTm9CMVVuRzlVR21lL2x1UG9oUHoxamc0Y0tucDdpRjRmYytsMGthNnNORXJ1bk8xVmM5SlFpWWRsMjA5QnlhOUw2QWFzckt0Ti9heUsyK3BCSmNYaEQ3RkxsV0ZMQllKUkRodHFBS1ZoYW9CbldWSk1MYXUyUFBxc2lQaFpVWFBTdmQ2Mll3TXJqOVJNcjFiM0RDaU9ralhhcVEvSFNZSVU3RU5uY3RLVnl3MGNrd0E0SXNUUmlXaEVGRGtLbmllZmZNR2dFd1Z4V3E5REh1cmpsdEVhWFc0anJ5SEhtNVZENUJ0OVFPZG1Dd0VGaWwralZBSm00VFNoK24rdTJHcysvbDd3bDZ3ejJxODdpNWdTMDQ5dlZXYkRNcDExVnIwR3FERUl2MHZhb3pTdC8vbEEvdUl1eDcreWk0VklUZ3JVR2ZuWDMwbzhYeUdJVFBhblZsYzVLWmJVbEIvR3l1S2dSVEhWOGwzcUJ5elFTcGFrK3pmOHNjKzF4UjdZVEE1Z0xPNHNvVHNsT1BIVExUbStxNGZqelJlWFNMWm95TXFrZEhQUS8rL0xhUzVubHY3WEczWDNsUENhSWtDL2JwOXBtNkNUcjlRNkVIV2dMRHR5S3ZaV2c4RHZMOUI4NWJoQW1wV2RKc043SXA5NFFIMklzd1FYRWVwbEVIVEFWS3lDMXdnQ3E4L2J4TFJrZ2taVHpFb1BGUjZ1KzV3R21LMzI5c3dNaUVUUkFMUndwc3dBZEZyNUpQMjBYYkZDV1dyaFNGcmhDSHBUQzRDTHR6ZHRwZzhqdXJuQUpjSGZDTTdJWkJ6ZXVrcS9SUE1uY2ZuN3JIOUJsTUpUTU8vMkVKMjFYZnNQU1VXdEN1U3ViZjF1SEl1b2FxZFVON2tnNEFmMHVoMjNmbmRja29GamdGcTFONFlVaGNjMEoyMVhHY2NQNlJ2cEtmSUZsaVpWajFTYUVMOEsweE1CcmdoMm9lZytFSXdwdHZ3L2dwbHFxaWR0Q0FVbXBySlVEdG1TSWEwVWUzSUlWeXd3NnhwbWpMajdNd1RGRjlBWXp0Qzh3aDM4SU1QSnhWUy9ZZ1BQNTBWQWlmQy9scG9rQXI4Q3EvNkFKdkFGZC8vSk9oNDJUNFBNNERUeHMrYlNWNzRuOXRVUEMvU0RsM0RWVnBHNzVqN0FIaVJXelZEalgzZXp0bnptLzdrYUVKcG1FVmhuYmtYMm4xcSs1SHlWL2E2YjBicnZ1YmZ1OXpkSzhaZEljSTlyb0VsTCs0aHpZTzMxTmorZTFySzVuNStPQWZBOU1ub2xWK2QxbDM0Q0FFZXM4c3dEV0Vkazl1K0ZRRk1velpVZDdwNTdxQmpUbGdVREFTaE8zTm9mbHFrS1c2dnp3TDdFMDRDanNXS2RVUkFNY01iN09oNEsrdkp1ZWZQSkV2WUwvNUtBNXB4ZFBaRnB3a1NGekNmczFkSU5wZmZHRWJ0MUtTSDEyNnlhVHVpbXhJYkkyL2MxT0xhMzYvS2dmbzdtNllXYjkwM3FMUlBlRERBWW16eEhoN3FPRjlRN0t5N1RhUHhRZ0NsUTFVTUV4U3I5a29Sa1lTTFZUWUxLOTVMQWFmQjg4dUI5RHlGNEFDNER5L2wyUWpJWHhKcHEvM0NBNUNzR2wxeXVUMkF2SnI4OFpCMnlocUtFY1N6YlZGZ2xWM0NmY3Y2KzU4YWVhWk83QzMySzMvTUEwaGRGQUJNTjZUZ0R4OU8zSjdLei9Eb0FJQllIblhGZHN4bnVsYWxaajB2dkZBU3p6UmViZTNkZDN3cUNkMkdrODFqYnlTc3BmcTVMQlVJSUplMzFEUXZDV2JCWjl2QzNKNkkrZXVMb3dNRzE0aUovTXc1ejFEcG1HOTJOQWh0UFZQUHgvbnFSdGxqVnl0eTdXaEFTQTZwQjRocmJvYzRRemo1cEdLNjg4bFRPWG9HMWpVS1lMT1NFTmlrRjJiN1A1dWhPc25YZXN5NlYxWXFGS1ppcktYam84OXdldmRNclIxbStGanB4ZHowbmt0SXM0by9XNkp0N2o5bjEyck5zaTVrYmNqSlJlMXM0SmxWRDNEZVlWdGdLTEZCN3JyQ2dyTDByN3pEWUxiL2VPTmN3WEZ4L2ZnUFZXWVpUL1RtamNMLy9WZkpxM2MzYWt4SDFDUkFaZGlzT3BndVh0empTVGZLY3AwYkdnRnliUHhMOW1PWHRtdVorNWFUVENJdHdHbWc2UG9zOVdWQW1DOS8vVC9DNzk0ekJGaTd5ajk0YzBEUmgxLzdhTm1idkpqdjc0Tml6aEdmcW5WUnVmOFR4NzQvZDIwcDFKbDU0c0REUVBLbDhUMm5EYUk3dmZ6VHNNNUE1dzJEdVFaTFlyR3doUHE3bDB2bWtFc3JFTHZFU0J1L2gxNkM3MWdXemJpcVd5NG1NWkg1M1ovS2VWVVJVYlZ2ZEVhRW1BNSthYnAzTEQ5REtLVlJWVUpSbGRqWWN6VWxnTFVybVptcDIrZzZlRTNMYzRQWjBxY2N3Z3ZNRVJTUk1iUFZUNmgzTUV3YXNZVk51M3JMSjZzQnVXMDBnazVnOHFGNjBhNHp0cGtBMEswT0YrT2JyLy9EQnFEcXJNNGIwbWVwRW54WXUydDh6M2dlanNUMUdhV1d4L0t6a0hWTi9OTEJXYVFTaUJSVmZwWS9CdFd2R0xYOUs2aEozQ2RSVmx5VHhZeWpzRVY2emxreW9HY1BrQjlqbHlZYkhyR1hySzkrRXJ6VzA4aVI3bE9kbjdpSnlzVTQ1L2E5K2V5VXQrMVVPaGFaRmoyVU9zbHVZektPRFRBdUl5WEt0K3U5N2ZUU2hWdFRybHo2VFdBWUNFVy9ZeXE3bHFOT3QrdkNZWGl5dk5zU1lIejBjWkpuOEhidDhUSWQzaEJOL2ZoTlNKSXlXcVBZa0JjVHhVUlY1NzhGVnJJa3pHaFlzVWdQbG9VWWc5Ykh0eU9DaUFleUUvUldXTlFobjV3VjlpQlluWnFUVEV1RHNKL2Jzc0YwSE45aWU0WEdEQnNOcTNibDNMT0djMmV5N0JpZU9DVWhFMnhuaXl0MDNUaFNueGlIOW0vZnNMb1BVVngyaUdoWmtFT1Vvell3WGp0TmU3RHE4NjZKcmFKNVNRQlJtRDc3eXdpaVdwSXg2NGtkR3JpOTYrNG1wZFlsS1JJK3NmZlZkRmRpcnZ1SlUzcHZ5cDZkbkppalJiMWRjS3VDRGlQajBwUC8vVC9mekNIYXczdWZpWXBhanpKakRraUFIa0twNnYzeHRySzczMDFtQkY5bDFEUGszV2xOZHNnSVpCdWE2Q05GRWM3aW80NWpYUWtQQlRqZWpMNzhTNzhaTWF2Z25wUDFQMDhjRC9NYm5kTnJuMW9iT2FVWUI5U1VnZ0hHTUsyYTRqRHR3K0RZVWFXTmVsNE1CSUc0aS90VUZnVGZRT2VSK2hEb0kyaHl3aXBKeVJNcWduRVcweUR2ODlXc2NMMXgraTZ3SXhIS0w1TUh4eTI5UVhTVWt2RHJROE0zN05tUWVaeC9lNlE4a2h6UUxFQ1Y3c3R1QmJhZi9DdHJUTm44OEYrK01qOHZaMzFpcDIrSDRvdCtRMzBuRXFZckFrd0lzLzI1MWdYUTdFUTBqSld1OHdIVnA3eFdwcEdLMmdWb2hUY3pLMVp6Mk5meEtyNUsycDY4VWI5ODJLWTE0MVhuQk9BNzZENjlIU0hicmRwZFNpc0ZzaUFUNGR0QWMwODhRQVFyTzBCT2krOXorSEZEeXBOSU10YVA5VWU5b2ZTTU5aSjhxT2U1UUkxTURnRWdQSUwyQW9TSSs1b1ZyU3BOMHRoUG9FTHA2Wk0wTy96S0R6T21QZm5HVGQ3SVJEL0Z3SHYyU1pzTGgrRkFGdlRjQWpsbWVZMGNUVlhwaWxySnp4WW9tT1o3WTIvNGxXVjhoOVhNQnVEUHdGTGVnYXRab3FWLy9QaVpxSG44N1FiaytKUUdOamM2MldIZzJ5bGJEcEh0dnErTElkUEpON01SM3ppRjdmLy9LenJqb0RUU1BPODNvT0MwSmdzeWlpRnpPV3lKb1ZweWdxMTBBaE1QQ2FzdTBSMk5ZMGpNN3J3b0JoeE1aaVV0ZG9BTkw2TGplTVM1bVpTVjhMcXBTalVOQXRQcWpoRWpHUmk5aFBWeWxzTzhaaE0zU2NYSjFzeDVDVGV4enRyejNYZHJhdGEzOGo3N2Y2cFNxWFRUei9QN2ZiK2Z6NDdtd2Y1WGY5MGVQM2lFREgyNWUwRm5MbGhkenJJblgvU1NpV3dXWTE4WkFKbmVNckFJT2ZPQ0hZeHhvTnJzR3NEWFowMEdlME1XZzBDdnJSZDllMVdPY0dZNXQvYmZNdmJlckFMdHEwaDMya253TVZwZWI2SFF0cHE4S1NXNE1PTDlEV290RzBUMWNWdW5zQzFucHFKcXNMM2RRbXB1Zjk4SHh1U2RJMjlKekZXbEdEaCtQelJud053QkhPYWVnVkl0L21aNTk0TmNzWklPOWNoM0UvaTZlVHJkbTl5N3VYSm12S0tGVktZeWVpYmRncXphOVNnRTl6N281WFBVdTJTQkFVSFBYS085VmdLeWhaanRiSk5FOUN3K2YySzhySjBQSVpCWDVaT0RzdlBVWXpFbDZEVE9mQTlZc0ptSy91TnR4eWpnU0RLaG5hemFTMTZBTEtZSDhmOTFpREIzNDZrbTg2cFM2cnlVS1orVFpBVzZJVktEdTY3TStwdytBOE83S0xsVnpNeDhZMFZvU1lzMzRUYnNtWEpNZEV4VzZ5cm1qREcvbDk1TnBKcUNjRGpraWk3NEpzOGFVaW4xMGpjcmdzeUJwS3pWd296U1VqOGMweTY4eGsvdnFaL0ZIWitrSmM2V1BLOCtyalRSZnVDak5yUkJMRDcwbzdQZDgrOS96VjdhbldsS2M1VENialRidHFXYjRsekZZOGQ4ejFacldxYzhyLzc2TDNVaWQyZGhGUG9XTGZMTU0vZXJvTXlIWXdlK0c1MzFCdjl6TjdNaUlNc3VpUmg2Q2VRQ3JxMGZ2YUZiZnU5WC94UklpaTYvVVNMd1RlV09HNFVBTXBFWHdYdGtWSkRjZG1XRU1hLzFhdmoxc0l3cUNlcEdIMzIrMHV2NmExWXVjZ1M0MCtub3hVZU1qY1hmWjYvNC9wVDFINjhnZ3dFRWthZVJKV0o2R2NVcVQxektWVUtyQVhqcCtpb1hlNERvU3NucVE5V0RBNTBYOU1GSSsySjhycXdyelhIQVJ5Lys1WnZ5M09xVmxoT3M3N2o1RTJRU3llMUdaS01mZkp1YlpSbjd2NktGeHI0ZmYza3JGdHhXREZuc2NwVDdNRTAyUlNjV01NclRnYWhWQUFBZ0FFbEVRVlQ1MWxNSlppU0UzaXhKN0FjNm9zS3hmdzFzT3dRbFpXcUdHVTZMWlhpU3Awbzl4d3FqYnN0N1RYQWlHU3lVR0ZWd0NHam5JSWVNeXNlbVExZ0JsZVo4dmlNa0p3aTZyRTkrNGhaTVF6SVNhSU9tbDhIc1FXOGxDdzZxOFdvdG92Y1hSK2VkYi85Y1BWeEhzbmx6cSt1UjIycjBSVTZ3TmJFZXgxWHNobkIzWnNSNHEwZ0QxWFlNcFVCYVIwcUJXNDJiT2VCT3J1Mk0zRUhIcFp3QVYzRTNvRVlHMndOOFdMcEJPb1FPSUFGcityOTJJMGxPLys1T1h0b2c2ZjhhZjJZbHN6MUhmL01aK1hLSlBielVIWHF6bWRnUDRPY0F1WVlodzZ0Z05JK2RYNllTQlRzNFlReDBUU1dsQmpDYWdOSzUzd2VTbGMyZi8zZEFIMDlLMSt0SmZxTk5Oa3FHaWdHZG12eTd1T3BodmxxNmdaTk84dnRxUFlNWElJYXBVekdValFZL2JTaVU3M3k4c01ieitZTUFjUkR2eU52QnM4bktEOG01d1d5T2Q5eHZxYitNWnhoOFhHcDQ1bThVZE11SHl4ZldHOVNBSmVsRE1vU1VRbi85VldPTVlqbkFtNXdJTEM0VmxFMEUydjV1K0ZFMUZmWnpkU0YyOE5qYWxPMkN2RHhsdkFPK05vSXB0YmNiOUpGUE1TMlFzSEdmUFl6aTAvZGFmWHJEV1MxTlhEbExuczRWdWtBbk11aW1NSDFualNybjkzNGxWR3dLUys5SWdETUs2SjloVEJ6cEdLSzdWak1iendSaXY3QVhvK3NWRER5Y08wNEp2LzB6bGEzQkpBcklIOWVvVVpEZ2JNNXZMNUE5cDJXd29RYmM1SU9ZVDc3N0h2aVB6WUNEaUVpV3JjRXYvVHdyOER3elFkaEdselF1RnJYNjFxVHZxMkhEMnJDWHBPTFBqMTVrTlhMNHhYUVpjU3NzUFVlNElPZkRzaEw5YjcvbkEwVUQwOGovcUhyMjBDWjVLV3JwTjVpOEVIOUVyQThSU25oVVJzdEc1YklSMXpJczI0KzRyVEI1Q1pEdi9HN3RhQUxvMEJYWVpPQWRpVVk0RG9CWUlzM0ZIOEp4STdIU3gySSs2TGF2YXRKSkp1R3NXa25aSktvSERsRUhYTzVabHlHMUw5aGR1Nkp4QmgvRm5OdXVLTkZwWEhBWjhpMjJHV1duTWN2T3lCSXF3THhGa0tMOFUzczRwNVRvR1RIZ2RFMjR3ekVlMlFHWjdSOTNOdkt5VjlIcGV4TmZ2c2F6OFA2bkMvSVY0c1RjcWtkTmFSNEt5a3ZjeTdUUlZ5Y2VackFpWXVBSEZmVDJYMFlYdURWOEx1Vmd6bHpEcjVWZE5UZ3ZMa2NEenJiMmxneUxyRXJydGVJWm5hd1czaFB6TlJvenZGT2JvVGVIdHBxMGlXMzExODQ4cGxsMXlMMEZFQktqMUozL1Zpc0hOV1FDQ0xlRkVCQ1YvK1l6ajhvc1dLcEtyVUN5eExzSjJkaXlMb1BMOTM2WjNxZnlxSE92bm1CTFVzSjNJZEJuYmRQM2txNnY1dW93QzNNN3E3MDhva1BsMktHTGZsRzFEQUpmaXNwekZRN0NaOGhiQVRuSStDOE5GeEsvL2wzbFVCdm1VTElJK285WEIwa3FiS0JTQURZdmFGZlNLMlBsT25DcTBMYjV1M2hhalR4L25VblRnOG5vbTRJWkhSYXhLTktUOFV1b2FaQ1FNeXhHMkxwK1R5MXNzV0tiNFpnTTlSSTFiV0xSMWlnazJuWnBzYnh6VjFHaFVweXFmTDMwelQwKy9WdnkrNzVFVndWa2RBSC9FQURWdFByQ0hGdG9QaTZlY2tCWTgyK3NPWXo4ZG02TENSZzVmYm0rM3NyOEU2UWFQSDVwMytDcEo0czJRMjMvWjJDTEdkbnVFd3JZQUtDMEgxeEwwa3Y4RklzV2hqUEJuOXdOWjFDR2FrZkYzQkNCbkZQUU83KzZuMDUwdGFGTXF3enBETmR0RDFENkdEZlRLQW9uSE04ZUswZCswd0M1VnVCR3BPeHEwRmFoVXQwdE9lY2taT09OdUV0Q3RVNDUzdGxkK2hiRkI2S2ViQWRKQXdXb1FwZUJwc0Y1Qktrc25leTc0aHhIdlBRK2lIQzZQLy9CMldKZGVLOXFxdkQxY2pPNDAwaXBHSnFTVmtxZU8rZkRzcHE4ZlNyeWtzeHowaHhVdE1jNGVSQ0xYZG9xQUlVZkE0MFdIYk8rZk4xUWRGbVBmQ1FHVVVrZDc4VU8wYldyUUp3SzhJZkFtRlVRd0MvcmRmNDg1RUJzWVluWWcvdllra1ptZEdvcko5VGk5VFZVY1QvcU4wemViUHYxanpsbEF3K2FsdEVqa2lWd0J5VmJhbDhpQ1VXZUJXeGk5WkFoTC9xVFhMV3Y5TkxoTEN5WCtWTkE0emR4c2l5UU4rS3ZxWlQ0UUx2ZUhBUEtPUzlzazdBcHhIcmgxejlNS1FDMlBJZVo2ZEx5WEpISWV3V2xyVkI3U2Z6SjVrQ0dpWnZDaWNnZHludkJNTHQzVThPZUFwK2Y1V01wUkI3Q3h5R1dtT29VZGJFRU1lQ21nbVZtVnRiRHJ4NXFRcERrQ21iOEwrQlRsK2c0YzdkTis3bFliVlpkSDJZdTZCK202N005SjdLcGhTazczdi82WG1CL2VQMjMyWG9vNUg3L3ZCRnNOQzJRRzlHUGVtMnZOMmg4SUFqcWVETE9KOW9WM0pmSFlSS3QzYVZBVTF0aUdmdHB1R3BadWpDR05nNHZTSFhMSEtXVWhZa0hWZmx1bmRsTXV0ZUNtakFDclFLbnBjeVBBMytETDZTV2pHbTdsMDVubnJEY3FkeC9qdzZVc3RFdUNSQmJEMVBRRk9taytZeWVRUlpsSXFPN2QwM2NUQzA4djEzOXo3ZHU4R293WXpKSEcxNGZCYzQweVFDbGs4N1dxQ3AvYk9mcTNkSHNLbVJxM243d010ME1ySlA4QjdnK1IxdityVHpDR2dQZmxCaHYzSTBjOEgrN0Q2alltZElTQUpZT3prVUxsdGZsOWFxSE96a0N2UTdSdlVIemtUTkhHcExpdEhkMFg1V1AwdzBxUFpCOFdlcERTcFdqemo2Y3JyeXJEQ2NBWFI2Sk9Gbi8rVVpmeHBxajJ3dWVUUzgvaHREdkZ4enNBMFdLVlpkLzBOTW5OYjlwaFBOWmZWSFRGbk40NndOWDZTOEp0Q1NXeVczOTJ4bElsL3ZleWJSUGZ2aGx4YlhYd0E5cHNuNWJOcC9xNURkQ0hrTWZ3dVh3d1QwTityQmFHcjA1cnZ2QUp3NkdjK1RJd2JlbVNrc01Rc3lpMW9iUjFKaTJnTmMzckcvNnB4SUZncDh2THdZeUVYcUk3VldDVExKbHNHb2twWWl0cmZqQnA1Y1B3V2JRUENzdCtScHp0aGJYamdmam1xY1pUbytzMU0zNG14clkwWDYwMHlZRE5qT0JhY3BUdFVIQjNQM0dtSEsvNGRoUFozVWhBbnNUU1ljVzZWQTM3TzFVcmpjaUg4Y1ZNMERhanRJcklydEluV1Y3RFQxV1lPQlpQRTZRWW5UZ2QzTW9wOTNSL1dUdDQyZElPQnc3OUFzMDFNSndGQ0g3cEp1dVQ5dkI1amxuejN3REg3Z0p1N1h0ZEVRdmxqSEIxbnpSdTZ4eTF3eXVWSzJsTzN0SnpheEkvYVFQOFIxV29xbFVLemZsS05LUXFqV09BVm9GbTRjNVZQckYyMUp0ZHlTUjNHOGJOcENMUUtrZ0ZCSTV5SkpOb1MxbUgwcGRZeWhiSkxVZTdmS0x4T0k2dnUyM0hkcGtMeGVTQVRkR29tOHdTemNuK3RGRkZNWm5EWllJbkttYk5kdGpvRnoybXBmTk04UTNvemVlc1VkcWtvaitvR2V6WUFWOVdSb1l1alQwYWhWazd1ODY4RUNPRmlyMmhWbzViYVBnSVVGbmdKQmg2dkk1VHI5V2R3VW1Sb2ZEU081MFdqY3lsMllhRDVCMi9NWHZQWmtTZis2bnlES3Z5aDlEL25neVhmb2Q4cHE3bExPb1BkTWFVMlllVWR1elFvd2ZQRjFSUTFoSUgrSzdUOFp3VDZ1NmZLMzVhWDRkNUdmMkhrSFpKd0x6S1A0SzNTaVp4TlNQWm9CdVpWckN1Y29paEE0NWIyc1dVSks0bm5ucGhxY1BlWVM3NGE2ZHc0QzlXZHNmMHBqa0dabTUzZG0zZk10U1ZBMkdxaldaWnlabUNvOXJuSjcvK01CNUtiM3JtMHF1OFFCQVE4bGUyOVhKaG9FQjU4R1plZUJEVmJFNGdGcVg2d0IvdzhaYzJUUWFTK2VlQXM4T1dTSURYaWhLcVBRN0NaMGZFTXR6YXFhL1Z1Nm9rY2xMb2VzU1JBT3N5eENUOER6VlNUY21McFlhNzNnZnVhemMrVDgwZjF1dTBVbUdybk5VMFUzb2czNkxiQWF3U2ZycVU0aytyL09tV3FKR0R0dWw2UFpsQmpnOUdhNng3V2pWNGUrNElHV0ZGWWpRWkEyTEFOMzFoSHVoS0hGMWZSZG16WTd4ZWlhNzhJSEtYYTJGWWRlRm1UTmc0WEhiYlJIZ1p3TzVBUlBwWVJacXY5bUJCYnorb0FuZ2Y5QjFsS1pBWVFGdkN3Y0xKSW01b29KL0dBQUg5ckszNzdmNjh6ZVJRUUlDNEVyVTNXd2hQejhFVU5rdkQ5bW5Ya2tyTmkzSmcxV1RONW9FRGZiVUYvMVU5RzNzaXFLVzJLL1RmV2pjcnNMQmNGcXJlWDMwYWdaSXVTY3VsNzg0c0VBdVFLbHZBTWZtOXNSOE1EUU9weFowZ00veFF5QmJuNFdkZGlrWlBlMFhuUWFtVnlFc0pYdU9VcTY5QUtZdUdESGgxbmVSMGtYMDVpOTF5ekh5WXhMRWRyYkhRWWNjRkFKRDdiT3lNOFJSR2lmQXdvRysrSU84U0VQZnF3cmhpK1FkeUlmbUdGeXZWN0x3akdteWU2RE1ibFF1N3FqV3BNMlZCOXlkcW9aK1F6QVBBQ3U3VndDb1dTVlY2UGVCK2RJV0pKYUtLaU01Z1BFUXQvUStBQlNFUEMyUSswa0dVRnh6QVY0R2lrUC9jdHZ2WWIzZUdZNHo3ZmpzOHllRW9UTUh0UkpYVjhNTFlaNXhZQ25RbTNLajRZUm5rOGtGMlpNSHQ4Q1lYL3A3cXFyQ3VNQ1k3czRyUVJ2OUZ6dEdkVWgrS05zeS9JWHFTQ2syWUFCSFRTYTZCZkpHc2RGblZNL2Fhc0o0aHpwYXFKVFlIQnd5OCticjVlbmRJcFd6QlZCaWtHQzdDMjFLaTVSTExnNjViaDBIL1BjWUpvK2VHcE5tUWNZdUE3YWhZdHdIckhOdzJzRVl3NkhDTklkWUg1VWFreWRlN1NiWUNPTUZzVUxpdmQ4RDhTUEg0ZHF4MEdrT3VSQmZzSHBlZE5JSk1tN0IrR1JPUGFsaVlqNFpCTExuaGp6T0dSZDIzME5lV2piUGc5RXZ5WlphczM0M0NmWjFBNGJ3bGI2MVp1Z0UzazhOanNmTjF3UkhDYVRZandDQUczclpnSXk5UWVjN21lb1ZSdmMrTzFKcGtMQ04wWDU4aWt5OVF2ekN6d2ZCdjd5d1lmT2QvN2NPRzBBVWF0YVRsQjgvbmY2Q3lNS2Q3TldhTnNkamFOU2NveTYxbmQ2NXNCUG9LbjJ4QjI4ZGt6amRldDNlTHNRY3Bwc2xCTXR6YzQ2azEwQlI2OXBZdlNkcmJJVVI1T0JMMjFCVi9Sa1FUd2poZ2Fyb05jdVNQWjh0MjZQUnpqZCs1WkpONzU3TGd4QWNvdXBid21rdWsrb0ZobG9nUTR6bzlKMmdpYyt2NkFFa3NRWDJDaXd0T2xhbXdHWXArdzlLb21MaXJWV1FCUnIyNW9WTTNGbEFJWWt6ZnloaGdzV2M2dnduSnlmL2VHTTIvVUFJTG95dEVSdkNLOEJ4QW1QZ3RFRE1naEZ2WGxCakF1bXpjMm8wREg2b0FZc2Z3eGFBOHBIYkE0bzMwa2RpY3lDbzBWSGR0MnVxTmdBUE5zMmMwWWdwbU1vZjRGVlhIUEg2UDdsZlRCY1YzT01IeVI0VEJFdHZ3YjRWSkZtQkVVeE10dWNXaUlqNFkrbWF5YzlMbHdZV2RUSkJNMFVBNEpLclRyM0x1MUVhS1BqTGRrQTN3aVV3T3ZwS1h0WmhuRW00TGV4OHlaRWxZdFpvYm1IdlBqMVRmY1ZCbDRwelBudkw3SndnWC9wTmtCQ0VqVmJ5enJucGtJT0s4emU2V1BuQ2dqK3gvZnI4d3AwempsVEt4TWw1TEM4MXByQXdqU1N5Y08rc3VmK0hRbEZQS1Z0bmtDV2pBeFduRWZTVHI2NGJqR0plVnk2cDFrRzVTdmdjS1l4UkhOTGgvSExsL1RtOEQ5RURVbUJPRUg0eXJwOUhuZit4MnVZUEJpQTZBZzhHdE8yMmMwWUNoV3EzSnhUNFJDRVNoRms1dUxma1FGejlxT05uaFRaL3prNk8rUm44WUsyQi9PNE4xeTV2SWxzbzQ0MjNxN2pNOFFrMTUrWW1MUCtqbnlRY1V6MisrdWtWVUhCYUZkckwrbUJlSDVHT1NQb1EyL0o2K1JZbGRWYlR2N3Q0K00zU21GdnZmWXBzU01OeUVHWUFhUGxRZnpQNExFaWcyMkpPa29TNGJmQVprNm9wODVHTDB6OElBTnNFRlI4b1ZmVjIvMjJDMGdsd2tlRC8wYWQxaklySVBzb1M0MkRtVnJtMVJjQTBiaEJqWHlqZ1hwTVpVMDlPZzVCbG1wNlJKbnNGYlVuZllMdEpwSUFxSzhEZHpGYVBNVnd1ZnZhWjVGMWU3N2JkWFZGQWdZOHEwSTZISFB6M3g4UEI5bXFKc2RpV2ptV21HQ0g3eEFzYStlaGlwbEU2dVdXd3hJS0NPOUxuRmYyWklUQUYrSTVHK1dFWnhDbjVxS0NHb2NnNWEyd1l5UnpxbytDaWthMGcwWXR0TmtvZGxMRmtDSHcwR1E1Z2IyY2FJUlFNNENOK2hYV1d4ZDROelp1NVBkWlAwMGUvUTBHN0J6TlJNRjE2U3Rlc0d6a0ZXTGRqTzFCdUFDOUV4eHJzZ3hxeFpDRTJIR3d2UklPdUVaem9nWTkzQVg0Mjc5c1FQLzhGYkd5M0Faa1Y0TWFaSUo5T0F1V3puM3liUmpnS1grTXd5QzJwbG92ZzVPRjJNUFVlQlkxZUIvc3ZWMlBndkxvbEhVMjBUVnN2TmE4M2ZHbDQ0NjFVUXdkUU5YQXVuOEF2b1h4SmUyc093SldZTUt0YkxLVXpRUnExT0dQR2dhbnZwSStCOHRtd3IvWGtYWHpBTU9WOE94Zm1CQ0RQSEJMdGR2WmxmRzhVNXBJOTRlZ1JrUU9BcU5jZFhyb3VvRFpVNzFYNEVBSUJhZjRXelU4RHJMNGx1MVJMTUF6KzY5ZkxrcHk3TjdNeFMrWFhyejZLOVNFby8vM1c2bjhvbEV2c08xMlVkR2JQMHlqOTFvNkV2R1A0OERxRFF0NzllYktqZ1dkKzRYclRQZkdNbVQzREt4VEdPRUlpWm4xcGFNMUlHTFlYSElnWXppeUc1bVc4T1VGRlVNT3BwdXBVUUt1UUxDZHRXSmVvbzQ3UlRQUEVyQVVvWWNPY1I4RHJ0YXJrVSsxdVhhN0NhbGRLWG9TVk11VDR4Tno5WHg5MGg4MXVCRkZVQUNFUEowd0o0bTJtN1R1bEV6ZldWcVB6V2lGcHM0R1F3U1RNbm1JQ0ZxcERVdHdNbUU4enN5Y1U1cXFmcWF1L2FyZFRsSWtib3lCVHFUM2lkRDl1T25RU2pGVERuVGxhSW95TmZhYjBxSzFFREh0bjFRQVoxK3RzalhBajJlaHJoZ1Q3WjcxbjBXNzQzb0Q4cHpkZzNoWlhkSkZUR0dYclpVSStSZkdEUWc5cE45aVk0LzJjeGx3SHpNSXNZdU95WXNiQ1VNMGtHNlEyQlhsV1JkUEsrTmRzVUQ2alYrZ0tzZzgvSFd3bjU5R2pMVXIvZmhnRWhDN0FGeERlQWxtTjhnMGlVSkU5OG5NN3JxNFZjOXJkZXgwOVhuaTkxS2VDOXBRRlBJQjExUFdYTHZRWkhrNFVQaG5Ya1J6dytvT2hPejJpbm5Md0ppNkw5WThXOUFsbXJlRUYxblNGWlB1RmxnRzVBY1gxSGtMSjRQUHd2am5KYzBCbzlrejBVWjM3U1JPc2RZU3A0Smt1YkdwNy9vUkdiOHNINzRJMGFGcG9ITlloR2RsYXVtWlByRytubGdhNDdKazhQWmU5eTJja2J2TUNzSjljZSsveDFpamxaUnRYamNuaDkyUHVKMnV0ZSsxbktXenE1QnN2RDNZalBzTnpscndGb3VMZ2lGakhIbDRXQWlIRThBTUVkT3dmblRrZDJUY0IwcVFBWFVtd2hBbFgya0QxQmd4aDQvTmIzM3hGME9GSU94ZXU0VUs5TllvSWhtR0VRaFlSd0RNTEtTVnJmNUFrNGkyOXRxRWtZcmFRSGdJUWlKYmpwczFJemFseUU4Rko5cVRYSW5KWmU3N05GUDZER2dGQlQ3VmhkaGpVYXNKZFpmZ0ErRjZyR0NBeXpqMlMvL2pDWXcwK3pYRytBMUZHaGEvbWNNRkthUklRQ0trRjh6Y1NpRWsxcytYM3dkdTBMd1dnWTNPU2N4UEhuZ1ErUVhNOWRzUndKOTM0REFweitwQmhZS2VsUEE2Z3RCeFJNR0VkZVNJN29XcjBETVBEQk0zYi9oK3JqeW16ZGVzeGZaQU1rclA0cHhnaWNza05vSFNtQnJmTDFlKzczVjZJR0ZLUjc3bjRVdW50SHI4eTJvZDJTRFlseFZOWkJXZWdHYlM4YUYrcEUrd3hJSjJzam95SnRneWJ3L1hrSXNKend4UXRnbWtodUtUZnYxZzJqcktJb3NVeWFFNFcxbVVxNzA1VlQ0N3JyZGkyeCtPOHVRMGdPWTBIQXEyNGhXQ0dHMXlTZUk4eHpPbk5aaTJ1OUNxSWVHbE43MjF2dThkT1pIMXZkTWt6eTlGZnBQMzZKVktUQlMzYlVZYmpkQ1hLM1JjV21GcEtCY0dWRFdTZysyOHBtM1BrQW43YW43Y3ZvUDRZaVY2V1UrRjR1NmF0R3VYY2pJTVkrQXFmTzJFNmFxZVJEVEpKaWE3RkNmaFpDSFMwdWtaSUFLVUVjVzhQYVJzOXVwa1h1aVl3T3FGNUZ0d0xKRllFaGFtbWY5ZGVDUEllK3kxZDBvMFkxWlpMWWpnaDFpWmdTQmVQTERaYXQ2SE5pR1VLaEJ5SkJiTTZGYXNEc0twV1dvSWsrbXpJbElPc3hoa2hpVVRpZUg5bnhhYjVaWnJDQ1BhcWFtUDd1a3dFVHR4Qk9OVUpzajJnc0dKS1NqRDYzcHVka1BCNW5qZFN1N1ZmdFZiTytBUmM1K2QzajZVU1gwN1dLTWlTNCs1eW9nWTRqVHo5bzNmSnMwR25YZWNYR0R0eWljY2VBbHBzTmRSdVJub0g2a2p0MjNlVjA4dGdJK2hiYVNTWlVjdlFZaXBFbnRKWkZjRGtPdmt1MkZNSWlEamh4OWsvdmRtRjBzMndGNHZFak9KejBIWldGZXU5VlZNWTZoU1F3OEsyNEp1anBXN2hwUjJaeDhIK1UwQkQyaEZTa09kYjlsbjAvc2tKMHYyb2xXQnF1dS8zQUE5c0V3b1A4MXhjeTFvUW9JSTNIR3YvdWtXRTNnck4rbzNkZnlBTXRRR3pRNFBQYzFkSndIa3FTRk53cll2emQ4K3dMb2d1K0RQWis0SXZFeGlidjdYeVFlMDFPdEQ5dTlNK2hOUFprVUZMZ3JaNjBGWXZhN1BRd2FLUzIybzlTeTBUSEovbzBZVm9HV1hrcUh0MW9VN25SQlA1TDRjR1lpRTdMOHZFY0ZyS2pPbzU4N3RhcW5QUjI3VlArVjdlMVh2bngzNHdWdTdtU203Y2xvKzRLZWMxY0RkanNaSE1yaFJzQkpkZXJWSHlzdTVERnpOMTNhQVpIZWsrb2RsWUhIM2VtODJyWEwwRms2V0FxTFpkS2RiaW5uNVdPa2VuZ3d5cXhpSm9GaW9HellKekUvQyt3TG8xKyt5TnZxYVZXcVprMmNBT1lVRHZkckswblQySjJUbmkyRnFaU3RkK1pjSnVNaUY1azZTZDJXL1kweGd5bG9oY1M2bWNlbHVFaERTYWpJR2ZHYktwbWcxbThMcXoyaVcvT003Zjh5dzIyRko1WDVWbTBUNFpzN3BaNUhjdDR6WkVrRE1vTGZiaDFTY1VPbDUzOUtRK2paU1RZbjlUdFB2NU9wcGlMSkx6SXdXdmcyaFhHdDlhWStXYzQ2N1haRUxUQ0JRMEtsZ01QVWdjdDUvL1A0NmU2RlZFUkQ0MnVwTVZqaDVmOHdKdzRIUTBhd2svcU1qeWs5WVN0TEtpbUhaR1BBT2hkOUh2UGlBL0xWV0c1a1lOWEhIRmR1QXN1MTQ3aTdISS90Y1JXeHJ2MWt6Rmx1eUk0bURIeXQvL3MyUnJvOTVSTU53dzM2aVZBNlNMZCs1RThHSTVhWW1kdVNZMDlNbVVlbHd4RzdmZ2hiTzdQbThiV3lBUCtXYm9FZkFyZjd4ZktIKzlDcWltVVpkMDhpUnFhQ3pxZmxMQ1FNcnVCcmYyQ0hCVFNrdSt2cFhYY0pYQk1hTElRenpwd0hUU3RtSERxVXdrazZoR0FRT1gwcmVYVlczRVpFN1lXbkEvcTl6T09td0g3bkR6Y0tDOG1WcU1LNUJjRDZtR3FiTzdoK1dKNnhEWS9tMDRvS3RwY0hSUVNqYnBOT3hucWZUNHhmdUd1U3VFZmladnJVR1Zxd3grWHdXZ0pwckR5ZktiZDNyak9jYWcrRFlmTWVxazBuekZpRVBNd3Q0cEh5d0VqMjhid0lnbVhCa1ZncElLbElDS1ZTT2tEdzVMdXcyQytpUk01UTA2VEU2amM5ek1qdVRUNzlFb2U5ZVE5aHdSaEQ2NVh6TnRQUFJLbC9aNlFaajhMb0VsOTltTGlJYytBL2FVa2tkaWplSkJoM25idnJhYmptQW1CVE9LTkhMMDhSNWxHTUNycXlKUFdXTmdmWjVUbHoyYk1EMllJVXJkUGJMZUI1b0hYcXdReGZKNmJaSGQvZXRXOG1HdDlUSkxIZUtxUTdNYlZkS0cwK2g2eHF0ZE1CQndoTmkvdmZUcGEyc1MyUzVZdGtFem0yTzUwK1ZzWFlYbTdEbjE0OUhSb1VCM2thYW0xUitPM0Fac3NpQjdHZHdIYnhFTmIwZGZqSm1IL25NdDdVMjN5dE1qYlBOUC9rMXgxS1VIaGRoeUltendTZm01aEQvdWZyMjc2OXplcnJybmc4SlQ4QlE5NUk2VCtMUkdLcnI0WjN4V1hwWVZCVzZjWUF0QUlPSjRZWG0vQWN5YndvYmhpRG8zd3pUbkJwcHc4Mkt3aFJjZXNJNWYrU2J6MVNWRUh4R0U2MUt1RlNteGwxeFNyQUdFSCtHVElsRGRteGs1VXJGdUs3dnBmbFQ4N2I5ZXRld0RPUUV0Rkh2aW9FZm1mbkRhSyt5QUhXK0Q4cWtXT1hUb0loajJQL3h4THUyWGYzSHlmcklNL0NqODVDN2c0c3JRZlBjaXl5R1grSTduYlBZdUFNWTFBRHBvUWwxbEwzVmVEUFk0c0UxdW1KeisycVBlTjE3UHZ1SVdzdi84VHVsLytTbWVuYWhuQjRzSTBzR2YybVNLT21TMWFpbDU0cFZBc3I2R1JNSld6NmJZc1BTYk1odG12UEJmRWpFemd5endGazlBVkZNbUl3SGhCZnlZZzVOY1hEWFNRVnFlbVJKVzdXMXBrZ0IxellUR1ZBTkkwdXA5aFRTUzBtSzIyTXpESDJ4Q1p2aWNvMmEyb1M5VzhjMWt5TFVtNmM1ZnR4YUQyMC9FWEhQanVHTml5M3oxaWduK1c1cXFVTVlWbUQ5RlEzYksyWEdGSHpzalVOSmxWMUY5cjRtcUhzeWhiQjQ0WHpIMDVkNXNRVG0zV01CT1h6R3FiR1g5b3lObks5TWg3TGJUZm1UVmVnMndwWTlvVXlJaStaeWVtcE5NUWprRzJtdXVpdUlUODhvcEd5Q1owYlJVTCtjWkx6Wk1MMU9jYTdSUmpCakVVOHdSSGtDcjRUMjhBY3JZTStvM3duc1kzTFBGVWNlOHRuYnZRbWJvTW9PSXpwSjlETVNJcmgrZkNDUVRlZFlCWUN5cy9MZkw2OXlGK3hkWDdycXM3YTI0SEswWnNjZEtyOGErSmp6ZDh1TTBzb3dmaWRyclBxbncvQW90WDRRQVp3UlE0a0lkekpSek9nS2lkKzhyVDJuOTV4eUU1SHp6bzhDQ3FyZm40UC84Y3k0VVRyZ2VYZE1GZ3hQWjh6dEh2eW1ibUptWDZadFFZVFVpL3lzQjR5ZDdmanlQWkpCYmlGUmFFcXJaTXJSVnFQRkYzY2lzMTk4UnZjYkFCaEpJaVJOa2FKdk5jd21GaWxwWGVuQy9FbGR6Q3YvYzU2ZC9kbEoreUxWQmROLy9EZkRLVExaSXpaa3dJclJCNlpvMm1nNjk4eU1iaVdrRjRobU9LNTBQOW5KRGM2R0JMOVFGcXpXNDY0eXlTQkFnNGY0SzU3YTdLVE00amVKZ0Z5a1RRRS9MaWVrcmtEL2hNbkJoMDkxLy8yMGZjalF2VjVIWFRFdG5HaGxtRFBtNlp2RjlJRGpJU2VYYllFUjJaV0FRdzQ2MWVkZEJGa2FhRTRMWkVzRXN0eE1UN0NuOHVidlRPQjFTVTJqQkZTQ0Z1L2RLMndadWJoeWE4ekF0dmNDMU1MMmRmS29IQ2VZaGxEUys0Rzd5SWpadkRKbXlSV2dCdUFBdytSZ2NUMGI3WTJYSEVsbGxaK0VPbWE4dTZxTWdybEM1NEtjb3JxcXBWTG5ZMldaUWNSVlNRN2RrVEFKUkkway9NSVd2L3N2L0psVkEzaTN2K1JOYlN1WG9TdG5Rc05adG52ZmVHZklFTUZvR0NSZURaNGR1Mm4xU0VFdUN3MzhFUXdVcS9FakpuRE4xUEtFVnZHbi9Pcno4dVVSOFpmcFBBOGpSbXpIN29jSjkvN2dEQWhKSjZaUHZKRDFwWmoxTmNSbWNISkJMNEtaTUpIOUIyT0lsUmdIY1ZIUVp1RnpMNXFWREJDaG5oVlM2aE1GR0pXVjVhUzRwRWNzejVSNFYxN25Ga0FZaTFkTDhYTDByRFVQejZDK1BEb0ExTk9WNW50SjdqaXcvU3dPK3Z0N0E2UkZlMEpPd3FGY2h4YzVMOHU2cWRZYWpwdy9ldkpaQjZrbEY3V1luV1ZCNi9mWDdSMlpZdmtraWVQMnpZd3Z5Qk1XMnZseVdvMGZQSDd5ZXRrdGlCTElHOW1BYm91Ulp5cEUrMWJRcmNvUGh6TUJxSjdqUGg5cTZNajR2Qks3VU1vdGtRT0pZWmFlTDJ1UjhzNE83L3NnU1ppRXlEQ1ZQNytaZVh1R25EcnI4VDNtQkxtQkk4Q3dvMmFnTklsakhnbDBTU09YdlRmUDFnTnRZcnhSd2t3aEFUZUhrTEQvWUd1bEw0MVVyL21DWDdqN1JROVVHR2hsWmJSOUx3VW1sa3JIS2U4VEh5aldKS1FhSVVRUEltWUpWNTNlbDB5alcvV0dmd2ViMzVSY1ZvT2ZZRC9adWt1bzR3aC9MZkEyQWxvaXFWRU84NFVvWHgvTzhKbzBoOGl4VTRyMVRkclkrSHNPdzhHZytzWGRlTDRRRmNvbUphM1JUTlpxRUhSR3lwZktvWTRBU1VQZ0N3ZmpxSWVCU0JoRU90RTNLeU1Tc25vK3F5ajFWUExldllwd0xIZ05mdEtOY2dZaStBeHY5cHRGb3Y0SDlXMUlwa09IZ1pNMTVqbGVuNTNad01ESkV0TlBMTkc5QWFuem5UOGJUbjUxRVM2YmlLb1l4aE90dXVtUWg5b01JaVhkb0VSbDFmdmY5eXpwWk1XaHlXQzluWXRhMkEycXlFYktJQ2hmU1ZuRit0cFZyMGVqRFZHK3JmcXFOUDB3aHZiYzkzd2NnNDhEeTlSVkc5aUNTM1E5RWt6YjdpYkd2SVQzU09IVXFIUnFvU09MdUdoaFVYa1BpL0JKWjdzM3RpUnR4THdFR2dEMWFmRTQ2VkwweU1XOFkrN2txMEdyVTFGVDlNRzhRUndjZTgzMFBhRkZ2WEQ5d0tFK2Q2VVFYaXB2dUVjOW9UcmMwNHk2dklRN01nY2w0cUFyUmE0RURUVlNZMlRldXE0c3hQdm1LM3kyVGwzdCtaUTZXZ01HZjQ3Qk4xZkNsVVJabVBRWDJqSDE5RmRrZTNrbHBuV3JVYy9POE5Iejgra2RpY240M2EySzBSN3ZpS1RZQ1RaY250UnFxbUJHa2lHSkJFQURyNEp0MlAzd0FBQUNYU1VSQlZDS1M3N3NsdXhMb0pUazM5TnFsVFlnOG9ycFhoUXJZNWtJSlVteE9naGV0L001enJ6Rmd3dVI1YUp3dWY4N1VYZ1IwK2o5bEMrVm83Y3RJMDJvc0xiU2xzOGU0MHhsNU91eWZlU1JHQzBPbWttaTJDdFhWMDQzREdjNzVYVW0ySzRHQjMzU2t1THdMaXI0ZGVtdUhDcFpRMHg4UzFyN1IwTVBtM0Q2L2xhUzdLMll0bHZSMjRTNSsxZ2FLZXlHaVp2Ny9BMlB5YndRaFVrSG9BQUFBQUVsRlRrU3VRbUNDXFxcIik7XFxuICBiYWNrZ3JvdW5kLXNpemU6IDYlO1xcbiAgYW5pbWF0aW9uOiBGaWxtR3JhaW5GaWx0ZXJfZ3JhaW5fXzNwNmRfIDVzIHN0ZXBzKDEwKSBpbmZpbml0ZTsgfVxcblxcbkBrZXlmcmFtZXMgRmlsbUdyYWluRmlsdGVyX2dyYWluX18zcDZkXyB7XFxuICAwJSwgMTAwJSB7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKDAsIDApOyB9XFxuICAxMCUge1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNSUsIC0xMCUpOyB9XFxuICAyMCUge1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtMTUlLCA1JSk7IH1cXG4gIDMwJSB7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKDclLCAtMjUlKTsgfVxcbiAgNDAlIHtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUlLCAyNSUpOyB9XFxuICA1MCUge1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtMTUlLCAxMCUpOyB9XFxuICA2MCUge1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgxNSUsIDAlKTsgfVxcbiAgNzAlIHtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoMCUsIDE1JSk7IH1cXG4gIDgwJSB7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKDMlLCAzNSUpOyB9XFxuICA5MCUge1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtMTAlLCAxMCUpOyB9IH1cXG5cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vLi4vLi4vc3R5bGVzL3ZhcnMuc2Nzc1wiLFwid2VicGFjazovL0ZpbG1HcmFpbkZpbHRlci5tb2R1bGUuc2Nzc1wiLFwid2VicGFjazovLy4uLy4uL3N0eWxlcy9taXhpbnMuc2Nzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTs7Ozs7O2tEQ01rRDtBREdsRCw0QkFBQTtBQVVDLHlCQUFBO0FBU0Qsa0JBQUE7QUFLQSx1QkFBQTtBQU1BLDJCQUFBO0FBSUEsMkJBQUE7QUFNQSwrQkFBQTtBQU1BLG9CQUFBO0FBRUMscUNBQUE7QUV6REQ7Ozs7Ozs7a0REdUJrRDtBQW5CbEQ7Ozs7Ozs7O2tEQTRCa0Q7QUFsQmxELCtCQUFBO0FBRUM7RUFDQyxXQUFXO0VBQ1gsY0FBYztFQUNkLFlBQVk7RUFDWixXQUFXO0VBQ1gsZUFBZTtFQUNmLFVBQVU7RUFDVixXQUFXO0VBQ1gsY0FBYztFQUNkLG9CQUFvQjtFQUNwQixxdjJFQUFxdjJFO0VBQ3J2MkUsbUJBQW1CO0VBQ25CLDZEQUFzQyxFQUFBOztBQUd2QztFQUNDO0lBQ0MsMEJBQTBCLEVBQUE7RUFFM0I7SUFDQywrQkFBK0IsRUFBQTtFQUVoQztJQUNDLDhCQUE4QixFQUFBO0VBRS9CO0lBQ0MsOEJBQThCLEVBQUE7RUFFL0I7SUFDQyw4QkFBOEIsRUFBQTtFQUUvQjtJQUNDLCtCQUErQixFQUFBO0VBRWhDO0lBQ0MsNkJBQTZCLEVBQUE7RUFFOUI7SUFDQyw2QkFBNkIsRUFBQTtFQUU5QjtJQUNDLDZCQUE2QixFQUFBO0VBRTlCO0lBQ0MsK0JBQStCLEVBQUEsRUFBQVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcXHJcXG5WQVJTIEZpbGVcXHJcXG5cXHJcXG5EZXNjcmlwdGlvbjpcXHRTdG9yZSBTQ1NTIHZhcnMgaGVyZVxcclxcblxcclxcblxcclxcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcclxcblxcclxcblxcclxcbi8qKioqKiBDb2xvciBWYXJpYWJsZXMgKioqKiovXFxyXFxuXFx0JGJsYWNrOiBcXHRcXHQjMjEyMTIxO1xcclxcblxcdCR3aGl0ZTogXFx0XFx0I2ZhZmFmYTtcXHJcXG5cXHQkZ3JleV8xOlxcdFxcdCNlY2VjZWM7XFxyXFxuXFx0JGdyZXlfMjpcXHRcXHQjM2UzZTNlO1xcclxcblxcclxcblxcdCRyZWQ6IFxcdFxcdFxcdCNmYjAwMDA7XFxyXFxuXFx0XFxyXFxuXFx0JG5hc2FfZ3JleTpcXHQjRDFEM0Q0O1xcclxcblxcclxcblxcdC8qKioqKiBOYW1lZCBDb2xvcnMgKioqKiovXFxyXFxuXFx0XFx0JHByaW1hcnlfY29sb3I6XFx0XFx0JGJsYWNrO1xcclxcblxcdFxcdCRzZWNvbmRhcnlfY29sb3I6XFx0XFx0JHdoaXRlO1xcclxcblxcclxcblxcdFxcdCRiYWNrZ3JvdW5kX2NvbG9yOlxcdCR3aGl0ZTtcXHJcXG5cXHRcXHQkdGV4dF9jb2xvcjpcXHRcXHRcXHQkYmxhY2s7XFxyXFxuXFx0XFx0JGFjY2VudF9jb2xvcjpcXHRcXHQkZ3JleV8xO1xcclxcblxcclxcblxcclxcbi8qKioqKiBGb250cyAqKioqKi9cXHJcXG5cXHQkZm9udF9ib2R5OlxcdFxcdFxcXCJNeVVuZGVyd29vZFxcXCI7XFxyXFxuXFx0JGZvbnRfZGlzcGxheTpcXHRcXFwiQW5jaWVudE1lZGl1bVxcXCI7XFxyXFxuXFx0JGZvbnRfYWx0OlxcdFxcdFxcdFxcXCJJbXBhY3RMYWJlbFxcXCI7XFxyXFxuXFxyXFxuLyoqKioqIEZvbnQgU2l6ZXMgKioqKiovXFxyXFxuXFx0JGZvbnRfc2l6ZV9oZWFkaW5nOlxcdDY1cHg7XFxyXFxuXFx0JGZvbnRfc2l6ZV9zdWJoZWFkOlxcdDM2cHg7XFxyXFxuXFx0JGZvbnRfc2l6ZV9ib2R5OlxcdFxcdDIwcHg7XFxyXFxuXFx0JGZvbnRfc2l6ZV9kZXRhaWw6XFx0MTZweDtcXHJcXG5cXHJcXG4vKioqKiogTGV0dGVyIFNwYWNpbmcgKioqKiovXFxyXFxuXFx0JGxldHRlclNwYWNpbmdXaWRlOlxcdFxcdDAuMDM1ZW07XFxyXFxuXFx0JGxldHRlclNwYWNpbmdOb3JtYWw6XFx0MC4wMzVlbTtcXHJcXG5cXHJcXG4vKioqKiogQ29udGVudCBXaWR0aHMgKioqKiovXFxyXFxuXFx0JGNvbnRlbnRfd2lkdGhfczogXFx0NjUwcHg7XFxyXFxuXFx0JGNvbnRlbnRfd2lkdGhfbTogXFx0OTIwcHg7XFxyXFxuXFx0JGNvbnRlbnRfd2lkdGhfbDogXFx0MTQ1MHB4O1xcclxcblxcclxcblxcclxcbi8qKioqKiBUcmFuc2l0aW9uIFRpbWluZ3MgKioqKiovXFxyXFxuXFx0JHRyYW5zaXRpb25fZmFzdDpcXHRcXHQwLjFzIGVhc2UtaW4tb3V0O1xcclxcblxcdCR0cmFuc2l0aW9uX21lZGl1bTpcXHQwLjI1cyBlYXNlLWluLW91dDtcXHJcXG5cXHQkdHJhbnNpdGlvbl9zbG93OlxcdFxcdDAuNXMgZWFzZS1pbi1vdXQ7XFxyXFxuXFxyXFxuXFxyXFxuLyoqKioqIFNoYWRvd3MgKioqKiovXFxyXFxuXFxyXFxuXFx0Lyogc291cmNlOiBodHRwczovL2JydW1tLmFmL3NoYWRvd3MgKi9cXHJcXG5cXHQkbmljZV9zaGFkb3c6XFxyXFxuXFx0XFx0MCAyLjhweCAyLjJweCByZ2JhKDAsIDAsIDAsIDAuMDIpLFxcclxcblxcdFxcdDAgNi43cHggNS4zcHggcmdiYSgwLCAwLCAwLCAwLjAyOCksXFxyXFxuXFx0XFx0MCAxMi41cHggMTBweCByZ2JhKDAsIDAsIDAsIDAuMDM1KSxcXHJcXG5cXHRcXHQwIDIyLjNweCAxNy45cHggcmdiYSgwLCAwLCAwLCAwLjA0MiksXFxyXFxuXFx0XFx0MCA0MS44cHggMzMuNHB4IHJnYmEoMCwgMCwgMCwgMC4wNSksXFxyXFxuXFx0XFx0MCAxMDBweCA4MHB4IHJnYmEoMCwgMCwgMCwgMC4wNyk7XFxyXFxuXFxyXFxuXFxyXFxuXFx0JHRleHQtc2hhZG93LXJlZDpcXHJcXG5cXHRcXHQxcHggMXB4ICRyZWQsIFxcclxcblxcdFxcdDJweCAycHggJHJlZCwgXFxyXFxuXFx0XFx0M3B4IDNweCAkcmVkLCBcXHJcXG5cXHRcXHQ0cHggNHB4ICRyZWQsIFxcclxcblxcdFxcdDVweCA1cHggJHJlZDtcXHJcXG5cXHQgIFxcclxcblxcdCR0ZXh0LWdsb3ctcmVkOlxcclxcblxcdFxcdDAgMCAxdncgJHJlZCwgXFxyXFxuXFx0XFx0MCAwIDN2dyAkcmVkLCBcXHJcXG5cXHRcXHQwIDAgMTB2dyAkcmVkLCBcXHJcXG5cXHRcXHQwIDAgMTB2dyAkcmVkLCBcXHJcXG5cXHRcXHQwIDAgLjR2dyAkcmVkLCBcXHJcXG5cXHRcXHQuMjV2dyAuMjV2dyAuMXZ3ICM4MDY5MTQ7XFxyXFxuXCIsXCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcXHJcXG5WQVJTIEZpbGVcXHJcXG5cXHJcXG5EZXNjcmlwdGlvbjpcXHRTdG9yZSBTQ1NTIHZhcnMgaGVyZVxcclxcblxcclxcblxcclxcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qKioqKiBDb2xvciBWYXJpYWJsZXMgKioqKiovXFxuLyoqKioqIE5hbWVkIENvbG9ycyAqKioqKi9cXG4vKioqKiogRm9udHMgKioqKiovXFxuLyoqKioqIEZvbnQgU2l6ZXMgKioqKiovXFxuLyoqKioqIExldHRlciBTcGFjaW5nICoqKioqL1xcbi8qKioqKiBDb250ZW50IFdpZHRocyAqKioqKi9cXG4vKioqKiogVHJhbnNpdGlvbiBUaW1pbmdzICoqKioqL1xcbi8qKioqKiBTaGFkb3dzICoqKioqL1xcbi8qIHNvdXJjZTogaHR0cHM6Ly9icnVtbS5hZi9zaGFkb3dzICovXFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXFxyXFxuTUlYSU5TIEZpbGVcXHJcXG5cXHJcXG5EZXNjcmlwdGlvbjpcXHRTdG9yZSBTQ1NTIG1peGlucyBoZXJlXFxyXFxuXFxyXFxuQ2FsbDogQGluY2x1ZGUgYmFja2dyb3VuZFN0YW5kYXJkO1xcclxcblxcclxcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxcclxcbk5lY3JvIEN1bHQgWmluZSBDb21wb25lbnRcXHJcXG5cXHJcXG5cXHJcXG5Db21wb25lbnQgTmFtZTogXFx0RmlsbUdyYWluRmlsdGVyXFxyXFxuRGVzY3JpcHRpb246XFx0XFx0VkhTIHN0eWxlIGdyYWluIGZpbHRlciB0aGF0IG92ZXJsYXlzIGl0J3MgcGFyZW50IGVsZW1lbnQuXFxyXFxuXFxyXFxuXFxyXFxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyoqKioqIEZJTE0gR1JBSU4gT1ZFUkxBWSAqKioqKi9cXG4uZmlsbUdyYWluRmlsdGVyOmFmdGVyIHtcXG4gIGNvbnRlbnQ6IFxcXCJcXFwiO1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBoZWlnaHQ6IDQwMCU7XFxuICBsZWZ0OiAtMTAwJTtcXG4gIHBvc2l0aW9uOiBmaXhlZDtcXG4gIHRvcDogLTE1MCU7XFxuICB3aWR0aDogNDAwJTtcXG4gIHotaW5kZXg6IDEwMDAwO1xcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxuICBiYWNrZ3JvdW5kOiB1cmwoXFxcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBVjRBQUFGZUJBTUFBQUEvQldvcEFBQUFCR2RCVFVFQUFMR1BDL3hoQlFBQUFBRnpVa2RDQUs3T0hPa0FBQUF3VUV4VVJRY0hCd2tKQ1FvS0NoRVJFU0VoSVJNVEV3a0pDVWRIUndnSUNJMk5qUThQRHowOVBRb0tDaTB0TGVUazVBZ0lDSjdsaFFnQUFBQVFkRkpPVXcwS0VnY1JCZ3NFRUFFT0NSVU5BeG9FUVpqL0FBQWdBRWxFUVZSNDJoUzdjVlJhNTU3dnZRRUZzazE2UUtJWWt2YmdsaEJtUzBZUVpTczBqaUZVSGRSVHJUVTB5VGw1VVZRc05CbklEdXdBRXk2aXgvaWluVGJqc1k3dGVyTTJHd1M2MGNTSWdSU3FKeUZPanErbFkwN3FTVHJhNUtiWGt6Q3BiMTNuWnJybW50V2J0Zkx1K3o5cnNmZXpuOS92K2Y2KzM4OERMR1JpSVRUc2FSdGJ2cjlpWkNLN2k4VnFyQXJTTWRoRnFFRVI1cEo3bCtoQ1JSdzFaRGhmVEJhcG4rcnFISkIwaGJIM0JxT1FFWHgzczQ5bkRxb2dhSUNkOXpnMVZiV252cjNMS2s2VDBhVGVCUTFVNFpyQmRvRmYzeEZuazBOK3VXNFdFd0FNZTZmZVZsUlNxanl6ZnV3cHk2RXNueVRJMnA0Tm5vMWxUNHlWNXpWNUUxcVR3aUVScFhRaWd5VWxQSDJUb2RMMkxjM1pseFRZQi9uMDhrUWVNRDh5dU52WUhiR1ByV29Pdlp1MGpnaktVS2RNdTZjaHdYaGVDRUlNUVhPTy90YTQxbU9GaUFoS2FwQTIxbGEyZGIzczNMN09FcSt4WkJrN25TZ21JQWozRnpZdTZEOVlqdnl6bDhQWVVXbE5rNEsxdi95TE42OWUzWElNbSt3RVB2dXFtd01QNld2ZnVmVjhZZCtuZ3pPSDgrcTJ6M293Yk11ZlhvQ01JRDFZK0ZWdTYzQ3VRakF3eEt6VzIvemhrMExkMXFOTkU2WXFjeTJuZ25QNVd6cnNGNGRrVU94THdOeGVVSEZycjQ2RnJtYzhIMkIwMDdoL0JNdlRrZ1RydXFjUzE0Z1VsMXhRNlY0eWRsTjRVU09xSHdzYzkyTWpRNVlOVXB2RXVHaFUrcUpGRitzMjBUcjJXNjhXa3I2SHh5NnpvU2dENlFnbEwyUkFTSWhHTngzbFN2S2g4ck15akZpNUViSVVMN2Y3OHR0R0N2K3FpYW5CQXFXR2gxY2tVNVpRRTRQcjFnSndOYXA2VGFWNURSeG4yYzBTM1hFYVB1NTFOMkJZN242eTlGMHRrRFF2VmI3V0RiRHRwQmE4NVJNcndkVnRIMFlmVFEzaFNpakdWWVVMdHFKRkorSG5paG1KaERUMkNISExHUTNNanFFK2hsR212ZzlwTnhGbXpneHBzbkNCM0FseURRbkdJMDF6QjZub2gwWkkxamdOV2Nod21TTmM4OFBKQkFHVnphV09ZYjQrSjJRQTY5R0tCcTZ2ZzJUcUZDbWMwQkhsOThNQ2JiaGtJR3pWZ2dQeW1QWERLQ0V1d0ZERmRjRTlBTVFYaE9yb2Exdnh4UnZGb0Q5OVl6RytpS1NBMEQxbzZkT2Y2WDVJQjZlOGNZTTBLekl0d0tmdHlFS3pDL2E0V0pQblY3Z2t6dmdmdDB2Z3VoVE83ZDBPZWZtb1d6Sm1NWDg0N0xFS0wwSzY0aTlzdnZxb2dVd1R6ZWJRb0Vyak41Zi9hTEo5cURrMnlSYWF2NWhDcFJMaG1kWDJkR0JuRXVUNHhMbUsxZDRVOXF5V1JJNlFMWTkzZjdVekZ0VUdYU0tTSFh0UW9GcXhaWmZOMEFsKzVURGZscUNWa05DZlNxQ0l3NDl3UGluamVqYVc2SS9SWXFCZ2JHVm9DNnBIZFpvVlRCVTZlQ0R6MGUzeGcyN1ZiYXk0SzRRTjlCaWdmZklPcWJDWTdPdFpic2JlWS9TVWtvWVJialBhNWFnSCtGdkZqN3BqaFkyRnNlMjRvM254N1pjYTZDZzJJcDJPL0RtcnkxOFFCVUludnZ5VnZmWUFMRGNFencxYW5yc2RMMW5DclpsVlBXYmc0TXphS2tuTG9XMlk3ODczeU1KNWZIa0lWdC9qY1EzUlpnd0ZmZEJCYXdCVFN5M1l5ZExQbkhtUWtmQWplNDlOZ25GekFOamt4SWoxRlJMVGhUSU10NDhtajNaUHR4MDZqOUk4ZEYyb2ZlVk1Lb1B6cit6TzFCUEhmdFFacTFWUm1CM1ZRZ3A0TWVuUVZjZWVDOUtFZnlpWWgreWNrdFUvNkw2MU9GS0VGcjFuU3UrVlpvSnpJMEZGZTBWNUJ5SXpXZjFCYXhkakhDejVDVEErR2VJV1lUS2NyWDByNVo4cFRRREZhTDY3ejNTVDlXa211SjFGSkp2SzRldDlnQmt5YmZNNnVDUkQzdEZWa3M2UUJ1RjhBYTVRRkpPK0RPQjFiZ2xhYmdzV2RjeVFKQzU4OTMzQkpqWnpVS2EzN1pkS2NLVjBuOUszRnZHb0lOaG54T3pqZnQ3TXdUZTkyaVl1SkgyYzhDTUJMSXBxcExmbVlqbE1KZHpkT1BtRm5ZdWxrbmFGMVovd2FRSEFoTTJza0RSZWVzY3FBVmcxMCtkV3NvM1hsazYyMmdmYnQwcFZtbGFGSVlwTGtEa3l1THRzc3Z2d1AvNTh3clZta3Vxd2tHYVkvNmt3SjBQNllZU1ExTGxXVzE2Y0xtU2RiNXEyenM1Sm9Bd3cwUHNKZ3MvaGtCL2k4bmZucXg1QU1DQTRpdlhBczQ0N2JtN0I4OUF2YmhNU3ZqdUluUlF2WUpLNkhEb2psZzFwcStkYnRZUXU4aGtaWUVQTFpuNXVvYlhzZk9Oa0t1eDBhRFNReWIwMDU5Ym9BTkEzYkZkQjA3dnhmQUhxWGFQTk52bkJLR0R4Sk5MbUd6UjlueUp1YnJiaDZIVndZT2IyRnVUdGhrRnRQWURQNklkUm9QYThFRng3Zno1alhNZ2FRNnkzTTRNamRwYmN0WXdSeDNwMEFGeGs3ekMrbTArSHg3aXYxU0FsREFJbWxRMDc2LzJqaTM5d0tGNVBzb2xnU3JoZllYenV1dHVkZjUyWGJtc05VOCs3OUk4aUNKY3lPTlhHbEJRR0lZTkdGenpING5aL3c1c0xpVm9pazBsWmVyWmkxQ29Ob21ZZGNnMHFCU2NHMkdwSUcrWWt5YjY0eFJwUTRnamFWU3dvcy9wcG9PNDYwRlg0TlY0eWZUUEQ3K0FDM0FCbVZzeHRoS1JlTXR5WjZBdjVqUlY5WVVzcVl0OXU3WWZxRlRGQWk3MS9IUFV0V1hVK3pxalRYc0t2MHNYYkR1VWFYRUdpMWN4dCthM3FvQlZES284S0N0UTRzV3JQMjhoN1hBTGVpN1BPNmFCbWplQXc0bW1UNG9aWFEwMmt1Skl2NmtGQzM4aUNmNDZNZXptaVpFVTV0ckRKbGt4ZnVROUJFcFExdFEySmNDUVhLaEVaVTN6QjRVMGJMQURGOUtFVlF2Z2pmM3VzRVRpNXkwSHN3NVJMaEl3UlN0VE9CT1FWWlZmc3lBNlJnbUNzQnd1RkZjaldtdCtIQkFEK0pCUFpoaFVGRHFpemhZVnkyU0dKNmZLaGp5SE5nSnJlVFA4YTJYM3duV0hQbXcrdFVKeStVdkdYd3NmdUxqckVjbnZReFQ2TnNBMnVYN0tLYlFHU2Q1TjhNUitwUG1tNitGQlZYeE1yV1kzV2IvaTBuenVNNzBMNGE4K2llZEpCVjFEUWVLME1hNWZxaGhMbE10cCtOYnNKeUxnMXliM0gralc3MnNLMTdVaEhITTNMZ0t3bTY2V1NmR2ZGSGJSbHdKTlNtL21MWHIwS2VtZ3RQYVd6TkZuTFNuQ2dHbVU2VmFKdnFzK0xyM3hRaWdJQVNFUlVRblhKcWpSR0Q4NThqWTFOVzZIYWQ1YXNYbEJIdHZ4a1JxaXpxNmtBMmVLS01BSFZmYUJnemJRRGpuZk9BYUpIaUtMa1EzV2NFS3ZDY3ExSXF5a2FNcUlTOVgxdEt5cGFrQWpkUUNqeXdTREs3Ukh1VDhSa0VFMHBVckZFbnJrZFFRSHd3VUh6K3Z2V2lJdUJGamY1OG1VQTBhQWZsMGJHMDNOaExVSS9zWTd6U3VDQW5kYWhnWTJmdlRVVEJjanJYTXdITmVkODA1akttNk96d2ljWkd1bHJhUENqVlhNUkdFMUNlbzgwY2pJTzFPMCtkcHhjRDhwN0o2aE5kZUtIMVpkNnhCMDROZUtsNTZ1eXZZSmg3bkZXYnFFSnV2TkUydWlBbmVlV05SQVNQSmQ4RlhIcFFqUnRQKzZ2ZFdobi8wZ0tHRmFoUG0xbHJoMVZ3WisreitaanFCZWMvck9RL08vL1ZuWG9IQzNteVkyVjJiNzY1Y0dwS3FHdENHdURZS1NTMzVlbkU4UkFsZzBoU1Q3S0M0R0EyTzBIOEg1L3dvOER2c2lPQ244NWVSTEN1d3AyM1BXLysxeWcya2Z3cCtpSFpTVFhjODlXd1BuMkRRT1d5NUdzeVgvNFg1VXZ3UkdTMkhQc3pkSXRLY0wyMFhDenBTUnk0UGIzVEgzTnl2dS95K0QzRzRwTzhsNTVjUXlUZ1ZvdjM4VWZhNzRKUVZkVkVyQUo5R1VZcVBEakIxbC9iV0dtNlVSU0ZwTHVxdnpYeTd3YkFuMFVnbmtZeHZ2dlA4M2NFUlJoU3Y3ZlhYM3VTSjU3MFJYQVpLM2Yrb01vRHdISTNGaDVPK256czdWck9pTnlNUUFydW9HWUhFbDZTTlUwcWNvL1RpTHM0UVFKYk9wcXlxTUpYdXZPK1RoWnBIanpENSsrR3NPYmZNaUlSdHo1UWErM0c1QUExU1Z2N1M1VjFVN1NKY2hKM2Y0NWtnblNDSWloT0I3bENZUllmMjFKOEFPYy9VQW1nY0tjSVc1QVFYNjVDdTk5ZU8wbkFxbTJoM1RJa1c4NjR0Vkt2U3JHNUhWaXZBVzQrNUJxLzVLTTlVNHN6VUcreXhxSGVvKzBmZ3VzWUowNW9BUzc5cXZMWGtJNHIzc1ZWRzIrMHpoSmh5Y0JaSUtTQStKdVhSUlNhMkxmY3RQWG8xcXRCb1lzOXh1dzM2OCtvQTljYkJoL09WT3JKWkhkUHdOQjEwaXpDb1RlbjFSNXlRY0VhNEl1eE16aDlxUnM1RVA4eDB5dCtkcXE2Wk42bXhoVGcxQyttMVNBZURyTnRmdGlvYmZ2SmoreDdMNzFlbGgrZ2dqejRsc1dPUmZqcW5hTkR4N1laL2R3bnliVmk0MXp6Qys2cVhZcDhlR2E0WFNVN0pDeTVyNEhDc0VHZVh6T0Q1dXFOQ05rK0I5dWQxVzk1WFR0ODRGSXlFSmNGMy8wSW1tVnFFdzJCaDJ4OU9DeGVTR2pVT3pRNmpYQ0hEUnlva2NEa0V5aUxEZERsWmZXZEZ5Tm9LdVZMNTJ1SkswbXhuNURGWFNRNjhKcXpNRlhrc25xQzBMQmluUzV6NGNwc0paU21iY0tCcGw5WnBJcG84UXZZdE1NMWM5aXIyOTU5NzZpWjRjWkh4UngrMHMvazNoUFk3bTJYUi9Bb0dqemd3eWN3dWo1Y3B0Zmh3SDBxRGdSTmtOTUV4b25Nby95Z2lNQzBuSmZtQjNaZDFJWFV1VC9ZdVViMVFpT0FIWnVSMUExSnhRVVhTL3dYajZNUFdMejJNT0lvd2szV1NFaHRudkZNbWRVcEpPb1BSTjlwVC9RSU9ram9XTWxZcFI0Uk03R0VaUStyRGUrc3lJbm9UeklpN2pUL1VLT2FGMkg4K2h3WDVFNXowUm51ZWVHOEJBTGxZZkMyWjZtc0ZrelVKT0JYYmVLT3NDQ3RvRW9qd005MkMzVTVkRUVwZFZ1YjdZUENHMUFCUksvU0RGYmg2bXlqMWhQaVFGcXVkWmdIYy94TXNZN3RhNkdtc0JTVlBqSkYxV3I4a1VKMC9OOURMZkJtenR2Q2puaHpVa2xFM0ZFUmNhOVFrOE9jVEVldW94RWFVaGVrWUZZOTRlMGdPajZrS2x5V0hOd1hzSUROeUNKODRMUURjV1NyaFdzajl1ajY4TzVGV1ZiSjRadXNncmYya0h4dEtBTTQvUkV6dlRWb1NtbzlIZDNvdWJJVkdGMnBiaXBONmZTZ1JKTE55eVN3YWQ3SW1OU0FMYkJJYW9vVlZMVExFSUF1bGtSYmU4dFNvOGFiMjVJVFQyekdwRTBNL3JtVjFoVjVJY1gxVDNTMVhCYnN3RWZhN1pmR3g3NFFLaDNnNGt2cXZ6RzBKbUd6bGtDM3NBUlc4QUhTRVczcGpoWTFjTjRKU3VNWVk1U0RjdmhDOVVyMEd1clI3R1A2cDRJN2NmUWxmTkN5K252VE4rZnZxa2x6Wi8vUDJIVjQ2MXduanV6aCswTG1Ia3AvZmEwek9pUXc5VnE5VHAyN0h6ck5xdEgyb2dwOUdnVDN5MEZ5QWw0L3h3UVowTzZJWndvV3R3Y2lwSVdBWDhURFdsRHRTRXpsQ1ZFRDgvOTNGbDhiMk1WQlJhYlJLRUJrcFNLTFc4M2pGYnhXRnRSUVZneGgrOWYvS1p6cjBnYU51ZGZMdlZ4SkNRVGFlUFpQTzA5eVEyTHg1YWY1MFI5WmxGQlB4VFdkWDVrNlRNcXk2cEtQeFVhMGNTVlZOZ2g3bVkycURNTG56dGlxYmtWYzliTU1PdGRqRGluYzdReUFMNlI2MHZidnY1Uml5RzdKWllrdDNiTFI5TXZBaVZvNkF1YkNHcDkxQUpDUThtZG5JeVF1RmRPYjM1NkdPanplQzk3b1RDSXlUVGVOeXExckl2NVV6VkRFRDZpa3BCaE5rNVRUTWJjVVk3dm9VT0grWjMyazgxalplZEtQLzBMTmV2Z1B4NXJ5enljVkpVdnJrTjg4b1RiYlZyZ1FqcE40MlMvbC8ydFVMSCtvVFNmNm5iOXV5YTdSV2h3bnBSdVp0ZjMwUWV3NkQzZ0ZWcVhjTDZ6QXREMU92cTBxOXd1aXBkODdZQ0szUGRMYStEK1FRK29pZVdBM2JvaE1yeS9aY2t0TlplMUNSMWVmUnRFcTlrWFZZbjRyZzlqVDhxd0tyallweVZOYno2WXZpeDBRRXkyeEFMdzl6N0VVTGFPbEI0NzFhV0lLaXl5WVdmVjRYYWZibWJWSmhFbHJRVUtyaHpTYlpwaFEzMG4yNHM0T01FRkNRODc4L0NLcXBrZXRNVTFzOFRNUzF6YmNrbG13ZEp0UkhaSWxIbkxRVVlaV041UjRHU3pNbktPekl6VkFud3poOUgvMTBYTkMvcUE1N2tLQUdCVUU2TWhSQUM0NlJNQjlXcnRqandrMy9lcGJ3aC9tQU5JWXJvSjFDQnl3clMxQjVrdmxZK1ZNZHZCVkNsS0ZxNGlIWFNqZ0M4ekdGRi9YbmpocUNMUk94ZkVib3JiTlkyZitEYUd5RDBwLzVMS1g4L3hTVE82T1grb2VhcFF4MUdFSGhEaFJMWGhBYUo4TGRYNzYwT3BZZm44ejZtUkVYeXNFWTFkZ0RQVk0vaFJsYVhsdDJpRG90b1dFQnkrL3cwdGo4ayttMmluOU1xQ0NPNFBtTkE1ME92RlNoaGRubmtoZ0paSWtrM3M0UGhtMnA3Y1cvTFZVejlxS0h6UkI0YlpmYXdxbG1lK0FlQjNGSDdlNXlvakd0UUduOWpwcWN3LzJYcWRuaUYvNjZyTGNRcGNJa1hwenJ4d2ZqbnBhalV3NWc2bmdVVVJCSkZyVUNiZ0RtdG1iOGhKZXEwR2wyS2FEQmxpSkpMYjF5dnVPTXJRclV0V01sSURsVlhoUGNHd3N6Sk9sQ3Vsand2L2RjS0FLUWlkbGpXeFgwT1UzeGpYUUZvd2pLWFhCeXNiTkJLeXQ5MGpLNXFEQVRkc0lGNFJmRFRwVUh5M0RMQnlKWmsxNEJhbUdsU0pXSlBTTGhDSjc2Z1l6aFFCcjJBWUVidUpjS0l4NjdRZHFZUk43OFNZYWVlNE5zczRjZjd1UDJaZ1RlL05RWEJoOWY0THdpOTJrYzAxckZ3S29yMTlDSTBXWFh1cHdSbEVPc2hwSDc3bkxpdlVscFh3enpmN0Ftck90RVBVL1ZocFNXMmFTWFkySzVHY3BUZHd3TWhKUC9TVzFwb0pZcWtzK0tGM3ZMVWFlVWVmOWJYQzdNRDNZa01Ma0RiUUJDOTF4ZFdlODltS08vTDlOMlRlc2FJdVoyWFpCK0oycmtiWDI0bXA4WGlpS2RGSE96RkpuUDBlVWV4dEJWbHl2c3ZTdFYvYWtMN2hKbDRGcWk4S3EzQzZkTHFmbFZJSjExOFllS081UHA0OHZ1UHlnMnYvMUFhRE16OHZDR3Nyd2NZYVRITU1EUmFLb2poejBUZ1M5eWpVbm5WMlpJdkoyZFFWMENGZkZqUWQwWVlBWXcxT21sSWJJeEwrTTZpN25Dak9xODF4NUJseWx2bEhXbzdlVUFVRWJaZHlxbUEzSS9mbHE2RmFkeWdXbjNKakczOGloaXYrL25MVzRxK3oyRFNEMXN4UGs4ajRXMjZTdjRNNTM4RWx2WFNnZXBKK2RtMHpNV1FnUVYwZlFveDZ4b2R3L0lRYjJLL1ljNk9EaVgxNzZyRUtjNFUxc0g3MzdSa3ZheUYvcW5Mb1VCWDIzU1Y1elVEWGdWKzFOSDVQOGlmVHovaEtBTXh4Z1E3dFVyKzVWcHBzOTh4cHZYMEVhd3B0aHdKU2xxT1BLS1VMNTAyT0JvMVByUE5nSGM0TERSTUFBOEZPRldDcC9DMWZFV2J6RjVhaHdTTzJ2NTdKREltY0V3YnRZQ28rTDFTa3NhR1V6bktFQ1ppMmxGSHR3NU9Sa0czZjFNVjZrSFYrSlJGMWZ2bUhTZnJWM0hNc0FTTTVPY2dNZEVqMXFVREJ6c1NDbHFsRFZPam9mYkYxMk9uQTlYS3ptV0NSZWsvT2hpemJaaE1GN2xrVWxQUVdwa2xnS2xGSGNFOHM3bFQreVRZa1lTN2lqZ0x5di8zbktVVXFLczNnSTVEMnI3KzRXNWxabm5Lem01L1BLUUFhYjQ3WHZPTldMTUNZdXByczhhYk5wZ2xvRDVTblUwWWMyUUNkMUhWaDdYeXdwbUhQUGFqZ1VmeW1DTHIwNloyNE5ZQlFiOEcvQUt1Qy9ldGxIWURnM3Y3VFcyT1gwQVFRVnJMV3BzeU1vUUFXb2lUZG9OSTJkQjJ1WkdIZjUrY0V2V1BMVENpU01rMmhyVzJpUERpdmo4YWhCUXIzakVCRmFkNllyOENEMkpvbnhpUysxM3A2bXBrWC9qWEhJYVhMNjJROVBYUDdUUmoweDZaUVlyTWFUQUJuVkpscUlXWnJ5M3JQU0hlMVBjamJmR0thK3BmWG9zWGFtZjkwWmNHUm9VUFcyaytYQTA5MkxUd1lpNFhlU28xZSsrckNMUXlVdGdaM2NoWUZ0My9YMm1yL251bS9XNVkyNWo0NGFQWHp1SzQvek5pTmN6TXZtTUYzSWVtTHV2NHNpNEQ0c3hqMkRDcWFnUW15ZnUwdk8rNjU2VzdwTFFKdHhpWjh1Q0VrMVZFaUo3dThsRDhGWURQd3RiODVFZzJpL0dkY3RsOWF0alZ6NTV4d2l6OXorT2tPWmdkejlOVTJ3RXkvb3lMRDRNeExHSkRXQXhzV2V6b1ZQTTk2bFFxZzlRSzRSNnpYVi9ZcTFtbEtNb3l5eGE1ZmJYRXJOcVVEcWFFaGtWcHJFQ1dWRmhteFdsaEEvQlpUbGFjREoyNUdJeWlzamthRGViSU16SEkxRU9XS1lxYmloaFdQTWpvVWMwUDViU3dNSGRPRmVuazVjK3VOOWpOTDQxSGZVWTRJa1VWTlhKbk9pU0xmVVN0UnRYb2pqZXhnaFFNMlNhQVlrR2Fpdk1yYmRLT2RhckRpRTc4dVB3Nk1nRUU2MlNWb3VVVVVGV1poYzh3aFhCZGR1NVJWc1ZBaWlGODBZY2ZIZEpmTzQ3TkErSWNnNzBuOWpyTEZHT1h2MW8zQTFPRUtXVGpoRWdUd0plbUQxVnVocHNFY3dVdGkrT3R4MzFGTnJvRCsyL0hyRUROYVpGY2diWGhlR2NxTUMxaWY4Si9iOFBZUDd6R1RSemF4dHVXVWthU0w1VGpTNWpzNzUyakZidm8xQTUxNUcxNUxncTlHbzBHM1puQThURUR3L3BtRGJPT2NDQ0NHV1JlbVpZQWszaTBTZXJZWElsVk9Gd1NEWkUrMnZtWHRiK1VDVTdmMDMzRjNiYnRtR2JyMFRoTzBaSjcvMjhrVWhJQmgzb1N6NUFIQnpPenJTZmo4V3EvblNRYWhkUzhyUUorb0w3UjBzZGJxZC9aN1JkaUp5c003cWt4MEpQK3pwQm0zTERTT0MvNlVDN3ZOYUZTSFBaNG43amdXQi9abTEvNnQzZXpOdjNnUEZKbG1RcTFvTmpNd1FVQzZKWUlJWkhtR3RDRUtZd3BCNEhWUVY5c2RvN2VtQ1JJVzhOaUE4VXhLeEhBK1BWNkFUQVQwUGRwU3hTOStxbStidmY4VEFWOE1HTFJIeDcxeTNFM1hTdXBTQUpKVDhqbmRoNzRUVTErdWhpc1ZoajlwTmtlaFhoY0VORmV1Q0JvNEVsOERrTWVRRy9pdTJ6MEhQNEZTNG9yb1Fhd2F3elMrNFdoazJ3NXFqMDMybFB5a1Zlc1VoTkN3dlZLOUJnbWo0VFE4RHZReERYM01aQnUxbDBFd2l5MUNUZVNydVFLdDYxTEtxQ0x1N3FCc2JjeTErc2hyMWtMU2NEMkFuYm9oQUhydHNwQkpSUTFaajJqbWlzeXhTWGRiQmdwdVVlT0tMMTdVamxjbm9qN0tEK2ZuT2dVMEl0aUM4M2VRRGdFRU5YUllRQTRVWUkrRXhMdTkvajRPNVZSRERRWVM0SStEOFlMSzVTY3ZzdWcwV2x5M3BaM2pOUlZzNkRsRDN1UkpnVmJYRHV2SkVyL3IxV09DU3dTSSttekJJNTFEd2o5ZUlDQjd1ek04TFpWOFFGcHFqTlVxK045NjZaQS92cE1ndzFiaEtTYTFnM1VLRWZCMDhyRktPaXdmSXZ5UTlodk1zejN6VXR1OGs4TVdoSmpoaGdObnczYTI1dENXV2FSRkNpOWhrOWZlQ3FnQzQyRnNzYTRRRm1nUG5SZDJSUHZxaXhQUk1hYndPQWdORmxKbWs3WVZRYzd0MnRhSXRpUmVqeTBFNWgvMzJqRHRBaFNPeTJiS1VPVEgyUGhnVy83dmhPKzkrbnZtQkhIaUgxNUlWeE9ybjY1UVh3bUgrZmRYNm5LRE5uTzBvUU9DZEt5TEdoOEV5NmpaUmQvTjVYbmNKS0pJWWsxQU5LRmRlM21wQ3NLSkRQbnd4Mk03cm94T3ZOTXRtcTd4dDBSeTFueUNqQTRkeHN4UXdRYlRUT09FUkpoTE9OVTJ2SFZDanFFOUI4OVRYMlNKT2dHczA4b29BeVVDU3JFdFNwb0tmYzFvSGlUMmVMWVlUOVBZQnl1SnQyK1JEOWUxalpYUzFTSlBqam92MXZhZGo4aUk1b3hMcUxmaWE4STgxaVFhWlZGUGNLTnE3VzhteFE2ZDZ5MEJUUUROaFhUUnRXWXF2dGlmYm9HUitidDJMdi9YbHpEQVFHcGV2V1FzQU40V0dtQlpXSTJqR3RpaVA1QXgyYVRTY3NYNTExUk4vdnBpSTduZm94cFYrZVZNK09tR045ZlJseWhTWUxudTBubTRNNzJqUUxGMmF2UU1JNm9neGp1cERkZWVsUDZUYTFXT281dnBPVVl4OHVacW55YUQxLzBtZXVsZDdkaEJ6eVMyNDRKTy9NdGowcDNXbVFORk96ZVg3MEhCamc3NkxmbWVkWk1zUlBKaVZhS09PUWdIQUxJdkQ5VEc5QXBNdkVpOGZNTlZYdzBpODZ3dFlCSUV5WHNnZnh3V09UbDlaZ0t5VUdYSjVmaXY2NlVTa1o5S0REamFvM2J1OEpYY3hEQ0c3L1FIbjdReXoxL0tRV0VEVFVFZjdoZXBoQmhKaEJsdCsrSEZvejhjdXJJRmhHSUtqRVJxeXFkSzN2dEphLzJaTG00TCsvZTkyNnkrd1dIWXdaa2c0aTVDUS9zd1Z5dGsraDROdGpkTUhZaTRsaVVsNGxUMjRGUGlmV1hkNzFjWktjM29mQ1lMS3c3dmRGT0puVm1EQ0ZXY1Z3VTdQd3BKOUl2Skd1Q3ovaVpSMm5kMmdvbWo0YmxNZXdVY1ZOWmV1Q1U0Wm9PRzAzaU5kaVRZQTBUR2RTaHRVbVFpVTVBb3ZTSElyTzB6WWpkaGFqamxjV1ErR3JnUnNHL2dlOUo0NnFxRGh4MkpzM213REM5bWxUakVDUmxFMWl2WW1rYmJZa1ZFTHZmTWlKRTJEWU1PUzhOaHRxSSt5bVZWQ3RVRURXeTVkZUdTU25PMHVPQzV0WlhJd0xFNWlBeFIwcmRWVWZKVmpzUXE2LzRveCtDOWdUUG1ZZjJWUWgrZ1VFSGhkVGpPc3pGUkkwcHlwWGpFWnJ5d2FoNjBjYnhKZ3dEeVg3TEd1MlM2UXZIK3pUcHpIaVNLOVl4QVVyNFI0eFRQK0p0aXBBQTJrNEEvZlkrbk90d2wySlQ3RVhNOGowYUdkUFJ5MERHWTAvcjhOQjc3RE14MSt4aThtc0hVS0FiNlltYkJHclFjdFlRNWlyaUFPSHlkUFpvWUdDOGlRbitpazBhWmlJQ2tEWUFnaU9ZMUN4N0VTMVpsbGxOMC9oL2JGZmt1RWphRFlYV0xFTmpsZ0pDeFk2clNqd2N3RExzc0NiZlhtNGRQQWY3OW5sdzB4aUhKemw1VTc4cTBqcFdMbkpNcEd0MDQyN1A2N0twVmdoZE45bWVqb2hWNnF4SUtRU3NXNTVzL3haVWFSQlBUR0pVMEZXd2VxZ2ZOa1Z4V3A2SDEwYmFscTFoZERlUE5uKzFnV25lODFma3A3Qk1kaGZnN2svSzZBLytiK2hmbi9pbHJ0dWR6MlVjLzNadWVoeUhSY3VkK3JQdFhOb3VuY0d5bG1zand4RzFRL283RFYwOUFJdjlCSUVKSTh2Y3YyY2thcUJURFp1cjFxaUdOR0VzWkFHZE55NkNHa2NNOFZueFdLb0pnUmZBM25ESUhsYUh5SnFuZXdtemkwbGV3S2hQYlN4cDhrdDJIMmtLdy9rY29SdDVBV2E1NmM3QVRRd214cHlhTEZQNjFFOXhlK3l2cVIrSWQ5dzMrMENiTlRIMXNTVnhCSEZWZlQ3cTd2NW84OGtlNWY2dVBocWt4QlZ1SFZESUNkRW5rUENtcXA3d0xsZlFXQ0pvNDE2bmg2c1RrL25VNE5haGFCb3pha0k2ZlUzYUFQai8xUGY0MHRUc2oyanlOcXNtaVVDZ0E4bVg1TytsaTR3Y2lYUWhkeVJzSnl1S2U1NmcrMTZOamFvU3EvQW1PZ3F1Z2RBRjg0UzVkOUVmbk5pRXFjS3UvcVlMOHJiWHVHQkgwSExnN1VaS3BwcnNyeXV5RUtkM1JGL1h2U1pYYmdLNmViNTZQdDBIU29GNUdScVltMjhMd1ZoVHBTS2RaTHE5ZXFXREtpVEJIQXh1TTQyRU9GQnhSMUNrbW1kcWpuVXdzVDRqdWM0a0ExQ0x3dFhhT1lZRDNZbGxoZ2ROMjdRVVpUMDQ1cUQ5ZEJEeEs2UzMzMHM3ekttRHpTRStHSm5vR1NZTE9yZWx4cVFoSUMwODVYV1c0WjJmSGlJcmNrRmIwOEVxdUp2T1dkV2hSMUFKSjg3LzdpZFJYMHlNdThVYVFEa2hxTzZ1R21ZV1JFTE51L2l0c2FncmR3VkJVOU9yOWNSSkhNT2Z2bXBtVE0wbjY0KysrVG9XcjlVcndEZUxBdjZvR2N4N3JNbFhRWkFmTmMrVjVTZG5Icnh4aVFGRXRDQUk5RDB5NzYzZTlWeTlqakFzSjdZZjNmVlR0ZWR5eWlrTjk1elBHd21HZmpwcFIzUVRVakRiWTFRdmlrSGZHZVBDSGZGc01VUWJBQUlKdDRUUWVKampUbXBmaG84L1BReitqV2lWa2pMTE90QW5ObzIvZXd1SllxcnpiZDF1bXVQYXYxbVhOQzZ4SExzUmV2NjdvMFM2eGgyQTdIeTNtRXNKZi93Rk4rWmo5cmJRNlZSVG4wdXg5aEphL1hlNUlDNEpIeGtTUG9pSVArRVVob29LaVFhenpKamtBUkx0NlowS2xkaTAzM2hHbmo4QWFabEJHSFowSjZhV1FXUmYxODFOTm9YQWYxVjRldXB2bGlsQitubTZNSjFZVnRTZXhkOHVJbU1mdXlzQU1GYTdjN0xsMW5PeHM5d24xU203ZUVvQ01HUjhRSy9PSEhhTUtsRVA0Qmd1TDVnY0V6VysvaUVzeGRvQTVGODRUMVVIN3I3ZVBwZ0NCZEVXMWExSm5HTW9MOEJ4QUNHRFRzSVZpYmJXZEoxZVF5Q25CU0Z5YU5mYkF1Q0pGQWp5RlFDUEpCd0RhWG1GLzVvdFVnQlBidWNuN0l4ZTk5S2JvVWRlaWx0Wnk4TXJ1T3lqS0h0NGFXMXRtNVVLZ2Z3VG5SZmYwb2hCSkhiWTIrdU9Fd3hSdDArb0dmbm5MZVpHTW5GL0Jpd3c1VXk2c1NvZFRhOEl6STVySXdvWkU2M1FORGFlQi9DdnpYMU0yY2RPSXAxZEs3SUlBQUNBQVNVUkJWR3FGdnozRW8wd1pmYUlQMTNpUGtBUE9xWW1JWTRQWXRmRDJWeHR5c0kvMk9xWmxidWFxN1V5a3o0bGlkQWxzV3hQT3FxZ2tGSUxxSlI3Z1J0U2l3QmFYNkExSTlja0NVRyszL2VxQ0tJR0hVL3dqa1N2V3NxcGV1OTZkRmFxYlpiTlJFNmdvOFp0anlxRzFGK2Fndk9SOUsxL2xSK3k3eFoxNzcrNndPWXhPWElBNFhRVzZ2ZjdES1VDclphVDhYZHpxeFBaSGg3TVA3UnpHeklyYUhQVno4d0o2Wk9wNEVsT2dIOTFXc3h5MFV3L2duTWVzQU9MOUxJZFVYTnpFMUtxVG1HTmtCSjVCbXJlOFdNS0owa1hEQ2lKWVZTL1FRa1pWYXkxd3R1U3FBemxTRUg1OWlRT0dteXlZNERYWFVBSGRLTmNyYVlwMmhneEdPMVhad1l2TGlkbisxNHBSNmxBM2hwb3FiaGtKUnVYZnUwc0w4L1g2ZmwzeXg1L2lBdkFMdDV5cENOcVluQUFoeWt2TzFUdTNkVFI5Ym01aFRaeHRkc3FZSEZpZElIU0FKbENOT1NlUnp3clVNMkxCd0ttK1RtVkREdkhhT1h5YmhZTkh1Nklzd2Y1NDlmbFZZdVVqWWJtZFZBVTdzQ09nSDZHSGkrTjVMUm5UTzBJVzBOaldTdWdvTk9UVHBOUXlNd0xsRS93YWdaakE4dHRCUWdUTFQ2d1J3bSt6T3ZwTHZ0WXFabno4ZVFtVDMrSVBNU1AvMTlVMy8yMExFcDM0R0theEc3QUZDVmVJaFd5TjNhc24wTS8rL1FBRW5aMndPRDlyVERuSGZaRFU2NFBPY2p1dzJkeDlmeE0wV3JMc3hKelZybGJKLytHQVlKM0MvQkJMTTZac3RCeG54RlRpVmUyeU1WVGNtZHNKZjBYR1d5VG8vN3lRdFpOb0U1SlJWdTdNZHpCSlFOTkF0b25LU3dNQ3ZEME5xM3J0eFdSMDJaVEQrc0d5S3NxRHlCTDd0SlVSMU5ndEdkelJUN1o3eDJ2cFpFaWthaENVSHI5T3R1NFFtVURsQzl3bktyQksrdVpFbTVjelErVVRuTkIwemRFRGZ6TjFrdCtkZ1FvODh6NVJrcUFTNWtoYk9sN3hXNndMYzVoNFR3Mm9sdlRYUFczWGpnaS8vQy9uRlh2QjB4RE93T2IyRkJIZS9iZzY2cE1Zc0xteDRVUlhYQ1dsNlU3WWtKTlppemxNamtXd3ZxWVRnQStFOFdLQSt4SUlVY2x2dk1PaXlpN0YzWVJvTXhIU0tjaEh5Y1YreHY1NE1UZzY5NDNUNVhVeml2TmdyYVpCRHN2TlhzcjIwc0JtZUdTa2dXd25lWExwUTBIRnFPbmlDRW1tMy9yblNJY01tSG0xZktQdVBobTE1QjJqWWhSMW4ybW05SGdYaGxhVHlIVTNwT1B5YlIweGVldVh0L1dUMS9mZmhLNkxuVGtsNVZSeVJOWVZTVmNlWXA1VlBHREhRV2s0TkcwUFZNSk1BNU16eEVoWTBwUEFpY3VYbEJnZGYwV0grZHU0cnJqdXNoQ0RlaVMzUHZrR1FweFQyQ2wzVXhUYTJEZWUwV1JabFVFWHJGOC8xdk9TcVA2UWpUUGxQbVllenJkckRFV2NQZC9xZ1VKdUpyU0VMVFoxaEJEeHh6eGZwTHY3aGRjcEQ0a3BqVFpkQ0JOTHBNZWxrUXExUm5vME9HVzQzNnJncGZCSWpsVFNHTTlndTg5ckw4VThVeGVGaTgzYWkvRFJUektBS05rRzAybVNielE5SW14TVdoczFZUTRta1IzZDJRYWNUNlBaaG01b3BiQ0IwNGM0TWpyaklxTFVRcm8rTmxHdVFyMXNURFVDTmFpeHplcTFoa2ZZa1dDUGwzc2tBMkJFa3c1RjVEZE9yZU1rNU1kcE1pb2szdkFxa0hUZkltVWpZSUpRRXhRNXpwWVVoVmgyL1JZbFV6UTZVTnRWckRGQXhoWldJUkRabVJsMGFQdVFzWVorZ0pBd3FqdXZvRVJ0MHFwRmFwQVVkZUJoMm90SHExVTZVVnV3WjlEbGZTYlNRdDRRRjloanhCSzJwcm9lWUxMNndIS0RLaE5zbTQzcVRydXlPTDZ3dEgxMHJ5VUJsUHk4WVJhUitwcFJYeXhGTSsxMGEySllHcGtqdklhalNxeEhwN1h0c3lVdnJxOTI0eERKVUJiY0h4TU5ZQlk2Yk5IdzFDZmFaeHA4QTNQbUFvSEkxRjU5QkJUTk5CUW9SWjBCZ2lNNkRiVkZ3WEkxeWJObHRhYVNocHNkTTZ0UUhDdDJWc1dIZDFPQWh5TE1qZzk0RWxVUmhWdlRiT2Yxank0RXJvTlNDUU9pU0x2NmRrd09LbnlBalRGL0ZiTzJNclkxL3ZXbGJ2aEVOL1NGTXVKMlhrNnF0RWxCNkJzMS9hdzAzUys2Tkk1R1l3bVdHL3ZGLzlSRUx2QVR0Q0hCKzIyTjU4My9kWUUzRXVieDBMWENsNlpGQ0lJM3BSREVSMzdOMGpSb0RZK3ZIV3ZUUUdQTjlWVm5rZlBsNDVIM0NGR3kvdHpxekxMUDlBa3VGZUhvWUc2eXUvUlZpclgyVzNmaFMwaFBueWJDUk12TEFveCtWWEQyWFFTNVFQT0pRSXFjMFJVd1Q5dW9DZFNTaWN0SUlJQTllV1BLSldHR3RFSVo3OEIvbmtkOXZUZ2EzMklkdU9VRzRPc2dkMmFYTkVmRVdZN2M0SEYyK1FMdjdUdUNtVld3MlJiR0tKUCsyaXJNRGYzMkhTOERoYXlaL0xicEkzZXREOHl0QUE2R3hOWWJxYkFGSlpPYy9KSXp3aUswQmViMVNlTm9JZHdWQXJSUWJVZkxadjhzaEo5UXYxTnFJQ1JBcVNyTnJjWmRFZlA1MWJsYkp3dkdyazdVdVFCL2xIWXpJK2t5V3hodWVqYU16V1N5K2NlVERrQ0l6WTlpcVNZYWU1aWtkUno0ejZyWVRaYi8zZWJMZnpoWGlrcHZPYUJxK3Z0ZHorbkpoeXFsR0pVL0lJQnNPYkQ3anBReGgzUUEzNHFJSmw4QXFKWVo2Z1U4UlQvZm5KOHIrL2loZW5QTWE1ak50MUxJaEtJRFRLYjFITU0zaXNzWkhUNlc4ZGhHRXROVjhEcU1oVnVXWE9HTW1aOENTVlRTZ3VERTJVa01xcmxLUFMvR2Y0Y0pVK3BTUVVDWkQ1OXBBM0lkSnQ3YS9aS1Iwd0tRTElEYkFFMmk0Z1hHUFVNaEdJVjNjMlpMNHFYMURjSlhqNzQxcVpCSjcvNVppUFdjZlQ3MW52OGJLdEhtN3p5QkZ5Ry9oUE5HMW5FWWd5STNSZTlicVRYNjRkQ1BJeUVxMTBPZ3ZDUmoyM0txcStMcXViTVQwZFlmRDFWT084anlDMmNidHBETHdnU1JoWjIvdkpNenFsNnN3Mm5JejlpbTBaUjlDN2ZtbE1KdXkwYkk1QUI4TFpIN1VSR1NFOWkvMnRKMjd5bzBTdzl2UDh3Si9QWVhPOTFsVTl2MVdPNlgvK3VqNjRBUGlGVlA5dFZpSjA3Q2xiK3k3RGlrMHltaitsditPNE94Wnpxb2dXMmd5cXpOank4WVowWlZudjdwZG5yekExV1E3dDkvOFd2MWRSTEFaQVhwbTJLelRHSzVIc0tiRE5wVXhJejZMYWNpbkQrL0dHRUw0d3BFSU9wMVE0Rys3YU1MRW5vbXZodm01VENSdFQ1TmhRTE5XT0NaTjNDOFY1QVhpMjRZbnpaSnZmZnFua2tsZnA0eXNmdU9USXdWeDVVVzBHUURRazY0WStiUXA3WHUyaVBkLzNmM0ZpQ0tObUpUV0NmS21oK3RhYkNvMS91L3VxbGZXdmp0UHkvM0hxOEhiOUVoYWZPamJySGVkYlo3OEUyYUtHNG92T29nQmxIODlQWXhGOUxGcVpZRkYzdEVYbXNHVmtsQ3dtcXorZXBOZVN6dTd0MXR6cEFqeEVOVkVPMHBXNEFZNnNXanI5T3FkTjhPOVBBcyt2cFBocEgyQXFMWjQ2OHM0MWxOMFc0eG05eXpDQTJGVDJNb05Uc1BucVQ5NG4rcXdYek8yZkVFM3FXTzRqY2NqRlRmVE9TenNqeWFRdEVCd0d5WTZabXF1ZWR2UWk5VjlrRlpMc3diYjZ4cXRoTVlPWUpwSUFyUDBwQUZ6c3Y3VGxMejNsZnpzR3pmU1dsa1o2SXVaOStiWk9RV0pJSDBnaWhtbGNMYSttS3hKeGZiU1JYVWRYc3VaQzc5U3dOUUNMT0ZuaU9RNlBEenlUd2RNa0h2YmJsMEVSWGRFNnJxRlRjOG9Hb2YvYU5MN2p4anlKemQ3MzhiMXJ3UDdxQ3hqNFhTWUdIY1R6TCt2Ly9zamx3bWpkMklabFQzU2VOazVjdUdIMTRZQytaTkEwQW1yVmVybGtNVWpvZ2czVDRwck84UFFIVy85ekt3aERtY0cwMXZ2dnRXeXlER0VReDRYV0psMlpkZjUrWjhRc1JPblh3L1pzSy9wWHlrQ21HQmJIaHJTRWMwdHV1dm5GcDYzajA5cmdCMnIrejczZklOTEsra2pESklHUVhQYllwcjVXYkNyOXY0RUtCSDRuWjZKdENEMTZ0SG1JWVFmUm5wZ1pBMmhueURETmdBNDdsYnZpYUlvWGNnNDlKczZVMCtra041cCtxZkhXcnp6N0ErK01yZTdOSkRnTmFER3FKU1VZYUFJNU55bjdjSUt4VEI0LzNDNGh0enBFVTlxaXk0MkV2d0o1dll6UVUvQ05XMDNTdHFUUVBmc2NmWXlYMDNFMGg2N015WnpHMFhoU2t4OWg3cnhERDFEcVlzT25sQ1JwZjBudlIvbysvQldjZWhiUDUrQllqOTRpNUUxQmVrUkRTQnlXT25aeUdSWWZXTWp0ZWZlZUJMNCt1MUgwZkdXNFJjdWxoQjkvdEUvaGcyZHdJN1FQSERKL2lvTXZLeFZ4bGtNK2w2MzlKazgyWGVEQUJpSlprN24yaGZqblNKSjV5cTZha3RJck4wL2pIK1NVWXhMR2REVWwwUkJ0alZPaGxyNTEwSVRveEJVTWIwL0IzWTdNY3BHem0zSkF1NnYvdHJWUU15LzRhc3FVNWU3Y0hzem5GLzdhU2MwTkE2U1BaUTJXVXlLb1VCdGc3SUs0RHlsbzduNzhWb0hLY01sME5CVkRyNElGV2dmZmdPZExDR1N0clF0YitoVEExNTZYdlNNa2RZM2xJRTBGdHJNa2pzQUZ6MmFaakw4VktpaHVhY1RINDJNZ2YwY0N0K1B2aTc0S3RZTHF1QmsyMEZHMUZMWDA5c3FOaE1UdWRjTDFxQXdTazZqTWdZS3VRa1ZNQ1c2SUpWTVlVTThoTDhLTTJwcXU5U2srdmlmMkJObnd0VHdZOGUzWkdEd2ZGWVhoZzU4QkxRazRVTU5XWG54MlVERGszZ0ZCdk8rNkx5RDVVUDhoM0tnUkt4L2NTNDlLcDk5eUZxU2xjMDUyZy9MS09IWmNYaC91R09zZVZmWFVBNmQvTkVnTDd3bG9GbUhwWlRnc0lGWDRicWJFQkIwczdFZ0wwakxjSGU4NzBaOVkyZXQrODZMOEJRRTQvd2d0SkRMaks0WTF0VkFrRnNrZVNYbE05N1M3eEtLcERKci9JbkdPdytVQkhDOTZjZ3Z4bldocHIwWHFVMk90M0RvOGpkb2FQVktJSHpUMEpoeFFOdzM3WWZyRWRVUXJlR2h1eUd0TWI1cnlvbDVBMEQ3ZldHRXg5ejZjZXdBK1c0TllneU8vMDJmM0haaFFaRmo5QStJeloyRndGbnpOcEFaM2VraHlibmZ4L0VkbXc2elB5TmF2Z016dzdHQVZ3UzJhRVNITk1GSWRhOWE3Sk5CNGxJRXVkSUQ4MFhsMkpLaFpOMHh6eGJCaDlNUWZYQjNTOER4ZXVVaFZ6T2RVV0kyZnNyY2dpQ3BtZWtoOXpzNEQwclZFQ1B2Q2NNQlJtWEtkakgrZkZCd2Jid2RLNzZWSWlFUkEraThzaVhMK0Zvb3JsYjB0SzQvOG0reTRmZXZIdCtoVzhqSWVqOUtBWHlWQXQ4OE91ejZwQnV5Y2F6aWpUUWEzbUNveVJZV3pVc1AvMlpkdmhwMGFKemNyM0paR1U4SlVJQUtaZHNVbVNmM1FlSmpDajFCdW9HZ1hUQU0rYVY2dnpJWk41Wm0waXJJSG1vajZWb0Q1UDlSNHZ2aTgyRUdMbnd0N2JEMWpqb0M2U29wYXpQbm5vVVRva291OTdkUkt5dFdFRDN5QmVUSWRvY0ZHUk1Ma0lhWTh0UmdUdElvV25aVWM5Y082WHdFYlJFcER2bXlwWjliMVJsdmpEcmExb05wSzZUODRnNjNITk96L2pZYWp3QmVha1pFMjFwT1pUNExET2JkM1QvVTRTUUYrUktKMUU3TUJjSFI5SUEyZUhEMThwcWpvM2pXTDFCZXN3TnpFRWFzZUpVU3pNcWtmSkluajdCeDdBamZsazk4LzdCQlNIUkxJOWgrYTVxamZlRUN1ZkdGbDVzUDJMcjhpVDdaNElKOWl1TldFNXBudzZRUDZjSkRMaXBqT1JQR2gzWmQ3VG5yVStIaGU0dU5MQTM0NmZLdUVIQmJoVWxscDVrM3hkUVRCZzRxK3VJbndHS2VRbFRweTNVZ05GSm9kSWN3RnJHRHRHNXhHYUpSS0lHV3lmOGNRYUcyWUZjdy9OSzZkSCtvTXYwNVU4YWxndVdTV1A5a1M5UDUvYTIzTGs4MUQvVXhkRzhQM245dzUzM3dxd2MyMi93TDVTR0lyOS93YW9jM2FtRWljamtlaFptT1pMbkd3K0lxekw4RC83cXFhRm1FT2NQUHdGampWZmNtd3Bnd3grRlJOb1cwWWp3bFBDSGZTQWRaanpCb1lxL1N2eE4yNW5rek9wcHgxcmozb3BiUUdDdkJqb2IzYm15bFFIdVZmMXE3dVF5SnZIdEQ3M1JQY0tnZitWcUdQZG5iK3krK2dUMlQzVVkrZ0ZyY29zckRYUWlIOGRVS3dYNVQ4Z28xR0JVNHJ6bmxWQzVIVkpsRVQ4dmVUbW9DQlBOSjZlcnltM2FEU29Ka1lvNVV0L2RjMWsvYVl6WDRINWcvOXQvNGN5bWZCa2pHeUJQUEJQaDlPV3c0UE1VeWE4WmFvSnB5QXpWQXdQSWpzMTNWQUNIeEQrdzBOLy9yQ0JKZHZrT0JmZE5TT0Y0WEM5b1BQZnF0bE5XaEcxSmVCNEhGV3JvU0dLZzRpVStBbzRrRjRuV3ZHQ3g1OHV6ZERqSzhLajhWUDg5RXBqemVqQ1p4SENzWS9ZNkc2WitWQlBoVWtTNlhGSHZXbGI0a1Q1WjJDNXRDUDlINmQ1bUcwaHE2Z2xSbU9Nai92TG5sNlBkbzg2SmZ1a0tNSGJMVEFaNkpDZmMvUkRmdmU0RncybHVQRVhSbkY3REdjcGZnaG8wa1oxNDU1Q0VJd29EL1VIbk01eWFqNEZrZXNPdjRma3JHblBPNDVadTZlMnBiUW4vNlZIUGIwaUNGMDlCMGFaWHl3Wm1La3oxc3BEbWFnNzdEVFkyVUhMTFBsY09NTlM0MWo1U1p4dVJOTEhlMCtKZ1RPbkRTQjVYUnV2ZEFuci9JektueEExaFFqSHpLL054R3NYUXE2Tis1THBBdzdBSnlsM1o4bWRGT1d5R2NwUUZiOHhBQTZRenAzZFgzSzE3c3ZRVW1XeDJKWUhUM1VsN0I3TS9TYncyZjJ6YlYvNXhRZDkzamVNd3dYYzZaSkIvNlpsMGsrck9RTVV0VjZUejNGMFVxaDNQc3JhUFhibjJNdEZTZGtFU3JxQ00wUzF1YlpXT3NhNWdkSEJQb3oyUDN4TzMrV05BUjErUzhOaVBrMFJnaEJEUHJmU2F5U0ZuV2swTXB1b3VCSGc1OWFQNE9vMHpvbzhXekJHdFBDV1RGRVJPOWVVQmUrWVE3bjZGQVVGN3AyeEZuYWdFVVNwMUR6akdVUHE3Wm0xNlIrWDF0SjdFeWJPcVppdkpPaC9VbjRxU1BvWjRFc1BjMVRpeTBCV1pTQ3NVanhRejZhWll4eUlQbXF0TlQ2dzdGZFNWako2d3dVVDNzV1pXelZJb083b1ZKVzhWQ21WQkxhYlNEYmR6Ky9va2NnRFNBaldTMm5tc3VqdFFXVnFTYmMzcDZsVGFZV3hiU1VTT1ZBdDRmcXdHZjVCM1ZEYkVBOUpVWXp1aDZLaEhhK2VLdGVIdXpPbTJ3T1MzRERUV1FVbFZ5bzIyemJVeSs4dUpQeVg2dE0zcFJhMHh6U1dpa2FyVmsxQitXd0Ryb0lxV1JYcHlDZ1FOWUF2MHV4M0lsWjJaaGhrU1JxNVkrVDNSWGpMWFV5dnpyWHFxSktrSVlMM1VUeS90R1h1QkkxOUsvM3J0RDA4R0NTd2xDYjRIQlVva3NrSDJHYUFDaXFoUWllakVPejg5KzkreVhOelQzaTFNcHcxRnlqbzY2MW4yajNSSTEzS3JQVThMMUUwRXVwSDhjZDd6eWI1UFlNbmZ2VGlSa3NpaGtZSzBUL3BLWi96aDd5c2h2Ly83d1RtRnAyZWhtWTNONmV5c0tqQXlEOHRESkUwT21xNGdUd0xnVlN2VVZKQmJoSHdaZi9XcDA0V1VvK0ZGOUZhLzRhT3ZkWE5lck9McmhwM0pIbkNKdEk0V25MdURncERFWkpkcU5VdFZsOWl5bzdqbi9LdFMyUmtvb253T1pJdVAwVWRWSW1PNzl2S3FISnoxcUxUUzJZYTg2dXFka2t1dTdGRzdIeWtjVG1nMmdabmdyMituNExFM25yZmgzUm1KdWQ3ajBBNUphT3lvU0pyMWlaaEZ4SkcxbjhkaE1Ld2c4ZzRkNE5FekFPN0R6RGhKaGxxVk5PVlJEMmFsWVJ0aGRhcWU0ZFoxTktmQVFabFdLODFFMEQ1RGdiTGlic2M5QUt0aEVSUm42TnZVZlZvR3ppeHJteXNEMVR1N3Rhd2NVWERkbFJXeWZzaXVzcFBFMVp3VkFKVDFvYnRQaG1HRnVSMUNpQmdtMEVyNkpFTUtIc3BKcW5BYUJ1cHRQRlc5SGEvNHk5Lzl2N3ZodDRPMkVBeUF0S1h0dUtLSEhDa3FoRUdjUnJTdXF0TlUxS1JnYTNVa1NlV3hsQnZIOXVMSXZBa2t3cTJMbW5ZNFRqRjRGQ2lJWERnYWZFWVJQRFdpUU41aGN6MW5VK2xmdEt5TGRLamY4TVZFTlVIZG1vTzBEU292MFhvL0F4UEdQVXVxUjBsWkpsUzBNZVlWVzMyU01OWVRxMVlCNHo2ZDVjRkptdkE0RHRDLzZISlN0RnhrSXVwUGIrREI4YjdUbituQW81amloNnNPTHdGcHZ5aHN0RGFGcUJ6VXl0OXgrL0pWK2lhZWJQQThnc3dqSW1OT09MWGQvRXhyYm4xZ3VRNU9UMDI1THVXMFBjbW1rcUM4NEw3Y1M0N0RHbU1mSWFIdjI2bUJScitQbHY0d3dIeHYxd1FCdDI2VDBvUHpURDlKalIramlIMUxkRjhobm9mUE9xSVZMMmFsRVRSSEZSN0VGZG9GSXNxVldmcFJxL1UvQkt4bWFCcXo3ejFhSlZSM0NacG9jb2JycllsbWpwb0lHTEZVUUthRmxiTU5uekJDRDFHaVBEZHp5eTNUU05MRDExWUJSRW5ycEpkWis0NFc1bnN1aEVGR3lsQTd2aGlaQTBYZXhZaUttOFFXTjNoMGlFWnBzcU1lVkFCcm9vMFZFakZLeWowNzgxbUt2VERuby9KdmhlcjcwMDFKZVFKWEU5NkthYzVRK0RyM3ZwQk5UbjhtaUUyMUZRNkdWRjQ4ZWJOcGQ1a3NpR2tNT2lNbWowSU1PZ05ZQ0p1TjduLy9zbmxCd2t4V1FURkJyRnM4M2pqTzNUc01JUmQ5STZMZ0R5SWNqUG9aSGNSZGxWbVVaUGRJMHNzdE1NUkNaZnNLS1JnZkg0TWZ2cGZoWFNjRmcxeEhSQWFBVFhNeENyWHFuS1hEWnFnTFlyaHgvWlFTSkNWRjE2S3dBcVkwaUs0RkYrRWJ3ZzVPZ0Q1czVRTzE2STZLenk3YUhSZ3JUOUNGSVMrQVUrWm9NOFpSWUJxWkh3aW5qTjBIVTlPdVZxWG9HNzJOSUFhN3V3RGk5aFYwcHF3d3BneGwxSmpsZVdYZUsrSEVieWU1SjdXdmVBcTZCam90QzQ2L2dCU1FYNVBKMWkxOHNYWVNnczM4eWU0QjNCcVpjZzNTUVEwRVV3SGZSYU9taVdUWklBWktMLzFnRndWRWJkQkZPbDlTTjRXNVZqR1BLOS80M3RsdHMvYkZVM1BMb1hmZ0dIdjIydGZyTEd2Z0tRK2JQSVhaU0pOejhqY1YvN1kxZGd4YkR5Z1dpZXpCOHpCRDJTSWRtQng2RkFlMUcxK2RlME1sZ2dhY2dwTVp5QUpvU2xGc1JtUlNQc1NPRUlQOHkzM2QyVkVTeEJPNDc0V014T09GRFNXN1ZKUWtqc2FZYzAyTVJkT2NFdUIyTit6UVZ3YkhJOCt0d1psTTd5bGhONFAxWlBoNHM3eFpCVFZ2cWIzRlVUaGx3a29DUGloTStoRVpwSnROZy9rVG5UR3MrNzh1Wi8zL2RJRm00ZlJJL3cvUnpkODJZaDgvbGxOQjFaRXZGdllidVA1NHVyQng0cHRLZURaUlhReXEvU0JDdEhJQ3FsbXRKYlc2MS9oNmNrTGdoUXFBQk5tbGFDR1JOSUlkYVJGaWxhTUMwWjZtOVl5YXhKbDliTVpPbFk3Tk1JT1dFWVhDbUVQQVVBQ3pYSmNUeXpjNEFNNWhwQjBEM2NzSXlwaGZTbGVUYUZCTmtpUGwzKzhuK1QwRmk1dW4yQUhwTFVDVkZaTytsV2hrUG5DQ1l2emVMYVVna29LWjhKNGJkSkdHaDVSZ1IzQ0xhaWxGL3lkYnlLamxWMHBNcUZrUU9GS3FBbUkzN0FJSTZkb2RUSkErYjNYeG84ZGZmdlZEQUdUWURWMFFENWpjVzdwWHMrdmQwbytCYkRpOUpWM21pUE1VczhScDE2NVBTay94eHg4cDdyVlVOKzkwT0U4MlBML1M1b01CNnJZSEJmY2pFN3RmOHJUZnc1WTR4NCtsbHVZL3I2R3h2UUtZTTJvVkFYM09aNko3bWhWbzdBODJ1UzlMU1FRbHkwWU1Mc29hYlUzbXBKYWV6V2lUTFZHUnBxeG1jYWlGSE1XWS8rTnZQN2gwVGpmYy85S0RubXA4TTZNWnBSK3pSYU1WelYzWEdwKy9reGxyUEw2MHM3dngvTm9LZDA4aTZ2ZFFlc2UwVjA1cUZVekZURm1PcTlZdzRpWGhGQlJXVjJNeVB6UFVaUG5OR2d1dG0yZzhEd05VMVJ2eTZwRVFwU0lZS3VLbGYyQlNFSHdHZldoZ0xPSklubXBRNzZpQWo0MUxrQXQ4YzdDZnlFalpkOXFMS2lWUWdKNTl6UXFRSHlxVzJ0U0JVNXBaOW9qZnN6WUNyYW9rQmFvR2xIZ0QvUDBmNkRBSDE5dDhzVUtHODVlMzI3dytKcU4vQ1AvUW10MzMrTnhRdG41b083eTI5SjBYNHF0emU0L3lnU0dMa2Ezd3JkaHVkd2dldGpFOHNoVTBhcUYyNzZ5eDk1OVhEUnFvMXdyeDIyZVAzNzFJK29LNXgyMnppN1dDN1hwdTJOd253bW1kUGZCN0x5eWF6MXRZazJlcXlpaDBiemxvQjAzbllnR3M1SXhtd0xZSzBEZzRpQlBad3dBUWpWVWpxZXA0d3ZER3M5Q29POXVQaXovUndvNDM3TVFvWnlZaTBJaU5LTmJXME4vYk9STjVBdU5xNnFwV0YrNWFybTVWK1Y3NlBwenpaNnRuVEw3ZURsUjVwZ0dvR3RGQUVuQWs2aldFUFI5MWxPVmVVZXFlbGFQUFhDSXJMM0dQYXpFNWRUc3VOT0wxTEliQ3Fqdm5naithMHYveEV1bXIyeXJmTWxQajV0aUw1TXpWQ3VmVThlaVk4UG9iM1F5NWNsbEFFYSt5QngrOHZ5MFZDY3A2M0pBWFhidEQ0R3BycVRKMjhhRnp4d3JGNklOL3ZrbytQNW14T0V1R3BFaUJKMEZaRGQyZkgxOXkyNmpKOFozbElzKzJjNElkUG5LVUxpR3pFaDh5aUdKQmx4OW42Nkx2WDlSUWhOdjFZbEVJRWxjMitKcm5KYlRpZ2ZHS2lGV1hJVXpTazBHQmRzUmlLQUJTNGJDTE5kTnlaNit3bTlvcURUSnAzYzFwTk8vaHFlQk5QTEMzQytxVlZ0NFdDS3Nla1c5MGs5RXdONjdFK1F2cm9ucUxidzFhNWMzK2tkNzg1aTBwVk51SFlQRlQ2MEhxc2lpcThGbnN3ODhGelhyVVBMeTdRTWNMTWNIQXlZWW1FMVZsYTZhZ2F0bTlwQmpISWVXb3ViUW1TMHJyaXQ1dFlMa2tJSlR4Q2d3UVlDN0FPdnozWVVibHdOalg2UkZhaTdQdS91YUZUQWJQUVZiWTBDSTA0SHY4cVVEeG9rbjZYZW5NS2h2WFFnMWRacDQ1djJQdnNaMkNoTjVrQlVRNC91WUxmN0JOVFMwY3BLV2tCdWxyL01DdmJRMzBaSmNKMmpKVytOWWtRYmxTc0Yydk5GRTNMNmI5N1VoLzhPYUFra1k2Mjhod1QwZ2pDZTkvSUdrM1FFMTQzM3BGVVpsYjJtb0VsZmlJMmJ0Ulp2WEtmVWswQk9lN1lBRXNMVDBRSklCMkRVWE9xZDV3ZDNIdzlZYUoxaGEwbEpKZUFCaU8weTVJVEJlT2pmczNVekJvcHE3Q2Q0RXpmM24zQVZ3bjV5elJXVHZ0akJKa1RJaFpGTVY1VU5GeGpkQU95ak1FcnFYNjNOcXE0RmZYSW80NjNueHMwQXJWNi9zOXVYVnE1NnowUTc1RFUwa3JsQlZKVGgrQnVOTFgxbTZvSklJd0c1S2MrRmlrQ3pnTEsxNGk2NUdudnBqdEJUdDBxNlNhd29kTE94QWJpL3Q5QmdFVzY2Mk5WQ3AydGhMZ3lRV1FIdlNBS0tHalMyS3E0YW9WVXorRTQvempiZVh6U3ptemdwQU1xNkFiOTZRTW1OMUZhZ3dydkg3b05kU2RmT3FsMTcxM1d6NXFDeEZsUGFHTU1QZi9VL1QrVVduZCtiNzM1b2RndDBrTEVuOEVNejI0cFlTN0pSTVFaVWRvSElQVStLQk9kWXdoTVRONVVBeFliREtRSGRoQkpseEVheGhpYjV2bFRibTI5MlJ0TmdoMFkxcC9SVEpRUFNuMVpId3NmVXdUbTNURlNVOXpiY0pwWGVQcTVQU1oxWlhqV1htKzgyZld5b3Bad3Y3dXovZnplYjllSHlwZytzdEtEYWJpTFBnZ3ZWYUVFZTZXeE5DL04zYk9pOVZMRDd5TzR0bmlGajJadm1kTzAzT2k0NDZIK0dTRDc2N2FleDNQbDQyQVdCT0cxK3pTWlFSM2ZxMXU3dWxjbGxNaU5ZM0lscEpkSE9ZTFZlR2VzSUovN2IyVjRUNjB5QVlOZmQ4bDdkQmplaVV6WklRbFoyUGFKckZWRnZDenBtelBwdEt6UGVpVVRISkJkemVWZFkyS01IVmpmcU1WOGNXKy8wRGZJUnR4MldKVXducnR4c1ViT2lucWpxTmJQYWdTYy9kdmRkSFVDRlhSN3BSbFRGUFh4eWp4L3UzK1daZmRoVStLVkF0dzYwbkRkMTZlSmJjbFo4RGhxaEVNcCtvRk1LeXJPUUdPeFMvemRkKzByTThkWjh6SDgvQUlzZ3JtRXdIbXhVTFFBUlRJRzYvNGxub2IrUU5RUmQwUEpoOHFXUGkxMmxPTEszdTlLN2lzRTJsRmZJTnRxN0ZKWkhoN3NSb1NwMlZOdGVPLy9kZTJpcTFJVFNuYUhzVSswT3Bsc1dEcnlSWVZVcmNSUDk0NUoxVkVkdzRjZmcrSmVvanZnM0dZMVpZaHZYdWVHeVp3STdQL3VmSGxzWDFXYkt6bHg2dHlUdStFQTQ2MC9IMXJhL3dLeFgzMXBoeEY3dU9ldnpaUys2YnlMbHY2NkRyWjJrZkVvK0dRNGVxVllTcjhaSWg4SkdaTW4yd1R6U3dmUDVkWk1YWlQwS0FiZ2xzeWVUbVAwNlRJaHptS0tGWXFPZktOVGhQbFJhMzBVTS9LVVk0ejR3OHBGYVovOWxJVmJteFRPNktXc213VDFka2hPNnA4MEgxTnZGa09LWmxvcUREYjhtczFjNStMVUJma280d3hsbHE2WS9sMkEyRXZ5OG1RM1p0aXNzaUdoTjJVU0NFakpEMlpCT0VBL2M3V2Uzd0lpalJQZWY1OXhkZ29EMWlqUm1yM2p2Q2VxSDgwVkdjenBHdG16Lzl5Vk9XVDhncXNaVllhbm8yWGtYNDJaRlVOTVFGN0dxeVpBdFJwVTFTWkxwRXZuejNNK1p5ejZBQUFJQUJKUkVGVXdhMW1idFUwdDh1N3F4blhJbmtiVkppWWtYcDUyTndYQXFIZW54OXp0MVQwRG5iUk9vc3ZIVjVsMEFMV0o4OHpNYXVxMmJIQWJ1YUJBZGJGRDBBeHlDYVBiOEN6N0VqdGtTVXkydTZ2T3llU1hGa3RpcWtUYnBad2hDbldmWk16Z3l3UGtoeEFsWkRRQjdqSGVKN3doVjlsTXI0UjdFYWRpVWgvOTh2SkFqNVNIRzNTUUdrazFxZHFqSitHRGpSMkNsbGJ4T1ZNZ0NSUENrRUcvS2pPU0tGVy96VTVXZ1I2TFRjaytTVnFxUmhHQ0JJVzNKaWdaSlVPeGNrZFRmN2puL3o1elFhYlRIYllVZFAybkZIa0NrNzVqUUpOMFVZK0Vzc3h2ci82aHg4SkE0SFBWcjE0ZVhXbE1raE1mc0Y4KzQwcXl4RXVZMHpiY0hYTDhYVUNUSUpvNWd0Yk5tNEU5b0UzcGNvY1ljQTZLV3RIWG1leExoN3lQaXA0WEhFdThlMUg4dVM0VUZuWDA4L0U2cWNqeUNWTkwrU1VYL3hMTjhubjlGUGlMenNWeFFMNG9mbEJQaTI4bVEvclRqRUl0ZGpxajRncG42U0cxNGRnQXlKS1NuS2NKU21nODFnZ0tiUW9YeUEzMnkzNzZhSHhjWTlhU25raG1zRkVYZkFzbnZKSFNhd3cybnVJbVNGYjhYbGhkc0lkbXp2UmlwdmZYT0dVT0s0d2lCN0VqK0t1OVhjclR0Q2crT0hLalR1TnlIM1k4OGszbDhuKzBoZnBIMTZSaDZ0Mmp6SDQ2Ym9Pd2kxdzYyb0pkVG9yMGRBUXR2bnJHY0RZU1hBNFlJUk1PS1Q1YWt3TGxaVitLcFRxaWpLR04xdHZTR1hMRVhwdnp2b0FPVGxRRHBOTThUUThqMWlzSU5Ydm02aHhuZjNpd0g4YkFCMVdvbU5LeWd3MCtTenE1WnJoZS9Sc2NYeWJOZU5kaytxaUVUb3FVNndlN21CRTVKODdyVEp4dktKVVdlUTUrRFh5aFlmUUQ0aHdQeVh1cVdobjdvTWpGaDR4dFc0dm1DMjlTRCtKNVp1Tk5ZU3d5SGkvbmZ0K3ljQlNMVEdUaUVUblVlaVBoTWV0YW9SRFZSTkVuNjc4WGNTMUNPNkJHSzlBT1NxZVhjMDBqVDJsVU9IYnMwbW5vbHgrL0ljWG1HV1VQbFJJTjk4STQ4aytxNjdXVU9WdGllRkMvWWg5LzYwVEpsV3piWDJ0UWYzekU4VDlpdTE1T0FmTlNia0R6NDNTYk0vUG84M1ZVdWgwZi83RlY1ZnBsckRhVXZSK3R0VU1nMDhqZ2lDM3hrekU3MzlxZEZqNzZXL1VDUTg3SlJXNXR1NGdDV3JJYnVoUDkvenRmZEszVkF0VDJ5QWl2UUw2L1ZqYXJkVTFuanNVTEZnTDlVMWNuVHVrRWtGS1JvZC9LbnJ2RnkzMEVpM28rZWdCUUVSWmRraUEwOWVaZDZPaiszQm1XQ0NuMWNoNjNyRkFTQWt6a2gyQXZHY25pUHRYVkMwWjVjcjVSbWM1MDFlNWxRK0t1aXFwcUdxSXVmb1RsdklicXNWd2JGTXBaRW4rMTAzekRWQUlJOWpSdXp3bzdaY3ozR3lrWG03QlFSQ2Z4T0xnNmc5RUVna0F0eWg1OFAwRHk4S1d6RVBNaGo1M2pUSExJUWh2cGZtUnBzWURZbFc0VjU3QlR2eGx4UzNLSjBJcXIwMlMvQURSUjQzQjBmc3A4blI5amNvWDNxUnpQV255OVp2MlVmM2dIdEZDMDhPUTJoLzdLOExBRExsK29henllK0txT2lJTGkyWWFpa21kdko0NHNJK0t3dEJQSUJiNnprOEVIREJZa1hScmtyQmprRm9HNm5od1Y3ZU0zUzFXSllWNktKMTNqaXhPdWlsMHRyVGVHNnlXMXY3MnByS1Bsa2I5cFIvaGhmdGFWdEo4dFVSR3FKRUtpTEVwQnIyZkxuQ1hRMFlpNnBzcDN5RUZIRGoxUWNNQmFWOEMvYTZjNEpGWE1xYXh5cTJjSUlXcXo4VHRQbEx5U1lhTzY3eE1xVzdkQWNVZk5QenpiVm9iRHJaa3dNbEFqUGQ0NW1UUHF1cERhbFBCd2ZBL04vZXdQRFBpK29nMythYWVFc1gzdGpsMFNNaWxkbGY4Zmx0MGNzMExCWndCZmY0K3gydEhPTnduL1NYbmFOMGJnTjRQQ1JGOTdGZDd1Mko3RU4rK1J4L2hBeXZnVXN2T1N1QUxTTFlWR3N6MWhOdGpLWGZEbkZlREFmYlA2eUt3RXlVWDlEVXRVZ2ltRjYvNEErbTErczc1NklPaG1lVXlvbFMzV3JDeWR0Y2F3aVVkSUJBWEhLd09tVjlmYVFwak5RZnYrYUpSZ2hmYXdubHBLem4wMjFqNllCRnhFZ2NwV1JBay9KbElvYVhTK1JkdEJwc2Z0ZnVPcm1qNDg5MjJGYXgzSC9nS0Q0Mjk5cDIzVU5KWnZLQnNkbzJmWDRFbHl0Nkc2aEo0OXdVa2dPS0x1Vkl3Q2M2Z3V5UXR2Wkk0NFAwTnYzbkRuckJxa21xV08ra29JZ1RFbHNFdGNPcEt0QXk0V0FJeXVLSjc2bXNNZFRaYk1ZQndnODRNUWthYTZ0d0pYSng4VEVLZElUZGtYVjJPWXNUdGt4dWhQVGZ4SmtiT05JdHptS0xmUzY3TkVyTTRGdVFEVVl2NjZZMkFTQzdONWFVd081enBSUUdERTVURDdjajlIMENNbFhrR0wzSHFDejhsYnNUY2xqRWxqMkVONTFMNjlYYXlMS2RsMFowZVBCS041Q09IeHNyM0k3KzIxVUE3aHFvczJYNWhJQTRxWW5IeWc0Y3EzU0kxN0hXUXZNWmdpcndIZ3p4THlndTZVNjluWHRtQTd3ZHgvWEhmSnBMSU1aSFJaNFRWTjlqMTRadURDbC9KZVpidU5mWEUyZGlGdzZVZlpES2llWmtVc0ZsS29oUlpjbkMzYkExTUhiS0t3aU00cWxVdGcrd29aTGc2by9UT2tuTVZ3YmpVazMrbWM3eXRLUzhYbExQMHg2dVFpckZybXpCZnZCYmcrYkQ4RitVZEhtSHhQZjBIalRWMmlHcTVPQUJ3N0tkUW5SeWUxYllzZDlDeTJMZjFLZGtaOXhTVzR0empXNHMwZ0hsU0EwU0QxR016VFY1cng3ckd5S3VkMUxOa1g4SlpQaVdJYUtPbjY5dkw3WkZ1bUNIVWxWZzJyMzFia2VwZEhmVEsrYU9pMHpjSHJxVWsrWkJacHk2ZnBQNCs0MVYyUWpzeVNIWkpsZ213TnN4OWdKcitJVFpHVFRqMGZKSm9SeS9jYnhmSUJWZXJNbDRyRUphc1J5ZWZUck5aN2NkdEVpY2R0dFczaDRxY3FLenBtbjRla21ZdllZVHdLeTBpQ1ZwMXpYZzY3dWNTOXAxUjhEYTk4OElXRGlkQkJsOFBKNVJUcDZrQUhnR3FLZTZPcHRyUjIvejhNMmNUYklTR2ZQeks5NjcxaWJzNTF1UzZjdGgrS1FVQ3NFMzVtSGJDblR5Qy91NlFRcHlQMENNcDZuT2NnMzAvUENNV2F3OXBaYWprdTBUK2h3TXNHNHM1L01hR2lPbTE5OVB6b2Z4TE01aXlkeHZXb1oyNzFtZDNTSEN6ZVJaVHJ4eVVMajZCRlAzZHBlTG5GVlUzSDBNdnB3TDlMQWNURkUvS25yRFh0VWtYMHd6Mjh4ZGM0MEdsMG5Qd0d5dm51clBCRFNDU1daQzJZV2JnSmhURkJaN2MwZmJQZi92R3U1bE0rOXVyRlpmOS9EdjNVTmNNa3ZXYUZ3c1JVVDdBR0hVbCtCV0k0Nllzd3BDSEN1ZTg1dzlaUWF2MlQrcU84UGZRSGtsOWRZWTdmblZNSzNzZVR1TnhwTzZISWZXL0R1Z3lXbHFMUE9jODVIUUtFKzVJN1dWVFRoengwK3M2RjZIWjZBZno1K2NYejBrMm9ZNFVJdXJFU3BYOTFzaWxkdEY3ZWxEbktaSHNXK05WYk5DT3dEUnA3cHdTb0N1WkVhTHA1ZlRNa24zYkh6b3ZXUXdxanE3MDdBNHFhSFVtY3g4UUlkb2t3dXJKckZhR05ESVQwZU1UeVpvNHMwNkVNZUxHckNTakZQV3dOa2hBOXlvU1pnSjArSzczUG15ZUxEL0l0ZnNRSkpIV29oeUR2VVo0NXF3dXM0cE9EaUVxWGRJK1RNWVRCSlMyc2tGZVFuTFB6dURZdVhNa000T1NnUzNvdko1dWNyOG1OK1FvM1Z0dmZ2WitCdnZOa2dvcENCRnZ5bTRSY2F5cm4xdGRwRnB2a1pMdG9ycWprV1o3Qm1hY2ZYci9CSGo5QldxVU5RcVZMcEdzTHFBQ3M4em1xUWV5ZmRlQndjMklSQnJla1FaTUY3UWNFY0VMV0JHK2ozdjY5dWxTMU1jVDF4UE1NM1pMOWRwbmIzb25SUjN3VHBYSUlDT0wyb3NJTXJjbWpXUVpMWWQ1QjFaQStIdm5DbCtqbjRXdFFDV0RudXBhb1duV3dYbWZkeTBReGFBamtpQ0FTNllTMzNlWmRxMVc0QlQ2bDBOSTlKNUQwQ0ZvQzVrNS9iNW9Vbkh5aVBoZXZuWm82OStldVhxVkMxNW5Ga01PdVFZT2w2N2VxdGx5OEY0YkdKVEhSdTBmbm5nazBoRjk2RytmWjN3U1lUYUVYYlZ6QkhLWkZQS0JvZW5yejErTW42bnlTVTZEaGc0Vko3V2lDTUJSbGJFTGNkUVYrQ0FFODJ0MVQ2S1piNGV1WkhYUVpDeWxSazYvY2pZOEY3dmlyU2w4bGtvOHVjUVVyZVg5RGlVOVZTL2ZocXJMcjI2czZ2dXZPN1VRbFIzS3BXQXhKd3ZnMFk1cDEzc2pBTGtLRkg1amZqZkRCVWRUQWp2M2VVNkhMMDZiRk1waEZtak9LMG9yUEpzaG1FTmwra1o4cXZCQm1OVmlablhFdlR4LzFKRkptVXhkK2hBdVF5NHBIYkJNdDNwR3ZDbUE4d3ZneVkvNEE5ejVwRnBnSXhPNDFTdUhNaWZvZXNWSmVoUDAvaEtkL1ZTbzV5Tjh6OU1vb3liZGJ3WXZVZDdTV2tqNFlzKysweldjTzJqZEQ5ODRJUGFndzVIbHBITWd4d2FpS0ZzM1NtL055ZmIvbWdoTzE3U2h5bnhwM3BIN25MUGJlVGpmcDBzbzB4dTZ0dkRhSzFkVmZQN1Vzb0N3aFQxL0JRMDlTa3dqSnZBOG9Cd0Fad1hENCs1NmRlMjk2bnEwRUtuQTEvSXYvb05RNjRlVHJmOG5adDRWOWpPSE5QWXlENGFqT0I5MU5vVnhPQ05nUjljTmtJb2t0SHFXUThnQWxlR09UTCtWNjQ1TzZYUStRZjJPa0xSazdrR1pxbUtnTmVrc0lDRHFsaDN5QXNwTWpsSFhTaVhqTHlIbE8yVFo1SHFRb0JDcDk0UzJWak92Q0V4bWtSZmZsQ0xsWXdWSVB2TDhGVGYvZ2s0blBuTkZWbytkV04xK3Rra29LS3hVcDV2M0p6eTQyZVBvclRnWEk5aDZPaTQ5ZFd5M2pUdW0zZi9od0VWMytrYUFEdTE2c0x2SzM5eEx3SXV5UThLQW1aMHUyREppY3gySGJmTytRY1hvTFFobXFZWm13TEFGYTgwM3RNUTJLczZ5WHZ0dE05cGphYytYaGdtTlo0NXNocXB2blJXQkVHeU9SMlI3aTRZQnk1cjMwdEt1K3dhYk4xQ0tpQzZzV3JBZUpacGVoem41OVZSSkZ3cTNWUGlFNk95ZXp5SzNFMHFZb3JPcnkwdUxiUWxoZFBiam16d3F3YW16YnNucGdERnFEeXRMS3c2dTk1eUNsTlpHQlMraENHd0ZodE8zNmV1R3lhbFhEc3ptczU1ZmZFa0VJbkhTZnJyc09tNnhuU2pmRTlVT01nZExINHBVcCs4ME9OYnVFdjF5VHJnckxpa2xBejd1c1JYT3FmR2M4QUd0aFp6bGY3Z1p4VTRRQ2tKNllEYzcyYTRVVUo4L3VZU3A5VVZ0aUpTOUtwbG04OUc2WEJzeWlLV3dBOHVzbmxoSFYrYlVubC8yZmkyWkZmUUpuNU5rMWQ0ZEZVNGt1ZWVTZ2lMRmk5TmI3UUloQ2ZQeThOLzg2MSsvMWtsSGhFaWo2OVZuWjVjZmhpTHAweWFsSm9LLzFzYm5UR2QzLzE3Q2NCM0wrS1d3UlZIVGlkLy9wMEVTZS9QVDN6eWtUYis0YzlpbWU4RjV0enBEd29HSUY4aEVvbnVlWVJaSEI1c0J2d2tWaFd4NnpFbTZncDZjZWpINi9jZEptRFA0VngrUzV4b1R3VElaS21XR2I0Z2M5QzV4QTlCalBNa001WFpGUzZxNEhjVVBSL2NHZHlySEpNRjdhbFFYVnRDM2VhRXJ6R2g0YzNFOFNMaU9uS0w3cE1JbGJUejdWQWtTOTI5UGJUUHJ0d1dVNzYxY1Q4eDJiVjJwWUJFOGp4cCthL3dBT2cwR2JxZlhTb0ptdXB2aCtVY0ZxTmF2U2xRUnBLRW4reHJUNzdNNE05c0gwZUZJVTZpZ1I0UzV1KzlBdTRzMjZOM25SUnN2RHBUMW5wcmN1Nzkra09qWU1ZVFU0dnlTbVlCV3ZIUkRPbHk1eFl6L3c4Y1FtTXZXM3dPNW1aYmRKOWl0WGswd1RNaHZGMFdBeW9KUkhFRnJpUEZTRkJScWh2ZnF4anVtV01jS21PZzZyeVVUVWlOcnQ5cXlCZGFzdDJVN3NUWHd5dGh0RlJnVWJSRVlJZk1DYllOYkNRK0huT0ZnRXhlZUpSN3dTQ1c3TVZ1aU9NMXU2RzBzNWdVZUhOK2trVDVwc1dTZ0NiUjhBY3o1YjFEUjdBa2V5OFlZK0t3SzdjMTc4ejkyU0xuQks2T3hhUEFkVVVsMVkwb243cDRVZzhTbkZDRVR2Y01Jd21rcGgvYy94Ulp1Zyt0R1I3bG5TbDVQcXo4NlFBUFJuY2xET0gyMFNYUHE3RGU0NjRCSmVId1N4VGd6YU9VanYvdHdGMndCOFhCZE5oTHFDSG5XR0k2TUs0Z25nMGp4ZFdiTTJjbHJpVjBPZlpBUjBHbGo5QXBEcFRkS0NZWEhHU3J6MkpKeURqRnZMR3NDdVRTMzlvQmtUWGNLYjRGZTFUMVVRSmJnM0dBSHFUanVtTVh1ZWVTdURyN2x2ZWZMU0ZsMkxseDYwVW5UcGl1U0h1U0xPeEY5UHZGZ2QyNU8xRjY1MWYzK253dVJGNE1kZDVKMEhRaktCRFlSVThnek43aHIzYVRHeVBFcVdJcFZyVUJMYTRraVczUW5wbkl3UEhhcXdDcmJEcXRyLy9JZk9TcjJRY0NGRjNqbVZqVG1oRjMyd3JlRHVJZ1pRQ042bHV0S1lrNXYyWFJ0bUdkelNzRFhROE5OQnJTdUwvVVdkZXdMV0wwTVhDdnQxTTJVLzdDOGRlRGwyK3F2cnM1Y2ttdzV4NVY0MFI5Kzh0ZWZqTnlqbzlpTm9nUG9QRW5wOU5Td1BzN1JDOWIvdWtJMGJPaXFMbjZjTFEvNkVOTlJUcmNnbFVWSFdhQlhxUmNJNjYxSnhXUkJSczJJREpzQ3FSSGMzMWlYNDIvdXZiSkFKUmdIdkNOdXEvZ2hrQnNhS0JhUjN2cWtja0FhZmt3eFdDbkE2ZkwwUnQ0cmx3M1lNWC9zQXNNTTN5dDRzRWlvUjlJMFI3YzRsK1pIMU5uR1htUVpnNDZyUlVLZktDNFplSG5ldW81VDRtWE1nWk5KNVgvL1pmNHNnVS9uVDJ4cTY3NzFaNjNnQmxVZlJ3YlpJcUgzM0UxRFdxaERreTB3aWErdU1QRFQ5Sm16MjgvVXM1ZHVESXYvVklWYVdXT3JEZHRPczc1d1VUbE51NUdSeFZ5eC9EVTFyQTJGeDJybzJjbnk3ekoweTF0eE9xa3g5RVdGSXlFOG5ScXFydUVZOEh1ZDZvYXVjUEFvRkJ0QU12NzVtNStFQmZQOWVORm82L29EWUtuVmpJWjFkNlFZdFBzS0g5ekJreTFoeDlqaEQ5akE3b3BpOEs1RG52L3pJV2hGdXY1bnpPR09FTmZsV1gwOGszOUpKWHZoY25sVmlObEFuLzlpcXRJZEpaeHdBT1pQWEIybytPL2xKVGsxY2xkNHlFNU5uRnRSc0xXeVp2eGhkVU53c1lwMWNGYnZxaWJWTXVDNlBaMkdHWE1pQlNPQ1oxWVRwWTBkSksrbFBEZ2FyWE1jV05KVk9vaUpJS1ZOa0xqbFNzVjVaRnZzcURncnphOTB6NzJ4NTdOZnZSS0lMQmswbmRFNzJTVUlGSXVJbUxMMGZsaUlmOWFtQ2p0OVNKaDB6MnBtT3hCSXNHQXRnWEQrckJzYkhWSkx5UWcyRitwZ29pTUtuYW03ekhyeDNZQkphQkxxTVUya1JzeU1UbjdHTG1hd3hheXA2MTEwSXpGcG11dGZXa05wU3c4R0l0Wm5uS0libVNpRkdoTk1id2RGdjFYb21jdGk0Y21pMG9rNTM2SWF5ZE1VaG4zTktVNUNMVnRxMlphZmFRdmh6S1g5SlZBNnkyRWMxUGREb1RkSHlGL2NBMjRVaUpJdFFicjErZjJTNmtaanlVdlFwVDRCQndhSmhzSHhIRlRycEh1NEIzV0NnQVlqdTdpQWJBd0kyQ3luWDNSc3BUNUhZYTljSmt0K2t5WHo4K1ROMkFmN1MvYXZ3UHQvdkxZbFI3VE5DeHFCR2x4b2FzODJaaVpSc2FCdjlsUXBDSTc2ODhsN0txbEN3a09QVnpWZFBPQTVJc0pqdjg4cmZHdHR0Qmx2S1MvMjNSZUNWMlNaVnZhZi8vVDhBYmVVQWM2WDMwOEl2M2tuck9hc0ZGcnNISkwvc2xzQmZMVlFQQWFCMHFLYUFTUGwxZlFTYU5sQldqS01oOGJ0aWVBczhVUG0rS3QvbHROSndPcHJMOXBFWS8zYU9HZDd2RlFTNUN1akMvZngvZHVlTG5UZHM2YWNmdmpPVTJuU1BldXhaVXk3MEFUV0c5ZldKNnZGM24vN2Z3algyTEFSVS9BTldpTndyN1RqOUNKdmxyQW4rZ2laZEwydEhreE9Wa1g1b1ptM2pyWklpSW1yMzErNVE3OHlRT3RaaWtzNUNNaHczdjYrY0tTbk8yTTkvdjI1aHJZUHp4MGFyMElOOHg0SU5FOXBrenFSZlBWd1FZNVpyRzlLdW85VGxySEdNZE5WUlZsUW5XZ2NhRkFvTWVwUXFYNVdzNUJQWi9DaU5HRTNReVhwc2YyM0REZ1kzaWpDRG11SW1RazdDWVphUDY4bHhTeW0vNDVZcFlmelpZMnhSMFdNbzNVNE9NZEM4MGp5U3RES0lVK2NMTzd6QzVHbVJuVllxVXBtK1Q1VUllRFBpVHYrYURNTkxPbVZjQ1BPcHcrU1pIdVJCamJSWGMzdUxPcFpMOVJUZzFhOUFIQmVEL3NoOVhETHpZU2NteXY4OWZnanIyTW5qUjJ0M2ZFNWpqcUswNmNJb29hOTBsVmZSQkJUOXlLK3oreGxSbUNudkloM1d4TzhrdHQycVVsVkZObmd1Y0lmUU1sejRoRnJwei9hUDdlY2pvTXY2bHBHVmM5bnJyQWJxaVFsenNTOGIzV0pWTUxkQm1LQkk1MWFKM3NSSDIxbUhHZ01CV3VpQXloOTZpQ1o3b0dHcXFPZmZLNHJCZzdSWXRHM21aQXduS084NUlVWUdDMWhRTGFuaCtrbXNaNk82Qm9oKytDNWVwcU1yMnNlSG4veXAvNnJNL212WEUySnpXTE12VDNML09yUmF2Wkg5Y1A2c21SUTZDdHZYeDF4N1hndUxSN052UHhFN0dYck05OHU2YXhlVC9JOVBVOUhzMlpHNG9jNHFxYndocW53SDNUdnVUQVRGZURVY244UG1HVWxpYW8zT200a2FNamwwKzZ6Tms4R3ZDZXhkeEhSTElYTlZOaEhlcEhQQjY1RnZzbnR1bC8xbjJmMS92akV0NUtUK003NWJFR3F3WGt5TjFPa2p5dzZGRWEwTUcvV2tNSWd0UG03eEhCZjlCNkh4amxwcUd6QmR4TVlNVXhVMkExVG1kZ2poUHBaOVFDeVRIY2FlTkhlZWlVeHVVMGJaUldDWENtcFJhTTNzanF0Titrb1lmckRMZHdEZDZIdStDVjFTRUh2QkFoYzY2di9sNk9UZUp6UGl2Z1lnYTlmRHIwS012NlNCNVU5OTB6TVNQbGNBQVFJZ0dVaGdyejR3NHZ5M3N3U2VEY2Y1UWlLNSswM0IvcHVhcEwvdmxMZ09tS1VxSzJpRktkYkdCZFZtMHduMHI1QTNUMmwwUVU5dldRcm9La0dWY1E3VDhJd2dJZnBKRzZ1NlJ0ZXgxdFdXQXBJaFhhVHFpUjRHOWtiSHk3bVRzVEpuZlArbHlHaWk5UkhadjBnSU9abFhJNlZTckg5cDRwblEzSi94YmVrVkpZUUtEVk5MWWNKb2tNcElMUzB5eXd2QTBFNEFxVFJFdnVUdThIL2dvZnV1cGVOeHNWeGJlSUhTL3hDeXo2Q1FJaFNMNy9QSU9aWUt6enI3eStoUkZ0M3VJdEc2cGxvc1N3RVpEcW5rOEpvaDBqQkw0TEFORDNpWHJxOXMzZjk1dnRocTFha0xISHIyd1I2WU5EU05WNDdMZU9BK0pDdW0rWTZoUlhCampxOGFMUGw3czc1V2JtV25EZ25tbHZTQzhNUkJWWFEzS2F6RGpMTDFXL1gyUUtJTnNyS1VhVlBvMWFkdHI1MjRPWmp3NEZYMUc3TDFvSVZLVGwzeUZxUDRWWUlWWHJFbHdQOVNUVlIyQWdLalljaG9kUlkyd3NKaEZweFFtNXFzZ2NheDBJbjlNZEx0UmZsc2ZOTEJCWUJnaFBDQ1ExZGRvZ2d0ZThGVzNvOW4rYk82ZFVqZEVGK040VWlVSjFwQTlnOWt1NGQ5U2VhY2FFb1h6ZkNKNjU3enYrb2h0Ym5GbTJ4M0lJTVFCaVRrcFJGNldIQzBZZjNvR0ZmT1ZQTXVHN0FPNDFmQ1ExVCtvR3NPS0J0M05VSXQ2b0RPejYvd2NLVE9MaDFIVXlPSWhQQmVGRy80K0J0WlI5ZmY1Mi9aMG5xVVQ5b1pFYjlTZHZ6OHNseXplMmpkeWMvcjBaM2xXc21mMm5YbllJOEErTHJHNWtnRmNMWjNvRFZFSURtNG1BY24reUJEL2RNaVdEeWpabW9iQmxCRnprR05ZdHc0YU92QWJLcHQ3RXZvZzBuUCtpdmVqb3FyYkJoVGk1KzJ6Y1lKQXB2RFN4NkhBOThzYlZla1U5Nmo0NE1hbmdsUVFkeHNJTUt0elhKeW50ajU1NkswcU5MMUlwNTBKbm9aUERkUUI4ZmlPS2tRU05Iek9HZVl0a1pDa1pXY3ZOV2taQlBudDU0L3N5WDUwNXg1a2YvNjF4R2R0TTZ1WmRZNklhSUtWL2xadGJBRHFtUStwYW5pMm5vN1dRSEpUczh3L0doOHZKaTkydE1Sd3pYeFZreWNTMVZZcWRXWUgvbEFUTXQwTUNjckhzMXV2TE9UVUp1akowWDZ6a1lnTUdwK3V1NVhoTklaUGlRQU5lWnRZdWJSdi9id2EzcXBQNUFJUExSeHlNUGRVZlJKdHpQU3FHWXV6NWZSQ2lFOVVZUW9pSU5EdXM3VHlWUElyTlFVVytGYlNTbmRPN0RXWVNjS0VUeTNsOENucDNzZkhjTDRoLys5QXIyN3MxMGZqM3kxdFdlUGYrVkpNejA2ejl2SmFIRVBaamhMNDZrTWdIQ1JGUi9LbVFwckV1MnZOTGw3b3hENVFQaHhNQ2QxdWtTcGJzbHd4a2Q2V2FpOHJ6SU5GK3FWSDZ2YVRrbDJYVzNORFBvbEtGcThJQUF2YmhxUFNXSkZLeGgrUXhqL3MwVzFCcStBb3ZId0MyZnVWdnpJR0I1UlB0QjJBYkNyR1V3ZytlemZIc3RCNVVNN00xcFVvdXBDQlFPNWwrYjNTR3F6bkFHNVZMUWZVSjlBdTVsYU9FQkxVUDUraExIUy8rVkRQYkpaSzl0TGtJQStRVCt2a1RWai9Mak9TSy9Ia0p0WW9tdHdLNGZyZnlXYTNwZnFvL3JsaDRyK1IzN0dhSXBXcUJVdGJ4QVZWM005K1J3MnBkODYyeHk4dW5LcG16b3ZReHF5K2pLN1VuUUV0T3RUeDE0eTI1RjlIcktBbUttRGxxN01oT3UvQzVqQUxlUHIxbTV3dGdOSkpDOFdtMlFKM0Q2NWMwRTVnYWtDVnMvb2lCMTY1UExRajg1NFNCdGI0eXh3Y1ErRlcrZXl6YkZpWmJYSER1K21GVkN5TWpKMnhnVTRRMnlYLzhiOGR2L2VHTDZubGo4QWFXNUhrMCtnc1pYRjlXN0NhZlVHUGRxWDNNcTQzN0RRMzFaZ2docVk1UGF5c21LclRzVlp6RWE5TmN5SzJPZ3l5RVQ2LzBnV1FUY0dFaE4zUjNtM25NTkRvOVRpclNJZk1lZFlvdnRXdm1GNStUOWF0TThHWDZpcGJLV3JlRFVRU1RFbWNZY2UxWjRDT3ZLb05PdnRjeXNadklBRC83S1ZSQ29Hdi90ai9FRE4rR2RhNW5wTXFMbHcxSzJSSDdyS3FHY2t3YWhPQlFoZC96NUVkRE1abXZkUnRqVUJ4eEtiQVJkYUpyTmt5Y2Y5NUZNMUZzMnpaK25DWm9PdVd2eHYreDEwdjFwL21uL3JFb1puUmQwQWxNaWR4TkJsZ0NNQVFBSVZWTzB4cjNlbDlIWEMwOXJ3VlVlOUx6Y0hKTWJtOFY1ZmdiSEFlQndrRTNzTitCQ2lQbXBHZ3hBdWJZUmN3L1grVm5RMTNLbVVGckFLOWFhMmhZcHpLM0lsejFWbzBXcCt0UFdQeDFWVjFMeCtueHBOTGs1ckVVaEtMQ0RLNDkxTFNtUFByOS9BVHdWYWhFY09xamYyWDlkbUxmTDRzNW5zSnRMM2g5aVhFM2hxRlhrREJzZkRHNXA1aFl2b3lIYnBmbFRtL0ZRcnhpSm52QlRxS003L3ZGL2dENHhxNmc2T2YvTzUyYm04SE5XUjBwVVJCemsweFlpNlBrK3dnUURmVXFIem9hMnVnQ0tSYjFXTldoNENYZzNGM290aFJXZU9IV1lHZklVWG51SURSeVNFVWVabjc2NlBPV3I3UTNKdFRIMkdPSW5kNUk5eTRFQlVlODJCT2JqTDM5YnJzN003bjlHcUFnRnc3MFV3SENqVXlxWS9lM2UzSTVLTjdJNC9sMkQ2YXE2RE5ISHRXTHg0ZC9jMy9uNlorL0ZOdU03OVE0cjlmd1pFSXZYRWtlS0tLN3dEODhvdHJhWjZJZ1VxVUZlZ05EeEdCY09YK0V2K0NHV0ZaQm1UTEZBQnpWWjNDRC8rL0hlSHk3VkQ0aEducno5T0h3aUZVZ0RtUmF2cGJKZEZpdmJ0S1FhWHIzMS91ZDlJajQybWhWRVF2c1JkQmlyaWdvV3JrZUF6MG55aTYraDhBa3E0ZUFyNmVKUjhYQ29MaWcwcGNTeHkza0VYNUZsTjA2UFhnd3ltQ1UySFlmMlk0WGxwVkx6MmlFRlo4cVhpWERucEtlbHJ1cEcrSjJMY24yMG04Zi9SNllrRTFWbHY1am14SzBoUGo1TkNCUHpZK3Y0Q1piUUt2S1g0TWJSLzNUSUxJV05nTkpwMzM4cnBaLzRZYW5zVGt5TnprNktsRkNuVUwrMkJQa1Fzbis2SHp0Mi8zOXZoM21oY1ppTTN6VzBzRkhqMElXUWVUSEYvbW9TV2QybmhmNFlYRU81SHlRNXBhd1cyVkEvVWRnOG9HOGNlR3M4cUg1ZWNFZksvRERvMkgrTHhjN1BMaC8vVFdVdjZ1bWRuS0RVUTBBNk1JbWE0OXk1dStQLzkwcnJseFJOUW95UFAwV3RkWGFxVlJ1QTRsN29GL2NNcGI5MkVxZTczUk1BeW9nSzdEN3FNN0FNQlBoZElpczIwSEtoV1krR083VUpDZ2xQaW1yTWpoMmlPUjBkbmFRcjVkZXdnOG56enovOFFGdlVxZEZoaEZYSWNvdVZwYnJEYzJCVUJhL2UxRUZuL0pSRmZ5RWlPVjhpeHRNUCtwQUFGYjUyWGtJb21STmo3SnNENVZnYnZWcEJyRVVDeWdpcTFmMnBKeExJSE1nTUVtNm1TRGlmMFlaZFo1OVgvc0FpMUlJQUcxV2V5WVVJZDFNSUtsTEFpVnl3NWRkT1J6NnA3TDFMVGlVM3RXUk43NFE3VDFPd3BXNGNyMEpHdWRKY1cyaEFha1lhUWZkUXkxdTFTQmVkNnlxQ2xYdnBiMmZEWlJnLzkvcjJJM0VvdnhGcXpiVnJZNFdJR0NPRmx0OThDaE9RQ1ozdkh6a25sanhXenZOUDY5a2hEanZ2K3BWSW1qUjNDa2tPMEdNekU3S3d4KzBMZ09kTkZ2MzhsY05uQUFBZ0FFbEVRVlFGTXJuaTkwNXk4VklTQmhrT2xvTmZ3M3Y3TmxDSkJjd0NOcU1NNGo0eEtPVUNtT1NqV0pBQzNtM0FYZlZjQWdHY0JXMFlPemQwTU1UVFd6bUhnbkpCWDU0Zi9DSjJmam52QXlNRHN5Kytlbnk2REw2ZFRIczIxYmVxb3QxS0FqdVEwVWNOL2J4dXpSWitPcFQvQU9FM3RxM1RJYzczRU1tWVRSZWRGWUcreUdPVWFqNmExSml2YnhIVnJVYUloeGE1TGVDem8wUEt1ZzJaQ0krcUVPNG5tZjNQYnBkWDF5bmlnODU2WktvRUw0MEZtU0lhMWlIRzNSZnFoUUdzYWpmT000Q3laYktjQU1ITHZrdEdJTVpTc2xSK1ppS2R2anNGa1JGRVAvaGVYcWVDaEJsOVlJQ2ZZa3V4am1KeVFZcHR3RWdrUnVmbU1NMlU3a3VqWWJiRC9qUUowbXFuUHJpUHorZGYwakRnaEp4c25wRVEwTWhSYVcxdUxqUVZiWEk1L1l0NEFHOGduTkdIclp1ckt3WEUxbGlOR2gydDJLaEx2ZjRaZVVIa3QxendSUkJXdTYvV2hlczhEdCtVZUdWTU9oeU5qSDZ4OVNieTRaYndFbWd1dWdvdnl1VXZWUC9sNTluM2x3TjRPSmdFYkdic1RUS3c5cUI1aS9qaC91WERWV0NYQU15amplSjZkSHlMcmthZXZ6Vldzd2xEZXF6NHlLOVRJRWZka0Z1dDNJQ25PWUQ2Mzlwa2h3NDBMNkJ4enFDN2h1Z1JqY2t5Tk5UdGpqT1NNME5XbGlvdnVIK3h4bmY1UDNOQ21rUTFMVXNQUFRqaFhvRGdzb0tOU2RsSHMrY3k0dE1NWmJGT05OQkFQUGFrZ0gzdzlpZ3F6R1lDT3lQWFBGWFNVTCtSRkFoRGhDMldJdFQ5NTI4cHdRYzl6OEZVNW1tQkFqZzhhSzJJSkl4M0ZTWXEyZCtib1ZpVXIvWFFaUVlwSDI0YUlSd0FhNDhrb2dPVjVsTFJhUG1iMldlcC9wRGhZRnF6dnFtbkFSMGRiM0J3REc2YVJxd29na0IyNHJTdjhnZUw5ZnBXUGJFL09qRm4vendYaHdUVWtMeGVaWm0zVktmWERYK3RkR29iRFk1U05MQUxTUDBpeTNKTCt0c1gzQ1kzQWJFaHFVOGZENmZITEwzZUdRQVlEazlmdTd0UjRDTStpVG5LRkhsWE5OSmRvYmJ5TFFZSVIvdFlQam83RzRYUlhWSjM4NXRMaFMrMmtMUTU3aFUyVXA1cWl5cmZ0MTR0Qm5wT2lHcU9rS3RvQnNGUWduMS9vTjRON2Z6YUN3ay9ISmN6NUZud1hRSlpZcWp0WUN1ek5UZCtrRkdYaHVLamtpRGt1anF6UXN4VnpuRTNmQ3doU2pBOHVYbnpQY3h1ck1jSWJLWWZqWWZxQml4UEJrOHovbEo3N0p1ZWhJRzRIT3NjbzFjcnEwVFdScnBOck5QcFYrbDl0L1BPazlzbE01OXVBaHpIVmJCaDRCelliU1RrTEZzZ0lpWHBHLzY4QVV0UGhicnZtV3ZtNWp1TGp4aVVSQjQ2Ky9uVVpHeE85b1crRFJHRHdLYVk5bjJwTUw1MjlrOXNMcE9ENWN6LzlrYmtEdGZ1cDFZaEh3ZndWMXlWcWw3UTNVWUdlaTVCaXByTitLTDdZblhTU0RXZkgyS2lDMUFmOXdacWpJeGdHa0JXUzhEN3FIZTlOTkJxdjkzSjI2a2x1MTM4T21LTUxWdlprOGRaN0NqOGZFMXNscG1TODJDZWtLazlzbTVRK1NGQm1zZm95cERGbGdNQml0UVhXbnlGRWthTlhDNVJPajkxcmtsbFVSVWthMmpuTU5HTndFblZuU1Z2ZTZRVk1tb2tQV0lqQ0lqTWxTaGRBOEFsZUcwTnBIUC9lRm5FdXdPdFlHMm1QdEV3aUV5SEhEc2xaNWRvY0xzWXVFVFVEbXl1cEVBQ2VyV2VqV2k1TzdMMUVKL1QvQ2dCbXJpQk5WU0grQnJ4WkNsclRrOXJEUlc1M05FSDFwVlhTMFJFVVBiaVhDTlk3a1R3TmtmbUM0aWphZVZCU2l4bE1FVkhubXJwVm5DS0pKcmZ0ZmdueStIN1ZVcTBkbXl3WjFrWThFVnJmQ1loeUQ1akFoVnJFeUU1bEhHbEhiOWswMEhBRGFtUHV1enQyMkVGNS9wQ3kvTktaMGhBUUtELzZqVlNGa2cxbk9hZVI3Z0VTTldnbkZGZ0p2N3I1emFFTzA3Vm5lRFIybkpIbVFIZm1jeFZoOVdaNU53RWs0NmJFeW5nTlNRRTlyS2tEU3lDT1NBNVJtY0RDOCtjcThYbHZIZzBmbU5sSzlBVExyR0owNU1aaVkzVjI1VDJxakc5VXo4UkxLVmxJdUl1MCt4MU1TVVBFRWFmdm1oY0hnRXdzTmU3dWZvc1Y0aG9FZDkyYmVtOU9vb0VIbndraE85ZkVyVjNsdGl3WHIrLzBoYjFRQVd6Q2c3SWt5SEpIY2FMTThoOU41OFhWWTB3azZsYTl6ckJZeW1TbmlNamNqMGplWXloTVBkdlVoZ1pkekc5ei9uTUFGZ3lFZTEyWVRaQmMxWEM2aTNjQnFVbHlnbmJWaE45RFBBenZ4YjEwMVJKZ1YwV25VVExnOVhaZUJTK1MvQlRMSFNya0hwbVZXckRaSTJEdVM4cFIrbDdIcHNjQlpidGVrRktITFpIZFQwaTRZb2NZVGNEU0pYRGJvQ1BvRmtOVEllN2tqUzdTYVEwR3lCZitmZ0pKMWgyd3oxQ1J2TjloL0pQNG1VNFN6VW55OE9lSkR1bUtjend5Y3FUaEx2aXJCanVSditLcEVQdG5aVDQrU3dzRG1FcXVNbFNkSXl2bzBiU3NQRDVSUmVlanhLekZIalNkR3NCRmc5SURqR0lKMFBYOUJYakFFLzM3NnI0blFLeFpOUFcvQzlTOFA0L0JvSTg5YzFaM05jOFMvUkZHL3VRSlZycGUzbjhoNG9Gc0tKTE1PZVZaNEhISnVCL29XM3VvLzF6TjdXRDdROUZURDM0VjA5RGdFenQyQ0Fwc0RxQkJ5ZGZlc29MWUh2UXVvR3NMMUQya0JOeUhkR3oxQm0zamlqWmlOcnlnR2NQZlVTaTd4NmVzcktteWgzM0REM05YQ2M2c05jZXhmQ1daYmo1WDdZNUw2OXRrTU9xaTdqSDVzL3FTVnlXRVZWbmJ6MktnTE9sQmNtYlprcEZRdFR3aHdwZVgyRGwzMUZoNVI3UVBYc2MrWW9FVUdsVFJBZnYzc3AxcXFUWHNBTWZGZ2Rma2xBWk0xcVN3N0dQbi8rWktCcmZJNFVpaCtaYUgwSXlNQWlFVzMzRGcwUm5WMjNMb0RBelhUem8xR1VSV2Z6VFhhWWFKbC9FUnR2Ti9hcDFJM2dvNzRPWXRJSXhzRy9XY2NKYTVHN1M2SFJSakg3L2wvSVRpMXMyQUVLUFN1b05DMnNYMmZNajB3VnlxZkF0NXV5a2RNVW10amdXd3U3a3FteFpDWkdtcm5MaWFFQkJSM1hVNmphWVBFOE9xUUxYbFlyOS9tM1pFczFhK0pOVEtXdnRCM1lMZk5SQ0dnRXdpWFAvb045K1lZdTRXZ2l5R3lYcTZFTklvT20vQTJiV1VMUFNjQ3l2OWZGT3N1b053N2tNSXQyUC9PMUFrVnFQSTRqRTluSUxoYzdyYUYwbHNTa0JWcnpNaU9GQy9mZE9IMkFFaC9NVThrYjlCNGNKM05TMTdTZEduR2J4bjNyWG1ZaVVSQy92UFpDUUcvWHR3MFJ5dzNTMlBxdGZOVEdVczdiQjRtOE91TVduWnBaWHQ1RkR1cGQrMWhmSjhiZGVpajlmWGZhSHRPQ090K1BtVG5ReTJZTmdGZTc0Q0M2cy9GWHpVRTd6V01QVGdiUzhtLzhRYXBnVnJ0dCtCaXRId3NwLyszU25OckYxN3NOZzhsVWswQUloclBwekh4YkswTmIzWTVOU0NQTmNpY1JmdkNNdGlaU0tkbXdQVzNLZDZsdWJWTUNYWkZXanZ5RE5FWjBSVlNxOFBFamlNSHZPWmV4U3VyUUNkOS9mQWp2UHN2ZHpPTHdLdmJYbmtKeWMxK2xXdHNidEJWODNvWk5nWDlMSytkV2JqajdhcTlsWXpkQmFMdXpXaGI5RklJbVNyVVhvYUxxdjRyeTRxU1ExZUZUNWdFN3JtR0ErRDM2L0ZUenFXcHVzZFQ1Z3RDSiswUCtjVllXS0U3MFBKQm9ocWdCUkhlcW1sUnk5U0FrYnpiMW4zRldTMUdDSGo1R1dQNTNVRDluaUFkcW9wMHlNU1RRU3psK1FjWXRON1BpRXNNU2VuTi9WcXZMcG0wNDViOU9zOFdvTGlEbzdSYkpFNkxTT1plVzlmU2VUdG1ySVhYUlRrYnloSFZHY0RwUVpkZnowdlQyWlU1cVM0V21BV2dzNlNPekNOcEl4YVpRRmJub2FjM05tK3lhZktmMk0wL2QvNEdTaFJsaExtcG5OVHk2cW1aLzNhQThQSU90TXFlL1Nwc2hROVRtNGhoWFM1YjNHMVFiOVFMMXY5Yzk0RitvSjJ6amNUYXhqRXZuN3Y0dk9iemZlcGtrNFc1Ny9vZHhOMVI0b2p6eTRxTzZjT3FtVkZiUytLYnBIcE1RN2xyQnpYTHlzSmhXZzljd0c1bDZiMldMM0RiMU82dUhUWDVjSTExM013YXRxc2p2Z0VBYnVaR3JCZXFHdmpuQVNyaXN3eTUyTm9MWE80NXBGM0dDclM1bW9ucHQ0L014Y3c4eTkvWkJmVkwzN3NSbU9XMUl3ZXZxZUo3ZTY3d0ZNdmZCWUJ1aHhYY20zNHREdm41Mnl4NitaVDA5bHZaSDh4R09wRG90MlI0SERGQXowYnlEWjZmME5FQlZ1UHhQVThSeFpLVGtyNUdpbEJjWHZyT3o3K0RPUERYeUc0dGZlRlRlTUVaeWVWaXI3RFZCTXNCYzM1K3VPNll6TThvMUkwY0x1eTdvNmgzSm5VUW9zRGhHbHFRbUNtRmsvcE1JUkZ0eGhxbmZFTFc0T3YvYjk2MXB3L2JLbG81NitoMkxVQm1rcm5wRDlSRHNjcFpVQ1pZZHlRYmJ2SHRKVXl6T1MxdEdsNCtlWEI5VWp4aElGekRDNkpVcUViM3dZUWU2cUo4Z041cGt0WjhLaDl0cVIvdm9Pa0kyaFE4Sk9kSmZJVVphL0JLZ2ZDaVVuWTRvZGgrVmV1T0t5dGxrZEtwdExQT3lOcHFTTVJydXBhSk9ob2xBbEw4SmZDODJ6OWNsNUhhVGRmY1VYVTJ1NXhNbFBidjljZzRkNHNuS1ZIcE9ma2grQ0hBREFaWUpaZTkxOHY0d25QcVdDV2hyY1BoRzRYa29EWUdTK2taaWNwZ3Nvc3B2MHRNY252N2plaFloY3dkNUtnZ2t4NWd1MjhnMXZvZzhoOGZrUDRhM3pFcXhxeVRVUUJsbERjTFpTSWhtMmk4WDlRVFIycHFxOEVMMEcwUUtvSnE1dHRrdW1SSGp2YmNxcm5DNERoVHNvRXNyUFZoU2RxOFQzVjR3aGlUN3RpRGlWamU1c0Fhc3k3ZFNMTjNTVzloSmI3ek5DY1hKQTltTVZHbllYUnlaMjJsSHA4Zk8xaW5peVM3VDZDKzF4R2lvc1lGck1IbHNwQ2d0MWRlcUxjZ1hBUFJkV2Q0K2ZRK2UraWVaNmI5cGYxand4QVQyRERFQzgzM3hpR2lLc2hmOWp6VFhnRjJzRGlibk1Pdk81VlN5eWxSUHJLYjE1blI4c3dudFhMVVRQc3NIZExTTHVaTVZOdm5DaHlLRUpiZEluY3o0OHE4OUhTdG91cGZSd2lYV1hIajMzUXU4MUh4MSs2ZSsya1Vua3pCMmFKU0JjN2R5ekszVURJdGR2VU5CUkZpbDdwUkZ2WGRYeGtXTmVYd1ZGcjA3UTBNZWtTRVB6cm5PbUtTaGFBeGtVc2tBM1lWMmRoWXplZ3dYMDRpY3IzV1hYancycEl0RjR6T21vNS9NR1BVRHYzM1I4VTF0TWNWcHZQMVIxaTQyeVVDcnMvR0pLZDN1V244U1ZjeXRZa0hrcHArTHMyMkJuTCtYRFgvMkZEaEVLWmlhcGlZT0lFNlJkVklGem91MUZwWXFXVHAxU3lsbjVsMzUvMDg2eG9nOHowd1g4Tk9ZZ1I1ZEtCa3hBS2NPOEtPZkRUVU5ISmpBN2dWWUQwOGtNYUJQN29ZL3BqNnIwYkV0aVU1dFhvMkRaa3ZzYndGOURVNWxacFZ4THgvWXNoVXU3NDNsQWFrb2NQaHVsWHFBWTJCM3J0ZmdwTjJlOE1FRXpsRjJ4eDlFKzE3QjU3YWNVUkJzNXpSdkdld0lsRHQrM042YWlheVRDYmVPazEyNnNGSTFsdDljNXhreHZoalhIN2Y5V2ZQOWRpWXRRMEpHbTJuZTV1MUFBS3ZOenNCWlZhdVNvRVN3TjZjYWNvS296R1VzNkhsMWJkcDB6UldzY2NaZ1dKM3NhWFlEeG5RTktna1dDT2RJckZzQW1Yczl1NGx2ZGlvMzc1T0lGMTdzeWlUTWdHb2kxb1VWZ24rVEczclBsdjJNRU9wbFNxcGxDaG9sd29jUUk1QzllR0ZXNFZHdEpmbC9KMlIvamlYYnE4M04vd2dZU2szdmJiSCt1K2prSFRJdVdua3I0Nm9PTU12Wm94MCt5Wk9GRWFBeVd2SnR0OWpqTU8zNnFmYi95SDRsN2xPMzY1R2tSTmpid1g4REJTR0pYY3p0V21IUjRsNVRsb0I4dkZpN0RCQys1NFJ0RzVjMVdBOVM3TDZjNnRmV3hubVJMMm1lVmFvdUdDZlFaZGVxUXF2c0FXbjUyUlR6M1FpbElhRXNJQWxwUC9EVk1qdmxvbWRTYUxWQ1VBSzRlVUdJVWg0NG1uelFTNnJ4MkhpdC90cGhkZVM1Um9QYnlhK2MwOTJkV0ZoN3dJeVk1a0N5eCtrSlV1T3FubGk5RlJqNFgxOWYwb0MvalZscUhLWlNVVm8vdWVhWmN1Nms0ZEhBKy9Kakd6UzczVjZYTDAwQUNwUE1TS21zOWxBL1lzTm0rdUd4N1BzdytDZEZoaCtZUTBhTG5EdHdNcHIvSGVjQTIwa2xpUXJnZkdTWVpNeGtFOVBCOWFFZWpndmluLzNmZTlpSTBJQUY5cnJMNlJacHdiWjFISTdkSzY5eVI1aU92dUh2dlYxVmNWV2lpWmpNd3h0T29LOWpUL0lpR2hxVWVaZHlCME0vZk9MLzgwaTBycW1WL0tzUXJjWmpyaEdQcVFNeUp2emJtaTBRSC8vZmZUcDhHK0VyOWVzNGxOME11dGhSQ3dreGZESWh5TmY3Vmo5cGtnYVcxVlIzeS9GQUgyd0pCNEd4emVqRS9Od2NMRmhUSjZ1YTI3R3Z2eDRJNWRXU2lNQkNseEx0ZnV2aDF2ZEhIM2ZqNFdiemVHQjk5amY1aEh6Q1FKaU9tY1VMQkV4VnlQWGEyamp2ZmhTTGV4Unl6OVV2Z1ZCd3A5dVhaelhRKzhQc1dCZU5lT05FUmRiM3FyNGQ5aCtSYXhPdHhha1hPSmtkZWRmTVBFeHRMVmxtbG0rRW85bHhWUzg2LzRua1NWcFNkSnNUYXJCU0NySGtQajErb2QyWVhkK3l0R203Vmdvcnh4MDlpVFJCTFdaYm1XVDJGTVZ0YzE2cmMvU3FJODdLT05YUXNubXZzWkQrOGI2TVpPNUxVMjlQMDdsd2ZFdCtIeDZNUGZNMmxsVUhaVjh6VzYwR3o4SXZmQ1FSQ1VKdXdvMFlCWFRDVjJWOXg0RE9WbWJmSzRqSGdhSTBjTklDeTRuaUFZYmxDU2IyUjRkZ3hIZGhnSTBjUVdNYVRXQWNIaHNEUWROc2tOTjlOTVlvZmJPUGdRUk5qVUw2NVZlSFgwS2pCOFVCd2dwRzJyaGQrU29IdEQvdmtvMHVUelVKb0FwaFhCN3NzZlJjL2dWcVdpSkkzUmM1dTk0TW84K0s1UTJPY2U4bWNmUExpWCtOUlpWU0pjNnM0NFhGclhaWHZiK2VCN2xLZnFsKy9MTForL2xoSis1YU9qdmdxTmdpd2lUZXovN1BTRDUwcU1vdXhXWkRsQVBxbkN5MUxXblBFWi9uSHFncXhlZWdHWGU1cFk1WDZVUXJJY0ZDK1ZVVElNL2p3YWNCd0lvM1B1VjBqNllnR1FRSUZybzdnR2lESDE1QkxlTE5kZDM0SnFUbUFKdTN4T1RSQVFHam01Wng3T0xzVU9rM2MySWNIWUxDOHNDTk4rUy9PelJZUjJIdVc5SGNyNk5oSk95eldrcU9DaWczUVg0VEtpYjVHRHlYV3UwcWwvU0ZnSlZFSjVybFRuZ0dwWXYrbm9Dd0xiNm1CWi8xcTFTSThVUWhlamlsTG1rZ3lIVWdyaWpIZEFOdk5BSGU0dmRQYXZ6MkF3UHJSOEJTMnhsQ2MwQ0lsS3RNVVVGU0JWbVJXM0Ezdkxod3FESWpOVmhEa3RKSzZyMk9wQUpSMElpVUxPb3NiWXBtdjNiMGlYZ1c5VWJEVGtLRHFkYWRVM1dWR1pUZGJ2dmRSL3cxeHdZSnNvdDJNRGFCTk5VeTZZU0NLRFFRbXpqV1ppQjJ5bjR0VUNKblBkVnQrSUtPRVF3bXV5MEtwUEtBdldwaDljSTFRenJUNmhvUWhGejV2TkgzdzRVdDhsSWJ5WU1JdkFHMWoxdFpVOEU1WVZ5aXloZ3ZEQStIVUlDK3E4TEY0dThkR1Vhc09XSGFwS0VOT1I0VWNuWTdrVHk3T3JQaWd1clpBR1doRGNPMlhQRGtvR1FURGgzL3NzZ256V0ZPRXNEN3dwM01NbFNWNEIwMVZ6a1FRR1lmVUh0K1ZCYUJzMm5DdUtheUd1RWYwM0YvZDJtQUFwa2VLVzZXRk4rWE41NURLRFlmNGJ1bWw4VGxhMm5nNVkzblkyejh5aHlBaVBoOVRHMzFEN3IwdjNVeXE1YWpmMWU1REpLbkdFMzVsUzFnSVR1Nml0c3IzUmRlaXZhZ0RiTXV4MkpGd2NOM2ovcEladUQvVElDZk44eEhVZGQ3eXljODBDTjFDWmE2NStpak9KWEpRbG10ajhRRlZXVU84OVA5dE9sanVsczluNnV4Z2FZN1BjcU9pVjRxWmp3MHh2cXRrVXl0NFJvZjF1OXBpWjhHUVRiUkw1RjRDdVhjQ2ZrOXM2SXVsU0VXdjlrTWNadUZnN3ZuZDM1blJrTkwwQ05iNkNyVDFoSlk3ci9ybWt5ODhicWRvZFhFQVBPU0lia1JUNzF5a0Zhc3JORXQ4NGREdzNhbE92VStrMWx1enZ3Nys3bmJHSGdscGFCMUFXc2dIcXhOZDlUdCtna1J2M2dRZndNaGpSZmxsTDJnR2xSOTcyWHNrZG9XQkhiaVpVdTRlaUNDaWgvTmFsQkpoTTdIcFlwZWNlUWdSSnFoQXR5cTdPcUdwaVVRcExLSkxHdlA3NjQwdFN6VjhoOUFRamRTM1I4d3Rnd1IxdnlOMUtjY1U3Vm90SjVRcVNJdTBVaExYdkdITmZPM09FcUVTU2xleEtvbEtOa1RKWGhOamVKT2xOTzVkNEVBMFVPTTVSYjBjS0Y3QXU1OERZeXdiMkxVamttZk14c0NkYllBY0FsT3crSjE5SnRWczJiUWdxb1RTa0JHVVRONEI0TVpZZjB6cDFwTUgraWNydE42V1cwOFN4Z2QxTmU5WjJxUnhXWGw3VkduZ1dWZHY4ZUtaaURUMWxKMjgvcHNsTmJDMU02RFk1WFRGdi94b1J6QXQwdSt2NWRtR05rUlYyT3Fublc2Z21FWjFkTWpnT2IvVUJNVFNZRFdOdEttR2lsMkpuT0Y5L0RlWTI0VU1BUnk0ZWxwVXFBczdlbCs1b0VDblNzWVBwTUdYcU9zdHNNejRTdmJsRFYxTEJ0UVQwbXRLbmZaYXF5R244RTNZWDdTWFFlUzVwOUpPZ1FlenZhd1dlZXpENjBZSUFoM3BodStQUFgxU1FxdGtvdXNLc013MU92RFJZNVZmdFkxTzdWTUlQejJDNkhabTJhaEo2ZG8vNFl6c3V5T1ZsdXlxbnhTL0ZVeW5QVzdMMmQzVkRiekxGWEp2MmNkUHZ3NkYvdW5IcFlkUnQyaS9vckpVRDdZRmYzQVArOE5UZ2hCS2R6VmlSS0gybGtxZ21WSi9Qbk9YYW1SNGZyV2t3OUs0YjBrdFZtWkFOdTR3MHppTW5WMG13RXJsajM4R0t4OHFybnJVTWdneEI1cXNpZlJKaDV0NXE5L0IvR2F5WEZqeTdvZzF2R2ZsTnhkVm5JZytETnlyd05SZHFVeHhIMmRNNmtid1IyYTJudGNFMW9RVFJMWVRRTEpvR2xYRzZZSW9JZWZrNVhDT2tuK1FXNmljNVhHZGNXbmtycFJxaE81cW5CVTdQRDNML0JEYytBdHQ0alFqUFUrTE8wYVRKNEE4bTJFMGFkTDZxTkxxMVE1OThzVUNwc3hadCsySmg2bm9YN1pQZ1NCRHlmdWZ1a1dmaUNhM09lVTJxS0NqTnd1dE52eVYxT3FiUE1tRnRaRkk4b0NGdWpTRkRYQm5mdEphcXZZR0M0Z2JJclBMemdJbWNqcitJcERvbG42cEJDRElrdW5nUTNKWXBKbUt1aEdMemV2NDhnakFwM0dpSjNESXJxUzRPNHd2QXRRcVlKaVpzSW0yOGw5c1UwMjRXLzVvcy96TDM0TWsyUGlSOVMwUjJyWDZ3UEU5TEtwNXVHZUUrVlpRYzNadmV6ZGZ0MnhjMzR3eTNDYWs3Y1hJazlpRm14ZHVON1I1N1I4Tk5KeExrTDNZSU5FbWhqbjFrTmF0Rlozd1FwZ2pvZ2tUSnR2YkJLWUdlM09wcURHWlUvRzVCR0VmUG1XL3BsM0d3TFZNbHZFU1NSdWdxeEdtU05jK3pLQzhqdEZ5aDlqVVc0NVR6MFdwaWpFdEVGUTQwY0NUZmRQdFB1bkFUOGZWcmYwNUFLcFA4WjhERTEwSTIvQ3E0Q2psWDYwVXAybUQxZWQvL1Vlc05LYk9jd2llSEtKNVNhZjJ2Z2ZNdlpqTitKN1BxQjIvQkc0eHg2STlFUFE0SEJySVJPUW05K2I0cFN3VkZEOU4rNVhXSXNObE1UR0J0ejdTV2I2ZkEwbDYxa0JpVm1PTWgwRnRDM203VUZubENYWGxqV0VVNW9jZHBTdlVQVXFrT3lyRzRMeGd4a2dVT0xQcmdzbW5SYmJsblZhU1BSRnNLZDhjd2lFaEF2QnZkcjFndHRvYkhvanE2NXl5RDhkbUZRUkRFMkhrUjFHQ1NXZ0RadGp2T25iZkhsWjNDd1AreUgybzV5S2U3azJxdlZzZnIvakVkNGtvSWV4WGdrV0paREFOUXk4djNObmJJV3hDdXFINDBueDhwWnBiODcrV0hiRmpyU3BLQXRibHptUnFxeXJzekVNK1BZU2ppc0NjQ0ltOWFaZzRncGtPK3Z5MXRzTURCTXA3KzRFVTZ6dytKcGtyMlRxd2pYdGxFMEY1UzhZQUZrbGVhUW03TGZaOUc3VHJjc1RmVkVRaGVRWjdZaXZYSTQxMU5RZGRnZ0U5aXpncUlzQUdjaDZ4MkFYR01YaDVEOE5IYS9jOWtONFF3Vi9KRFE0ZUJ2SXFiOW42YVZxNzNIOUNwRUdJS1VnbVdYdkFZcklyVjhzaHNNcVJlbnEyMlhRdXMzRDQvTkdBTEFSdVE1OTg0V2lKRVU1V1QxUEprNXVsTk5oT0NvM0dWRWpJV3VCM0gyL2pCajhBcVlVN0dVYng4U0NpSmVrNHFrYXplUjl2c3hTRzEvL3pMMi8rSGZmRlBtNVVHTERMTkdPUDVNNVNVajBSYk43QTNOcnNNcmRMZEt3eGxDdVZRbWJNd1pRT1czU1dxbm8rSkNnTnJ3NnAwdm1CZWlKZkp6S1lnNHFzSFZtMnkyYkxIVnNzSWhXRk5VZ2dHdEZMYXhibmhzQ3RpOEZjVWZUR3pvTFJEQWZuZER1S0ZIUWYyZzVBa1lIWVhITkhCK1FURDBkaFFMQ1dzYjJ6MDFFY3pDV3h0Z3dkNEt3eHltcmF2V3pwT3NDa285ZndscVVpakxqeFAxNUhhVU8wUmhhRjB2V09EZ2JZWHRTS3FRYzdHd2RZYmlRVHI3RHBqU1hSbkFMaURUY0U4MEZmNGFGbU9pdk1VODJxc2dYelNvaGFhUWNITUdFMDJNVUt4czdMS0pZTVRsbUNLZFpSSmQ4cUdKV0E1U0J5d1BOaTQ2WHVENDloUjVKSWI3MXBESEFOdUtyZVo3S1dHRXREd292cVBCc2lqckJrcmRqUkJsdW8xazZDcFhnZ2QwbEpROWk1VURzZjRyN245YWpOVW9IQitkR0M0djY0QTlzZk8vc1dHQ1pGUzF1ZW5nclNkVFBsdjZ0dGgyQStHekd6ZmpGZlh6TTE0bUtNdVdvdUQ2OFFSdUQwY1ozN2NCUXVZY2QrSzFwZ0dEbHNLVk1LY2UzWGRqNWdKenhienZ1R0hPNExxMmdzMkpsVE9WbytVeEY0L0JMa0k4RkdubGh3NERQMzZmdWxoaklpZkFXRVhCRERlNnNseEE2cHI0aUtJOG9Fb1VraHRFNGFhc2Q2RUxSQXJVZnR1bnNzVlFBbzJMbEJRcDUwU05tZ1lFSTdCZGlSREZLTVpIaUgrS0JOdmIxT2VNZXJWcXEvS1kwVnRtZWxneTUzNkZqRFpWRlpkOWZ1NkhzbHQydG5SbnJEY2kzTFFLaWZYL3I0SjN2QkZMTkJMZVYwSjlWTFU5TG1EVHA1b2g4TVhMR1gvdXkwY3NmVEtrSzJwR3orVGkrQ3BtQ3ROT1FnQ3Y4OEUyOWdXZ0NJMUtISkJ4T1JydWZIdno4RzYva3R5Nnl4SDhkQjhMdk1DSWdPdzBFQXR3V1ZVcUkwUEVWNng4SWFFR1Nrcnl0cjVrQStGc1c2a2ozTFpJZFo1cXRnb216dHRqVWEvZjhwZXVPb3RNNTgzM3NES2hSTkJ5U0t3VTRPYmduaGJNa0ppTElWR285Rnh2aWlUclhVa0ppWkxnU0RGcEljeUE3c0FCTmVKTVp3U0hxbnVkNlVZL091ck0wR2dXNU5hc1JJSXRWcnFaUEpzblNaU1d3eUoybDcydU0wdkttcnZITzhYWE82ZXJ3Mzc5UC8ra2YvWUdXNTkzNmUzKy83L1h4QXVVVjFpM3BNTjVkMjFYaFRHYkRPZ3lvSHFvcmpHM295NGVGSTBITFludzZic3VmS2F2UERoRFNoZk5qUXNlZlUzZmRxcUpuUklkeUNIcER1ZnZWLzV6M25nZlhOUFNkRmtWbC9Cc0tVR2xFVVUydXJnZGRlVkp6SE5kRUdIVldxanEyaVBuemo0T21ncnRuekE2NEs4UW9wNzB5dEY0LzhFaHpSMlh3NzEwcGVITmZHWC85QkdwSHBnTHJ5R0Y2SnZzRW52NUw3UUZFcWVra1NYOXlhelFyV2ZsRFExQU1aYmJUd3VyQk1QTzRQTE0xQUxBa2czNzZSYThPdVNGQlNVeU4wYUZPZjk3aGJaa0VRblZaNEpmY2ZwOXJzazJVSUJCNDB2L2ZKMlBjcmFZejl3cG9vSE5BcXlJQ3dBTDFCc3dhRWxXLzFZUVk2UElUTGpreTNENXI1MkU1cGx2YlVjTFZUSCsveFU4Y3dweUpUTU4xWWFCL1UxK1hKcWVFS1RycitSN3JZbmhpTXJlVFNHRVpVc3dNM3dwVmtpNVZmMkh6cE9KR3NGanVNMmdjNTJZck95V2IwRHFtQUZuVlVFanJpRVgycENaWnRrVUlBUUZGVUh2TUFkV3RVdzJYZjlLTmhmbmhhaXFDS2FTRUxob05UUWJRSnZrZjVQUmVrcnRWazIra0krOWg0bG1lU0JJVjVTRnJDRUZCVUhBZS9WNXUyMS9STjE1bEFkOGk0THNtTlJyeC93bzF5Ym1UODVITlhib29VUDlHMlZTNmkwMVNIbWY3eVI5dXhyUFhrT2tQMlRocnpDaFc5SGVaYnZlYWpvSk05RTVJU1hjaVlZV2Nzd2xLdFVsY2lyTXFvY2o1RWRRKzMwaGJqMnRlejIyQTFqbnM1UnVyOHUwZ0FsbFNPT0FFUG9hY1dBT3lsUzNZNFBpMG1BUStPandFYlE2enBuK2s5YlUzTDlYeWEyNUdGbm9qK0ZCeUF0cXdYSEptaUxDMVZPYnhQVWY0SGUrQkNmZHZFZ2M4M09Hc2k3VUN4YnlIaU5wejV0ZnZNQzdENExJbjlLMmV6aldnUVFuUm1lVmFYMDM0K0EwVDI0UEFTUFlTWDlpTmg5eHk4ZTdiekYxc0E3VVlsNm5XN3NKMnJ4T1VMczBTSmxXcU4vZW92WWpxQ2E4dVFyWGRmeXVzWE9EcjJpSDFvUFpEckUvb3VpZWVUZFF1QmUrUmpqMWdBUmxaZEt6bXhlK2RnZ3JzZm02NEFBQ0FBU1VSQlZGN1VxWENBQWZlb21SOVdzcVRwMWcxU0NNVjB0bDdHR2NhMkFyZlg0c01NTDhWWUYzK1hhNXV3dzdZeUdxT0FRZnl3ZFlBbC9FSTMxb2czdklRN1N2R3ZYOE52ditUWU1UZzJuOEU1ckloaFZ1am9sSTArdmY5Y0dkdDZDK1BoOUs0L3VIUWM2cUhiUWVvcXJsQ29FOStKMDZkOG5pd21PY0xoR1pyK3d6NTFWZ2dNWnhMb1VlVE1LdWg3QTlqdkpQWUFUTWhZRmdQR3FKZEl6QUhvMkNoNGU4MEgwazZCRnJDTDA2cFd0blFYNnRMMlFSeFJXbTc0dG5JNzZ2U2U5T3FNV3NUNjlKSHBIazJoU3ZWcUlpbUY0cFlpbkpLSm9HTWNBZithQXYyMkJNMG8wTVpuQ1gzZjhFVnZKRXkrMDFpVmk4NHVKM2ZNaUhpRHllM004K3JOV0ZjTk9IUm11T2lDTVFUMyt0Mkt2cDFEbm02K1owUVpCd2NUOTNnZEpyd3FpYmZNQVNXZEF1eE1nZ1RETVJyaG1YS2lkSUNCOXliTytIbnJ0a2VOWE44endIazRncGY5NEtyWm9TVGlLc21SbytUcUJnUmt6WXFKZkZWeVVsV2RuZzFxY3l2ckp4MWtwQmNwY1ovYTU5ZWZ1SCtuNTBpaGYvbjlEemgySnNaMEhGakdwNHZ6Umk5Qld5VGk3NTRQYTE1MmZ2Z2pudE9KaGs3Qm96cEs4aFRUZllGbzRDaSs1QlFrVERkSFgrZ3VoRGtjOWdqV1ZlZlpGWHRZSGlwNjNQYzFuOEJaMXJvRjMwMjJkM1dkVm53TnM1ZVdmZXA1QWFTTXFWK3lhKzJNY0JjL05RR0tUM0hDYU5DWGlaOGg2R0RDNnhEaXdBLzZQVVRvQlJFblZFSGdzZ090d0M5T2d4L053NlhET0FNM25Lb3hjcmxhRGhTOU5ydmxvSkErWDlQZTA0RlZtY2pWNnYxUndJVVR1TElaZCt5ZUpzV1ZvaDJhZlFwdzdScEY4YklYMmREMEozaVBsbDl3TnlFN1E5dFJoVE1UYzlLR0I5QTU0S1pxK1hJZ0FKZVNRcDc5aDBZdldLdkltQnIrYzl5K2kvN3k2Vzc3RGJsQXV1cjJoQnpGY25TaVFYTHBvWit0cVRuNjFway8yb1VHUUlKR0JVSGFUb2psMWhlRjJHN0szZFN3emFpODZWWWExVmsxN1VwY2JmZ09TWTR5RjhZNHJMcFowUHZTN0JvdnV3Y2xzeDFQSFdRcXk1dGVOVnd6cG8wWWQyMUV6VFVEb0FqbFd3RHNOL1grM0dxU3ZPdkR5c1oyeUZudHZYMGFVVnFmV2VOT0txMkpCeWtxeUpzOXJ3bGQ3OG90ZmYzRGdMTFR0ZlZOeS9RN1I2NWgzUG1wOVdMVlNVengreTBzRXdjeFRheTVYd05iN3I2cXZZZXFXVysvd3NDdHFVSCt2UEVTQWpXaGVQMUtCbDlnTmozWVNsOS9QaEVlNW1mdEorMDVVZk83R3JqcnhyT0Q5bGUyQmlPcUpjMWtmMUphcHdhdjdHUGxOZmFYMWhKMmcvV1JkSjhKUHAvUG9CTWtPNUFXOXY0U3ZEdGh4anBRVWJuZmx3S0lmUXJ0MjVUZWdXYldrT0tHd0JoN29FcElmSEdqQkR4Q21xSEJWdExTVGJZclVQcm9uV3ZoTXYwOXlraWxNK2wvM0lwTkt0Vm8yTU1NVzVPWC92WTdwdmJXOURJbTFhZklBWkp2T2JDMkRFMWhJZXBZRDMrRFk0aVpxMFJEMXdxbkowZWhKVkthaGVqWmR6TE5KM0NTZ2lXQlZ0OFhRUmkxck5NR0Q0YlpNYUg5cE1ZTHg1TlM2VGIwdE1KZGRkMzkwU3JxYWdYWHlBQkR3N3dkWWhITXpaQ3pSTFBrbVN5NEdGNm16SjY5dEtvS0J1cE1XS2RYaDN1N0hXd0p1MXQ3Y3pxNHh4TlBGOEpvQS9aeHY2NDNSR2tZbUxROUJ2Q2tCQWQ0SERWYlJpcUtxNUFQUndEZkRKd0lhbHlaZGNnTU5qV09WaHFxMW85R2gyTVh2QkdQTGo3VG9pR0Y4enBMb3dHalRuU2tBc0tTVWdCcGpUZnFCOU9PbGg1ckVCR2NIRDY5U3IyMkV4UnRNaGpqNXc5d3E5b29zdUdCK0dLclQ1WmtYRktrcTdpV0x2T2NFS01xTm12RERUOXlvaDRKd0dlZitHK25SYnZzb2hrS21pcTZ4eTFoVC9Zb29vTzR1YXdpQWxob3VrcVlLWU9EVWlTanJIWG9JNm9jbktBenI2bHMweU5qdzR4NDQ0bWhaM3d2aERrUS91bi9mZC9tYXdxc1VKYkpoaXczbG5pMnkycExZNCt2YlNUZURLendNSWtOcUExN3hMNUtjR29DMW5FdVNiQVN3K3R0Z3FFd1dkUnB1Wm9OZ2htMzRsSmNJMzJZKytxTFNheGs0WU12c0hPelcvUnNxTFRMdm4zSEpjSzdKcC9qd0VKNE9iaUN6Z2JQdndwcnpua1RyOExKTkcrODJMRzZQOTB0WmFwQ0FWQWRlRUtUNmlpWU1BeWUyN0FDM2JueTdaMVJuQTIwVGhVQ1hqUnNMS2dpUGdpbkE2Q2NOSUZ1a0JKcURTRUFha3BlTWQ3b0JUdmZ4TVR4ZlFJRUFDdlNzdEdEcHduMkhYMUJCa3FKQkR1SU9nSisrZzEyT0dNVXRaVjhuMzNhL3ViUXN4cTg5TjgrN2NSeW5pMFI5amtHc0p5cnI2N3FUblk5WnczTndDZTFQVXM5azZabVJ3RFlTeFdYY3F1T3BJSnBYNEIxNldlNjVMbWRYNjdlc2pRaGxhdGN0MmVTTEhvOEl3aVJuLzdsQmJkRkN5Ujd5LzBSbWI5MTRwQThQc1BZZklnWG9MUnlvQkUvZnM3V01GSkphUjZXNzhNemovb3EwZkUyRjN1cTcxTDJtQlpWSVMzMThaUThTS1NzZ0Rldzc0dUlUTHJyRzZsWWRVNnRUM3RGUy9PYm1uZ2NLOHhOWXRBWHkyLzF3djNiTmVFMFJxdEVLOHRHS1BOMCswNEdRVDlwbWRsaHZURjdDMFM1Zi9FSGJubHUyeUF3SHduUFJFaTNLdzZhVlpyVlFrTUhvUjRSTkQvN0FQUGU1NVZuMmFzQXlqSTBQT1JpUHkwbnBObElSUThSMDBhZjFlSnlxQnAzSkgwcWpZaE1qSWQyNTZ0dTRPdGFoK2lPNDdYeUVBamdTdElrV3dzbFhqbjUva3VtYzJDT3o4NFlZNlg2L2VBdkVOa1U0bTE1NzhYQ0RCQXN4aEl1TUszVnRoSllKQllwWitMTk1pOHpETTR1eEVMZ1JXQ0tUVEpsZStnRWM0NUNMSU5yZTBNWTYwV2lKenJodGphL2lSc3JlRmVKVWNCcC9XR2VvbFdCbTJvQlB6NVNoRlJxeEc3bENmTHVxNnNGYXpJbkxSWC9Wak9xYmNjUXdnUVpjME5sTFRMWU9EcWdxeGVXL2VTVUFxbE5rZ0YwQU5DWDRDU2ZYUDdMaFVOanBsWlZPdzJmNERpbzdyTlp0QlBEemFxVmphR3piYThnQTZ3RFA3MmZnK0h1UmQxb05jbXdMZzByTXNiMElscDA1emhCaXM2OU45cEs5MCsvV0NiNEtxd2JWL05kQkFkby9sRFpCY2ZJZTBPRFUzamg5a2pmQVFaR2tOYnRFb0FueVVMeEVnNWpYV2dTV1NWVWJRTmNYRDhFRGlFaVJxVUNpREViNE5wVFVURGtrUjRzcjR4TUk0S0gxRHdwL2VGbWpPK1M5TExYQS80eEZ4SGl6Y2NkYUZWSHlYcTdWY0hBMkNxaXV4OW1WS2F4SmM4cVJzSEg2bGRrL2dPSVVrdjc4TzVtZXc0M01ZVHFqbDV3NDJLbkpMWXVnZzBqY2xMczVWemF1ZzQrYnZLZmYyOCtHaTRqcnB1eHI1cjQ3eWRjbW1naGllaExtajJyVnVwSnBmUlBYSEtNbzBuZVdHZThzaUx3ZHducEsxNi96V0MzY1liWWhjWXFvVWtTdVVrMFFaTXVSRkgrOFNzL2ZQL1Y1WU56clNCQ25iY0s4enNwS3ZEWmU2SGlhejdsMEdWTmdLbTY2THk2WENZSldheGdjL3JkNmxTaGZzUzdmNXVQVWJJaDZsbU43L2svZnV3dFhzTlBwQWo2dldFaFlBQ0RKMlpFK1NRZy9mU1ZIOENkOGJ6ejIxSzZMaTBYZExvQjNXUk5GQ1JhNW5EN1VINDZ1eWloSHRIdzEzOVE2QW91MzlkTURId29xUy92SzB4eDlyRkJUV0RsOU1lakN0YVJRMFFIRGlaZjBuYlBQeCtYUXZzRUljamJUdElPdE9kTElMd0thYjVxN2hOQVVLbHBWVThhZ0dPUmdaUFgweVJ4Qk1lMEFGWGRadi9Wb0ZhSEZPcnI4cHdVb3o5OVRBVUx4bnlYUVhTT3c2YlNlZm9ZcTJ2dmJVZkNRVlErVlQrSkFZdEdmSmd2OVBqNzcrSVZtMmJRQ0xaR1pWbXJHU1FBSFVWKzgyRUpURjVrVzRNNWJYdzBLalAzY1JpT1FCWisyWk5GY1U2SmxSMWJIWjh5ZVB4NGZCM3UybVA1ZmtVckg1cVRRRnFwUklMckFDb3MweWluVFRqcGQxeXR6bmIwYVBHY2hFZW1ZanFSZGNwWW5hOEtWYytNYW04TkRMYXJoSUFFUHVhYkZYdlQrUkZWS2dyMi9oL3haeGdHakx2d0E1YmljaXlDbDljZEw5dEJya1hRZGdEWi9mMDh1ZHN5bTJWOTRvclBSYXhFWmRQSFBUUlY1RDdmMFJWNFRWRi9ENW12SUVrRWVncU0zbGFDeXhvNXMwcFpKeDErcDU2S3BaUzBBRVBtbGlWNWxOblc5US9ZOSsyTE5GZHNHUnJNd1JKc1pMSGJIV1lyRkFaMytkTGNxdnhnNGRua2dWQ0dKYW1XaDFTaGpBWGRYQzQzdmREQTBwZktPNlM3VGkzek1nOGtPdzkrWFhNb1NiQzYrYitaZk0xWEdILzUrTjlPSVdEUDRSN1BKSm16N0E1YjJSL1BkajcvVmplTU51V1E1QVVBOW0zTjNPWjVhb0dNVFhLemxKN1RuSFIwYlUzaGZXUUgwOHVjb092QVRBcjJsOWVDdHhVL2Y1Z0lrVXV1aXZLLzlwdTVYN1N6L3Jtd0FKNjdVbnpFRVJpRHlpcndZWnovUlNyYUU3UUM2UERBRE1BRmlISDYzamY0bTBWdzIyKzdnZTdseFhLK0ZsZXk0SHRxbi9jQkxINnZ2U3FuQ3lSRHc4SUhqMTJUVW1lRklHNHJmUGNQS3BBeGRUQjNNamRPRUx1UFIrdEZnWE8zTFhjT3d5RkFZVXJQUk9jZU92ZnJwRkY2QXJRR28xWmk0QUQ0YnlBVzErNCtYcU5YeUZ1U1BjRHFtVnNGMWx2ajYwTFNUOE5sMTRtU1ZQUU5SckpEOVBvZngvbjIrTlB5MEtwYjRJWG9icHp1dzdwS29pNkFyWjdlMHJKMWFFOG5sbVRJZkY0TCtZbTlKS1dzN0JLZWVLbEFjOENyNFV6K1JDVGttS3Ivd1FyQmNOSHFZRFREQzJEOG5aeDJudXZ6K2VwQjNReUROQ3VxS2ZOQzRsOFFjc3lLS3NqUWFHcDZHWnd4MkNBQ0tDd2ZxVTQ1U1UwRUpJK1BCc3hrS0ZqeTRkNHlJWWYySmhDMmhFZ2hYYXltMCtMSDc3RVNpanlvTUZrS2NramR3WnZPMVdKamNtbGJmYllrQlJoVUZtOUk2L1A0SmVtQ2tSc2o3MGxiK1haQWwrVFpUMjZFeklPMVdORm9WMjNCSzByL1Zsc1pFNC9yVXZGR3JwS3gwUFpHV2hwYVhGR1NIL2NUQUl4WENjRGFldXZCTTlxYSt1VXJwUXFBS1FEeldIWnJ5bjFhYUNUVFNWb2dOVUJHZGo0Y0E4T3J4U08vZkFSYWVpR2k4aTA2NWZmOTdtOWtSeWcrbURCSmVQUmZYWjJIMTFZWkRvbFREZHhvRXBFWjNDalB0dnZLVjYwSzZRZS9UenhEY05QblVXaktLbm5IOXl5dWp6MWRIdS9TSHZQT1JCUllmRUE4WHJLUUV6MWxmaHVJcnd0OTlhSU80aEVIQm1OcHNQNjh6bGVOdGs2allrOU0yNkVMOFdVTWdTUVdyTmJlMlpuZUNlODVWZU96anpuMkdRSHNrZStKbEppR0ZnTHZNRHdSYmRsa1RzUFVYTTljZjk2ajNQTkthZ1JucDN6MDVGUjZVOHIwWksrdjZ6UlJuNkozeWRUWnFDYm8waDhIczF4Q1d1Y1FQajlzZTFJaFE2WWp1cHVVZmhCNGtYL29nZnhGU096cHZNZ3dMYzRxU1owWk5RNjM5bXdOdEI1OU5BekEyTGllQXozVnBuNEpzb3dsbFR1QW1qa2VTdXAyZngzckNLSlBIWXRhU2lSSFRZU3hPbE0rOUtDVGZGaWVxejBEenFzTTJiN1ViWVFXY1pCYTZvaG1nSHE0azRCZlR5VExvM09JcFVUQlVrUm1uSk9Gd1JJZUpFZ29GTk10am9DdFN6VGFEWHg5Wmc0b3hrbEkxdGIxWEZRV3luQUN1a3E1cElKVHZURGFhZGZKZE1iVk43TnlJTisrL2tBMENuZWJ6dEdCRkZBVEdtdUFRWnBPbGx6cUFWK2xqUks4b1MzSnR0RW1EcFNZZlFLQTVXYWVrdkEzckxIaXpMUEpxOTJPbk04cmxaZ0w3bE9kQzFuTng2ZHpOU3F6ZlIvYTljNFJ6OEY4N3VUeEVJUnZPeFdEQ0puVWpMamZGenJwS3pqWm5WcllkWVVQQWhlQnllOFNHRG5wWlZSbFhsOGVGRVV1M2EwNk1wSGZqK3p3eWFhcTJrNGwzdDNYLytLUDc5MHpyUHZ5Z0JnT1d6c1g3ckVZajZGaVgzOW9odVNYZk5jY00wTElYQWQxUGNWT0t4MkJyOEwwR21BTlRKKzk0NFc2bG9FYmhLWkdyeTNpZTA3REVwNUFLdFptQmpLWm1aeHZ3UWJ6ODY4ZEZyRXZkdFY2MmNWNUo1dktpZUNocG5NVEZBaHRUcFd2NkgxUExCUTMyVzRwU2ZMUENQVU11dDd2bm5BTzNydTEvei9lcjhsM3ZUUTNMUTU1UkYxaVZUejlpODdkcDFZeExvcVZiaXpYZDAvS25HdDNaWktTRTNrOStGVEpjWndlRVJ6elFkR01uWThMU291aUdEV1FpWGdRanZrNXA2VUJreWJ3ajVianZKbXBueWZqb3BvclBCWmhUWEZ4WmVJcVNLRDRaMWVUb0J6RDZZZ2YrMmlwa29jblM3UzZVbG5OYzI4MWFwZkUxa1pNREdvZUZ3elI2WitxU21XbGtmN3VTZ2cwM3lVOGs1Q2hONmFzeFdvd0ZCMHArL0gyQ2xwZm0vbG9EelUvMVFXMDBEY0QzZFgvVnVlSU5EWVdtVWQ2eUx1dWVTM2NYZitKSG1Qam1pVk1vWlNPM0ViamtFNm5kdWQ3cGFiL3JJZkdjRVdUUDUwM1ZGMm92eW10NVRiZHM5MXZvVEFiVy9yUDh2RmtUa2V0Yi9OSk1LMHg3di8wK3pZMTZ4eTdTTlE0OW05TXA2Q2x2NmFTM1EwTVlnZXNFWllrcG1PZU9UYjEvWkxwZzdJemZ5dmtiMmVqVFVKNDZrR25IVjdJWG0velJJWC9Mb3gxN1A3b3g3ZEFOS0w0M2V3UkQvUEFPbk5uMTNJTWppck93dkVpSFQ1U3RtckFtN0ptOGpwNzM3Ly8wVUVCQlFaZkJXQnB3dG5VRnZqN1pjemp2TG1Lb3gwb0hxNjBKTnMyZy9OQTFpQmw0cklPZEZiTVB1Z05wamcwSHQzV1NySS9iakNETjNlNjNNOTM0Sm80NUJHQ3N4eGhRUXVOQWtPVnFCM010L2VaK1BoUnl5YlFJbnV4a0s5ZmN4ZDNSQVN0Y2hMSjRGYm1iZmJrMmRYTlFQWUo0eW4rVzUyQVdFU01sUXlUUWpNVnQ3L1RkL3lnWFN4M0h6NWYzbmtvUHlKRHZyMXpHVmtVZWROVkZNVU9CbHJzU0ZBalRLYm9RaHMwZGVKK0NjYVlxeGtmeGRGd2laY0Yrci9YMitaQ0F3YTFiZDE4dG9QTHdDMEZsU0pDeDNOSWZQZEh4d2lUaEhtWlhleFZRT3pzMVJGS0JvWWx0a3liSGVVT3crbnliTlJoQnArWmVXMEVHd0FheWtvTmpGYnRPWFFQcldJc3BxRHFCV2dJbTlxRVk2dUtwL3JNZ09BZGJ6VitXendzUjliRnowWlQ3SWV5OC9WRDlSY09MOWN2Q1o0YVovZGVxMTVnbkoxMENZOG13YmY5aXRSZjFFN2hncEVDbE5HU3pIRS91ZFhTNUJBZXJjRW9OaHpRSk40MEd6Qk44WUxmWng5Njl3UGZac3BKeEdiVy9oUEtEMUlka3BJYTNNcTFsZlJWdlZoc0Jhd0xYRUpxNytHTFExZGp0ZGNldUovVGJTYlIxT3c5ZFFqVnFVUWNLWitNQ3U3MXlRMXZ0azcrRDZHNnlPeDdvMjV6dFhKVUU3MGlhc25rZlNaWXBMODQxNzdRMFJHOUhUSi9XQ040WjNOci84dGdaN3ovdi9BTjZvaFZlcXl1WU96eDYzRDZIVldjY25MZXlrTTBoN0R4Y3AxSjdNTmswbFZRRkl4YnVJcEdQRXdUaEpieVpYL0RCc0FXZkNNMmtHZ0ladm5XVzdpTVBGOEZuM1FwQmx0eFUyN2xtRE1tTlBUdlc0ZFBLcHV2eWRsTGd4WWVpbW15dXA5WHJzVVB0a1BrS2xHajBoR3NvZkFKR3NRd1hBbEI1bGMvN2FsYlNLVjNKaEdmdDNTUTBrcXJSZXZaMk9ld0d5T3dDdVc1ZXZtMmhtREJQdTNRQWtHV3RQM2pWcTNkTElCRFl6TytjaVRraldiY0VMZVhvSVdaMDRrOEVFckR5Wkh5VmpYRWZ6YlVTNVFNWkc2VjNmV0NmKys0T2thZE80NHdLbS9wRGV3SGJVWkJld2JzREdaaUZ1bExFMmNIU3ErVUdwTXZMNkE0ZlhISkZWZmdQVHJ0UEVGaDhlcmpXNlVVajhWOFAyTFY3SFpkeEFXSmlaNHBhNG8xZGpNOXkrUFJkUTk5bCt1TyswZXNBbEV3M3ZBcmRuTTROWjVXbXFzZ0pMWE9pVHM3TVZKeUFrcTlzdkxKNzlJRWgzMS9RQzJMUUJ2YWJoOGtsOURiY2VjYVlObUdNbFdpM1crSTJOSzY3OW9sbGJjeUpva1F1eDhjREwwUXp3OGkrdzl1Z2duYWRVMFNtT2hmQjc0YUt2QU9icnFnTGppVGJtZGw1VVBTUXVXK0NvZDVCUmRyQ3IzQ3dHYmV0Z2YyelJlSFV4UE9QaktDczVoNVl3WW52MXJFRWk3K3RTK1FhV1Nwc0RtKzl3M2Rua0lWeGZiOXk3TDhuS2NGWDBTZWpaQjFCYmJyYlh0N3VVUzNwTGdjd3UvK0ppMStQdnlzTG9tM1dQSGYzL1ZCVFMvR2VvRlpEQ2pEaEcrTWpDNWRMcEdOdGpaSldmY3NSakllUE43Ry9jM0hhOHRITXpwcDI1c0h5ZHNYWFZ0MEVYdHRyRTRHQmtvVmpqajg5SE5UeDNXSnR5UE8yVitMR2QyOVN6SWxSTDM3NlFSb3IwZy9vM09JSTlldWZTc3kyQkYzL1dzOTJzYnFCYUk1NzEya0I2VlpuODhPdEFxemU4Y3RDOUlRbWNEbWcveTNYTm13NGNNZkFHQXp6ZkdTa2tyQUFCaFZ3Qm9jOGNrZ2ZybmZOdzNGYkR6SU9CckhjOWQ1Um5Lc3RSNFJsZUtWZW9WaVR2c3pueGUweXkvVjl2NStUL0krdXQ0S3RYdUtwUmJiK0kvQWVDb3VRbGpWeWVESWxXQXVaRmF2VDhFelk0cmcycS9CZWo3SXZPbVZycFN2WnRCK3l2cVFIcklZMUJuRjB3MnI4S2lScHV4Mmd1NEp6N2Y1VkJHVDNtUDBtZElHakhXdUIyMUF5TlhHNm1lUzdyd2U1S3pLZitDdzRkS0JmaEd5OENXdU1JVmdtRUhMeU9GZDl1VXJKTysyRFlJZWhrMURNWHIwK3R6SUk1QTlUMVlrMFh5NDRhdnRONWFoWFIrdWprcGMyMFBWejA2dUNkOENieE9oUWFhZ1FJWGhiY0JRWWY3bHg4amxMRnlqOXkwVlRERHorMXlBNmRYQTJ6eDV6MXBkUUF2L2liNjdzTEVnM2dBK21tamhkQ2MwK0hidmdFL09ySWRGZC9Kb25vd2hXUlVjZGRjRGVSdk8ydFd3MXdQK3oxWDdqWENqQU85ODdwQzJBcWcrVy92VVhBQllKTk5LSDkxTVhnaWZzL045cHk0R2diSldWM0w3SUYwTnA5bGw1ekVtcGlHTS9xcWhHZDRna0xnRlFscURiR24rZHBUTk9qa3ZJOUNyRWJ4a3VQUm9zK3ptZEkxSFRDa2UrRE9OSUxrSUdNVHFxSWNQTkxOSlpoamd3ZVJsaWN0UlgrSHJ1SnJjbDZvNldYQmtYdk0rbWNLOWxGR0REQzl0aEVyZ3hhUWs2STlPT0ZnYW1Qd3JwZ0cxRm12b2Z0ZmUvT09Odkg4R0xPV3FjdTJ5TFRhVkNKUG9ZVW0wU3R2MTZ3M3U5SzRORzlnZmo0T2R5MkFkUGFPMUJRSjNMaWVjcFBBcG9SekFMalRvU2xLWDd1NmN2R0pURTlhUzZiMVkxWVh3WWl0ZU92ZjB1Wk5qc1VxcUZVWG13YXd4TW5Ea3RFNm9xRGFvcGl3RHFMTkM4UzM3Q0ZiRVAxU2lzTTJiWFVqOHVTeDlhMFBmM21mdERGY2hnOTJWL3RTOGVGQ2JVTVVRU3hTanFSL0F5Zjk0WTJVSWtKN0hySmN1NUZWVDhpS2RCcmdqckRvdUdEZ1VHMko5bk1DeUlLUnB1Nm5zbXZTK1hGNEhmY01tT0pxdU1lQzUwdFFWbXNETjdXQWgzRmkxb3lNWnVFaUgvM0JhVkRHTmR0Wm5jelY5c3g4NGRPdG9kSmFCZ3BMdlYrV2R6K2VNMUF1SjZEVTNaazFNQ0RaZzBSSlFGeDRDMnhzMWgxR09GRkZ3WjM1d1NMOHhwVnpaNU1YRStwSExZR24vOU91UEFRblovdVRDK0E0R1BkcWZ4WWRoL0dMWmlkcHIwNEdwanY3RXhQL3p2NE9Da2FyYU40VHYzVHNYL2tLTUpVWGxOU1J5SWhVTFJUZ2xFcHVOSElVbUZMM3NkbytvWFZHMnVzREljeXREZDd6allvZVdqaWdsOFB3Znc4TkNBZlFuamlpaTZJVVRuQm00K2FhNlVXNE1OdDNvRHpYM0MvSGpXN0U0aDlMaG1LQ0VaUU5UTEJhc2kzNFRJL2o3UDhicG1VVDR5VTZKdmxpMjhtZCt1WEFRYVhpQmFIT2N1M25hNVZBVTgxbFRjcDBxNFUxZVYyajhXQTBPZTNLWmJCRWdOTkQ2UmRySUhGSWxyb3lGamdDRERiMHV3eWxsTTNhbXNyc2FSdjNKSkFSc0tkQjF4U0xSSjlPWm9nb09oR0I5cWhBM0taQ28vVVY0dTdzbjZzcEZWYnBtQjZhSjY3REFFZDVSRHEweWJwOEVVQks3cE5HRm1FS0MzRVdub2xkYzN6TFhwb0lwVzBneEdQRnFoZ0IvMCswVnFXQXpXaDhTTUFJaURTaEhpYjY4Ukp6RFNwUWE0ZG4wZ0lPTDFPOEZyQUVWTW9CSm5pQkg5eXQrS2djSGtZZ01YdTJicHl5cGdHWUVsOGVBYXVHcHR6V2lON1VrSTdJc1EwQkNLNzV2R3VrMWVBanp6U0ZxVFdBS1dkZ1ZhRUpvQStTT3RBdDBsdlhObnJXOXAxdlJPYmNzQ0NqTGhzblQ4Qjc3RGhtVkZPSzlwS1NsZDNqVkFadDNORi94ZjhRY0o2QzZEYno4Z2pmdGFYNytuaUYrRGRnYWg4MCtVekdnZXlUQjdWUU5wYjk5WkZnQXN3aVJKbHJ4N0w3L0gzOTZXaFZWMWRubEFSQXR2bStNejREcEoreW5DeWV3RTZncnA5YnFvdGdhVWxHRTBkKytDb09jVFNUYnJKcUdhSzNPSXM3YWxvNmRWdUMvVllhNnZSRTNYUWgwS0ZYVWlCSWliM3pycjB4NUthMVZPekNrU3I4TG1CV0RLVGdvQW9jeGptMmgyM29uckZZa1E2R3pOOExVWUJBK3IrcXNYM0s4N0hyb2duUXlObnpDZUJNY1psVitiRWpwalM1NE93YUNNeFdLekx5cXhvbnQzNHQxTjhxb0VyOGpTUWlldEI2RllpSlFudEpFMUJicG5qTitZK3greC83Snl2MHZ0cHZwTXdsdnFpOElBbHNWWG5WMjkyd1pCRjFQVFRQS1Z1NWZaT1BOZHB6U3FTT0FEbDNHYVA0N2hERW40bGJQQjBOb2d4LzhSSGhxdnVDNVp3RTlWZzBpOGRQZmt1MGdWNTdRZXVNejl4WWluZ3RZSUJTVGZvQXAxNHVkMVU5U1BKbldENUVoU1I3VStZMFZwLzk0WmJIRnhiVUFBajVDeElBZnNObStkbDRaZGZSR0ZKR05TME9IMjh3RmZSY2NnbU90d1lYSXBaRzVZSHZzb1FadUhQbkZpKzJMNnJrUHFoU290TkgzVVJzK0EvdGpHbWdGNjF3L2w1K3dKNmF4dlM1OE9JVElCbWp1RDRmY0gvNjFaUlpwYVZxcGtuVEFvUUF5REpOdCtXclNBSU1wdElWMTBJUFNLaldBTEFTOFU3Vm5tdG1sOUs1VlcrV3U4T1dES3Q0dmRlTWp2dThsalZaQ2lnZUVtYUh3aDMrNHN1SWVEL0JsZlFKTkZyaXUrMDhlL3hFYXVkYnc4elVnQTZNeVBsN0FwQWlWazM1QWFzU2gzMllEaWRQTjhpT21QWnM1dWZTeHBuaU45eWNONjZEcVN5TzRZVndYUXF1WWhBWmU4K1BTN1lxRnFDTEZ5aVYrTWRic3lkR21wMUNjVzEwRWZpenlteTJ3VnRLQVZDSkdxMW90Qi9WVCtwN3dERlRDME5OZjFCenRyUTFYMGVnNXRsQmI3RFE2YnN5TnFDbmJZSFNEU0lJWlN1RjQ0cG92bnp5bTc4djRwbCt5KzVYQWg1cmxZOVhKUnkxQWozSmZPc0orN093NlY4NTBEQUhSTEJ5NkE3d2R0SGN2NE0zdlphSll6T25ycW0zd0MwS2xERnpBMWpMVzZ4d2hkQ2NDL1VrZzRUZGNjRnlSaXVJcXBzeWlDRng0ZFJVZHp6MDlRWEQ0NVhjSDQ5QjFYZjNXbzRPRkp6ak94aXBKY1E4QnFEcXYrZWk4UmdOT3orMFp4Mm1vZ0ZaMHp6R3ErVFJjNlIzNkhyR1JGa3ZJRzQreGRiekY5V09HZ25jcWo5dTdBVmNQSU1NYUMrL3Z3dzBOT2xTUEtxeWFIQUpIMVYxaVUwMVRqV1Z3UlFjZXgyaDRRTDViMGJmQWptN2M5eDRickp2TEZzSE5jYWVKSGF5WS9RZlhpY2E1QUhSTFE2UkJXUTg3ZUhqOU5ZTU1icWtxZGtxdTNSWmZVNEdIcXV1L3pweTdjc0lLd21xMTlvY0hQdmRHWnhGT2hUZHhhdVcrRFlTckhHeE5XaWpMeUdOSFdBekZaVkhIRDc0SjE0QTZxSk5nTDFYSmtKUkF1eWF0ZXlEMDliVG5KeTc5OFo4NkhSUityTXJuZUlvM3ptbGZlaU4wTUQvZEVjZ09yNlJnQmttSHQvdnJxS3J1ZkxIWFN2d1MzcUdoQVNDc3JJUElGT1UwY0FXYkxkVkUrL3AvVFc3Q2tRQzBOSENVSFR1WVY0bEoyYkpwUzZYVEdYeDRBVHh2L1oybmMrYVcvcFdGb1owSHZ3VzFtblFsRmZ2MEY1OTZManhBekZxRnplQmJwQTY4VnZUcHFTWDg3SDNXMnlxMFhqaGJaejI2VGdrQjJiVGw5b3lXQ0V4MWxjREpYRnR2OWZHYStkSjVJTFNPYVRYbjNzMUZPWkRXekxGbjB6clAyTmJaVHM1MU11dlEzc05zdU9xeFFPdlg0b2VUSzJ3ME1QWG9LbTEwU2Q4bGR0azRUQzhsaVB6My82UnZac2Nxb1lSQ2xrTnU0WjZQaHkyaDVFOGIweUllOEp4RHZSZk9NczRBN3R1RFhEdkErVGJucTRSNHNrTUxBdkpubzEwaFhoeEw0YnhNY09kcnNkcjZvZkFCRFdXT01WVGk3MzZDdVdScmFwQVhhbEhlSDVRZ0ZSYThnU1lWOFlGVVZrNHVLZXlNTEYxU2JIOHhxUjRtT3FLWGMwOGo3dy9sdkU4QnJmT255em9kdWtEakZOTTdhSlY0UGZzbjFUeDhYWGNUSGZ6S1F6Q2ZBVFdpZ25kWWZQcVRCU3dwcklZNndUeWV1VW01OW82dk5PMVNaRFZjcXdBQUlBQkpSRUZVUEQrc0VUWW1ZNC90dFFYMmNPZThKU0JpOXRQS0RoYThGWWVrbmJadjBhT1ZJRVBjUDdScGp0SGNjeDN3VTFxbC96SnlIeHhOa29ETXFRdUVvTEVyMVB3Mnc5dmRKR3B6TFQwUDY2bXVEemI5MWZUY2tQL05YY2hsdjJFeGg3YThjZ0ljNk5oeHJ1eE9VREhjZkloQ0FIVVFUTEE3Z3RTZWNOZ3ZvR29hTk1LcXdLckNHLzI3bHpCcnNFZ2thZkdVUkE2aytCN0NEL1VHbzhveFR6YlVub0VwV3NYenc4blBVcUJiZ2ZlNVBXdS94dFpGeER4UXUyaVh4cWxjN1NFb0ZnRU44Mk5HRktSYnMrWnJyM3ptaW1NV0RWdGlBYlBueHoyamJiT011SHUvbVEyTTNUYWxSWnVpNzk1Z0o2T0hsd3NMSWlQTTY0RFF5THZtdGV1RVQ2MUJHWmorZHJ6ZHMzTE03YVZTQUJ1Y1BJYnJNd1F3T0E5VTVpYXhEaEM1bjRjTURjMkErUWkwYXpNaUhYaGtpM1FsbkNnV2gzcUgyN3hXdWhENnNyUW9HNTlxSkltNFdqdTh6MzJWSVFEemx2clZ4cCtYRExHSGptVHU0TlhwWEJTdTdFcFhQZVRZNk5rbmNVNGJsaG9udWpxa09tbnRjUHF3YUxXK1JkZTRIOGlBZ1E1R09kcnR5bzA0MlVIKytDZ3FaNmQ0Nm1SRW5TTnVBdUVHMlBWa2hyeDZGc0d3SXd3UTBra3YwTXdtUnNPTnZHMmpLb2Y4OGg0dmJMcUhaaktFNyt5UWk2bkhleWhqRWFWcnhnUWR1dUgyZkJVazNwUjBiOEM3c0VXdVROcHBwVFNkenFQSTZZTVQ3MnNRL3ZCWTA0cDdaOWF5djdiSVNwdTMrS2JoWFE4cVpEWVZMUDBoVFovZU91SXdGOFpIWVdyL1BSaU9WTWFvN0lrOHJOR2R0MHMyM3E3ZmNlbFh6MVp5Ym94cnVPWmlNOFBwdlA3RWlma1hmMnNDb3VxVUdWOS9Rc2wxV2x6aDB4aHQ1bzJTdEhkYTh2di9zOG1zYjRRbCtCNlBvUUhCNnh5ajVnS0ZtNVptZUpoL2htSy92SzRZRE1icFE2OUMvK1dOTnk3NDBVYTdOSEgyRHE0YTBxTnV4MnR1M3BrMlRYU0JlS3F4aEtUY25QWSsxVnhrQmRTZGhGTStvUDZpRHR1aE1Iak8rYzZHZHFUclJVUk1OQURJQkNwZTdFdmdRQlFTcUdGVHdyTSs0bDZXNUhBV0xZS0JYZ3hNdGZleGJzekMrekJiTDd1UEloVFRxMk9IVjZpUVcrc3dzODcxanp5TEkvV2Yvcm5HeEs4ay9WWUdOanJVdnlxTGRkV1Mra2psemVZR3NUeEp2ekc5MlRsYyt6OXIvVkNkQWdDaFdvRy9PeWZHM1JPZTRpdnYzRHEwTnh4U3RVd2prQ0x6UUF1KytOZTdvcFpHYnYwbjRibW93anBXMllWVVlBOHRzbis5S2lMZk9maTFGdnJxaVVKQkZCWnMrMEQ3UWhBazZ5YXc2U2xnMnNDNTVNSXlHL0UyVWdJNHRzSUxERTBEWHdyY0MzRjN3Rytac3BQdmFhVmk5MDFzUHREWmxKWFRnamVocnJpVjV0RDRUVGZzb0tZdDBzNUxhNjJ5RVFySHk4YU15V0EwT2ZlSjUrNUhxM1dRUXMvS1NaQ1dpYXRKbU9uc1U4SFlTa0RDOUNialBsRGFiM0hwRU15QzROTU1NNzM1M3o4K09ob0JtT1dTbWJVdHdjdjd0Zi9YbVMxQjVjWE5nT0RsaFJMMzBZMFErYmZUSnpmZlBzNWFTVDkyYVNSRE1rUEJKTjFiajdSNFd3R0lsRFVtQWttTVZrUE9TbEUyTXExY2E4NHZhaTZFd3dNQ1pLWWoxOVlFZDZ1MWlrd0lvRzJSbHBrbEY2VVY0YUQrcHlmUEFUQURxSkFqSnBwVXFNNkMreC9FWi95dWpxZGlmaHZudVg3VmEwVE1janBzcENoTVJGRmRFb3ArYmhUSHQ3RUFvaUlpbm4zV1JJOUNNTVI1WFA4Q0daaVhSV2Z1OHhjNFZQRHhnWGt4Umh3NlJ6NHFsaEgzNGRaR2VRZzR5T2RUQUxVRFZNVnd0NUU5MG5lL0xIR2RrNnBXTlhmSVJ4VmpWamRHMG5hL29hNFJ4RytpQS9rbndNbStBdTJBakNXOG5uaWU1c05TNVZTM1FqNzB2Um52NVoxNklTUjJQMEYva3loZEJGRFZwaFdJMFhucUF1b1I5d093ODFCUGlOWE1VY0gzNFU0SFRLanB5S1hjMjVXRkFteWZXdkcwVXNaUkJERGxLQlJzcHNpUlF5aHdnaXk4UEt5Q2thY05VNHpmdHZZeXJjOXFENFdHSTQvRHNxcHNVSmNjRUJCK3ZLb1VwZ0xzR29PRm50QlF2b3dMVFNvb1oxVHBkbkF2MVZUaEJKa2x6UDc4RThaT2YwZ0Zubld1QXJxZW1UcFJ5bENOcGZPQkZvL1lIWmFYYjRIeU5YV3JxUnY5NlB6NDJ6MXNxRWpZSUFSZ2s2UldJL2JaYTk1blZnTEN1dVlyc3IwNUw0c0Y0Sk1UbTBzRnowbHFNNUFSMHBHNUcyVS9xWkNyekFuY21YekNwd2M2aTlqQkVBVisxMko2dklTR2RiUW9lUVdESTM1VnhQeDZOUkJmWUtTdjRzTEx3ZFpHSE5zWno0bVdOQlVxYmNSb2ErN256YWU3QUpjaWs1UktBbHYyMEpnRDVUVGNLSHZOY0J0NUFPL2J2ekk1VGx4elN2a3VwT0JrRjAvMDY2WVJUZUxCazdVUDhrZGtWNkd5T3Mra0hTSGhZS3k5bm1tNFVxUTVXQzlXcEdpR21iZ2NwS2R5ellyNWd1bHQ2Rm5FR25XeXlKZldSRW1xQ0FHbjJWQ25NOW1RUlFZUnMzZUE2a0hjaWcvLzJoc3h5b2U4TlBRTHlvOXVTcWdTZXRUSW0xNCt6RUI4dmZpZmdXdDZLdXRXQWNjOUQzRHdTNnk2blkrQUh4VlIyNnpKdFBHdFRmaitVSi8zMGM4elBrRnJoaGc4QnBJOFNGSGpqcTZWbi9NN3g1bWVHM05DK202M0hZcEI3Q0hQbENrTFFpZGEzWWQ3SnZxbTRicnlFZjFOQmxqc253TmU1djBBb0dqVExuR2ZNV2N2NG9NZERHbE1Vam9zS2xabFN5MEt3cDViVlpiZXlxZTQvZGxHeWU5WGg4VlNpTXNSb3RNZHdrYUhCUElMNENlVDAzNUJzd1dEOEZhUUFCYmxhRnpzdFIzUmQrR080bGt6MFBnNkZLMnVJWWRvaUhWaUhaYnduZXJVVE9ER2d2RllRV2VhekpQTjlKVytRTllQOFNDTVpCaDN1eGlPVkNOOUh3SHR4aFlDMjdIbzlEWU1lbFFnVHdCU0ZsRFM5b1F1Y2Z6aDNjQyttN2hHSW9yamo3NEJDbUpka0lobG5wQ1BMek5pckErd3J5L01jQUtyQlM4bzBEUjZOYUVjMHdVc20wSVY3OXgzaUZWaXRnSXRqM3p0eTBSZW9VYzNDUFpaSUM2UmpGN2E1bDhKWklWTnNHUlh2eE1BNG1OM3lDY01lYXc5Y0dtbFozdFgvY2ZYOG9PSjR6VXFKNkJqNCtYTXN3aEZUMkRHOUZrU3ZwUTk0aTNrclFMZzRvWjZiV2V5dVRxV3dtYlJvV1dseDVkbG9CMGRWWUZrYmRkb0VBYTN3STQ0TGU4aWwrVzJ1Zk5xdVhYeFYyOCtCaFlhKzFkTnBqbzVPQ25FaC8yMG9zQUtPeGYxV3JzWDRnUWRUYzFLNnByTWZyVmF3RHpFdnY3Y2JHZk1vL1g3NUFiUXpvUTdmVHRiTGVvWVkvM2dWZHRObnZmU1pJRGhqRVZWaWs0NkQ3anM1d010ZWJWaVNtbFQ4S0U4UFdLK0hVL3VkZ0JvMlAwS3VZcWdnSk1KbVBQU2tLcFZCckJZZ3dadlh3aTlMVWtpOGlUTmtuNmxsSFkwRjJ0bko0T2pyWTJjZElOMGxTUCs5NzlYR3c0cDY1cE8rQTJGczJud1lpaUJyTEVzTUJxVTVYNVU1WmllNE9TekZEVU5Wb0NTWlJVbFFkWGVTU0F2dWRWK1draTdKUnZ6TUh1QTk2NDB3K1lxdkRWS2JjSTE1Z0JSa3pZeUVZNjFxUnBQMnFHT1V2VFpHZ1AxS0ZibHVxOXZZQzRpbHZDVXNrdlZEUG1MUllydlphMzlLR2dFK1ZvdEtQZ2x2alUrdW1uVm9teFFScm93WitaQWNmbiszSVhUN05xQ2c4WTlBUElacTNSa2VDcjc2cWNzdmtzTzJOTmd5RUFNZ0xpZ3hHYXl3UHUzSTNSUnRCeldXU2hVVlNMOHUwK3dEa0pEQk9ERTNOS01OdHF2YlYxQThBZTdMZ2VpNDBKU0E2OGN1VHk2L29kWFFUU1dvUXdNblg2cGZNL0VJVTA4WkNpOHN0V1l2TW1tYXBUMEgyVTZXWEY0TUZHVXVXVlI1WGltTFBKa3JUYnFXbnR4WXdadzRQWkRkS1JsSTNvV3RzMDNPeGhXbnFBMDhKckJJWUc1SC93dWtOdlZwQW14MitkVy91a1Bhc3R3VjdhVWV2V1RJc1hyd3M0RkhFQUplODBrZVE4ZjdaSnVjWk8wOHB4WXVlTzU1M0d2RGYxNnp5QUlBd29YSHhmQTdUR2wxRVNIQzJVdlg0bWxMOVVlZFdXbFlQL1c4Sm9LbU0xUmw1UVhiTEhEajdWR2kvU3h5eWhQVWM4ZFBMUkgzM1pGZ2FyVnJIWnQ1aTBWRzQ1UVZPcmlxOHVjNGcrM1lvOWlJWDQvTkYwanErQzl1c1hjUURlT2tZQzhBRC8weWdPSUlWVU81MTZhUmdLQlZTdnkwZCs3eG9hMXl3M212L3MvTTlmbUNDS0pCZ1A3c09ZR3FaQXIwSkU1ZmcrVnpFN05vSXFmRFdlNC9jTGdZNmRUdk1qRUd4aktlQjgxNURxbU1tT2p0bHlrK3BBMnNGbzE1UDFTb1I3eUxuMmQ2NHNkdXlJVjVnZ0ZsVzY2NktrWk5lTUt2SW1QWWdPS2pKeFlGem96QWgwTGljK2NhTWMxbkdJWGNWdzhER0w0RU96L3Q3Ly83ZXVmRXBoNjBTSXRicTQvZDIxVy9KM2tuVG1SQkRLUWlkbllGbGNnZktzY2ZpaGYxQnloMzhobjNMM0R5TTFBYXd6WUE4U08zTmUxU1ZVbjNwR2NVbW9ObzJCSUpZdFhXNmF6QVROY21qU09Ha2pSUXg2RzN5dklRQVY5ckY0MCtnaDhYa3A5R1FWVWdjZmZYem55L2o1dzZnaUNGc1BSUDhQNy96cjk0c1lDbzN3RmhNU1VrMWZPbmU3Y1dOZE5EU01udEtMMUc4ZHJ2OEVIbWxZZC9rY0NLS09VN2hva1JhT1QxeFlpQVVWaWc0ZmE3M3JHOUJwUmRpQ20vZWRUdHdMKzZuUS9UeGt4L0xienVjR3JiY01NL2E4bHJkM0djNWkrelY0NitMTTYzVHJXQjJLWUk1d2tieUZSRG1BbndYY3NyQkJYUzFUVDYxUTFLaFJlOGhEM3FlZzNrb2IvNWJHZTg4ck5Kc0dLdTRyYW9lVVo4bmk1anRuMDRsTUhQRkE1bUJOeWgwNkp5S2tuaDBERzdEaWp4Rmh0Vm5FaitDREZJQ3Nmc2R0d0JlUG9Jdy8wN1VZSUZURHBiS0crNmpYbGpOL3RTbDhKY3F1dndFbmRNZnJNeCtYSEtzbm9jeFB6RzhMSGJnRUVHODNIUGJhZVl4cFpkMk5GUHpobjU3UDdWM1VseWVRTnNvOGJxQkM0bTlwbWE1eEZ6dDB6ZlhRR095cWdoc29sUll5cVRvN0l3bzF1MElCaWV1RUNZQ0xwNXJhUFdXbTROSEhsUzh4cTNtVmYreFNyUEhJNlJaRWxUOHRoc012RDVPdWhaQ1prVnFCT2ZYRVlneGlVSFFHTnEzR3hwelFEM1U0SkdPTTNadld3aE5XTkIwMU1aZk40SUlGNUtjakd0Mk81L2RuRUcvdStaZXNxSVcvdHRVdURFaHo4TFF5Z0dvRm9hQ09tVTd6MS9kYnJQNlRtQjM3eGs1WjlzcXdOak45SU1IVVQreWFVYm8vd1dhMnN4dk9PQmhrNG9QR0RsOS9rNVRUamE4YmdlV0FsKzJwV0loa3BnSTFjRXh5NG1KK2N5T3NWdUswTEJiWmtXQ0p0eHdCalc2S2tXWlB4VzJHZkxIMDZYWFZTMEN1QzE5dGs3Y2VuNmlCZVNYNFFOeEs5MHBHRmMzUHpvNm45ZTA4anlsdnpkSCtvUWxiMThTL3UxYzd5RlJ3cXVYYXlVV0R1Q1dGMUg0MjE4aVJWYXo4cDQrekVXUzMxZW8zaERNSUNoUURIQzUxVy90ZFRrbHduZlV5T1VyOWZqbDIzV2tpK0ZMUWlud0lkcElUL2pGWUVTaXpMQ3FCbjB3Ukx5YjNQNUJlK1ZnclZTaTBGRGVGNHBpZ1R3ZW5SY3VNN0N6UVpYMWFwRVVuM3lDdWhRT0xNMHhFTWNKSE5DNU1McUd3L0FoMFRnZm1rU2F5M29xcklkRjY4SUwxcldpM3Z6QnhnU0daaWE1LzhreVJFOGk2cWpOcTF2ZDlDNlhFcWNQSDFjMVlxcENhM3Y1enFiUWVxN1ZhSzd3ckU2WHkwLzBWTW0wRjZoM08vUGszc2FJUi8vMXB1VktJT1ZHaXI1eVhwaGh3ODV2YlFqdjh2dlpXTUhoMnlhelJMOWJXekpXTTN3M3ZIUVQxUjA0WmpscFFYRU5qUy9UZEY4NDBxcHI1bkxVdi8rOE53THRmcHN0WnVCTkpOTGQ4cVlnWExHZ0laSlN4WWxCUVpjTGNxU01NWmRONjZMaHU0V1BEbHIzOE52NUFLUVN4TVdsdC9QZGtoM0ZpaVhLMHZ2c2dXZnkrSjQyRjZUSWV2VDJtZjNYaTliYUk4MXE0UFFhTzZSMitkL1ZjN2RkSTVQZ1ZpSHZpbG5HVG85RW82VHdwL0M3N0ZRL2w2WnF4STRuNC9FbFJhTkYwM2NJQVplQ0J4MW9hcFhuNW11QlVUTFYxcGY3RGtZQXhLZGpueHFzbkxhejl0ZlBVQXpvcGFlYjNpNXlZcnZGUndTWUNzb1E0cVRWNThNRklmb2NoRWxWZ3ZnMXVQdHMxdEhkTDVObEwralFISUNxd2lXdHZOQUZJRlN3UlJpcHRlZUpHdCtkNVAwQ3FKb3R3UXhOT3k5MmxxbjVlTDdXQUViS3BSbGZhMHNmVmRENnU2T1U4Z25DV2lUdjVscFhSaFRhZ0hUQUlqeElxWHNFZEw5VE1WVHB5OUlMTHhaenRHK3NCcVBXYmpIb1ZGWE9wV3Npakh6S3ZObmdSOVBYTFRiQktEc1VXcGZIQ0xvRXJkZ3c2RWthY254cVZhSVJRZnZqaDMvditOU3VHRTdHY2oxa1ZYcldyVnEwMTdST2U4UER4VnBFakczUzQ0d29FZzhNNk5BZ29yaDBxaEhJRk9KOGdobjd0dVNxUm1zYU5TcUNCNmgyWS9Qb3owWllpK0Q4VW1zWUlLVmd5SExFTXFFYnREUWxRTVBuVXViQU4xU245cDBqYVRrcVB4WjJ1MldsWG1tQnZaRE8zb3BOOWlFZFNVUWx1MnpjVHJvNzFwT2lrZUZ2Y0Fmc0JXOHpmS1hHQ3Nja0RybUxUZUJDckZ3SFVDSWxzSEg5VjhyK3NBbHdZWHdmaW1SSzBGR05SM25zcHk2UXlIYzMxZUdXQ0VJNlNocmVCTnRuYlE2TUcyNXdmYUNweit5ZEVlY0lROGM0Uk44Z25Xa2VtOW50ckxWcUVLY1hzVkZLZkVVUnVPTjVsQkhwNFRKV2RxSit6Qy9WT1FZdnN2NTkzLzh2WUMvYlZMY0NRRUJPT1UyZmZkSlBKdURxb3BZMjd3d0pyN1c0MG9WZjA2dk96dWJWclJTR0p4bGVoRjgrbm9uK0VVd09IRTNxNFh1OHN0Z2FWSEVFYk5nNkVSVTg3czZYeEdVTkF2aGZoMGxIT2QxdFNkTDJsa1VaZTAva1lubDlTSjFXeExxdkhWdTlKV1kzYWV5STIyb2dwRFVZalBhVlJkeE4vWUpWZjAxSnhpeW9oa1BOYWlRcWpaYkFuTXRsV3Z3MURVNktxZGVIZExDZ3gycS8valJwTW80dmZvSkl6YnRKMHdVdFhhK1Q2aStMZS9xUkNJby8wY0JIYnpaaFhGckpmb2FPcGhDY3plZi83UG9wVnJtTkVSbTdLUDZmMkhVb3lKTXVuMi9XMElqOUU0QUN3K3pnNTBlNzVNd2xTMnNXeWtmQ3hpbjFyVThaSjBPSGF2d2lVaEEzZHZ4NEZBOHBWUEIzWEo3VTNwQ3dCUEttbWN5dzRsZlJ1QnoxMXBBTmFEQnMwcUpEZ0tEMTBXYWVrL3hrUlBTbmdOcmR3S2ZLNUdZVjloVTE4K2lqclE2UjgwTlJ2cnd1YjZDS2l0cXVBVmU2NWkraFBRRTFlQll5MW9VMVhNeHNIOGQxMnNidVd5UzZjWlR5Z2QrbHlBSzNWeW02SmsvWFB1a1FicHl2MGM5RVRiZWlSZmpoaE1RbWNNUlArUlMxdU1nVi9Vamx3T3dCMGhTckRyM1czR3FTM28wQi9PT0dzT2FJUkYrRU9uenZlZy9jOWowblVKL2ROVHpPY1Q5ZHU3TWU4VWQ2YllCQWRFQ2xha3IwbzBmTkRWZVVhRXNIZC9XNEYzSVRHaVdNRC95d3JENXdKM1doNXE1VVFQZ0hNTTJHeEM3WmVXTXlRMzR1TnVWQjk1ZHg5RTdXYytXYm9kdUxGWmUyMFJvSXdwM3ZSZG5JUG02WitleVFyRWJQcUZLMC8xN3ZlZ01sR0lObzlvdnlSZk9NWERGajluK3E0U0Z6QTBTVC9BcG5aMTlyQzFIUm9RMGdFQW9hZ2RtRTViVUo4czhVWUUwQmFBWTRDSTRlUUg3Mlg1ZUhpZ09nTlZDdCtvR1c4bnpYVFJLbkRnMUFzaitoTlBLR0tlUnBjWUtVQ1cxM2xMTXRQSWZIU241bVB2SXFwVWE0Qm9HcXgvVmZjaEhuc0JOb0IxVW5HOVVHbWUvbHVQb2hQejFqZzRjS25wN2lGNGZjK2wwa2E2c05FcnVuTzFWYzlKUWlZZGwyMDlCeWE5TDZBYXNyS3ROL2F5SzIrcEJKY1hoRDdGTGxXRkxCWUpSRGh0cUFLVmhhb0JuV1ZKTUxhdTJQUHFzaVBoWlVYUFN2ZDYyWXdNcmo5Uk1yMWIzRENpT2tqWGFxUS9IU1lJVTdFTm5jdEtWeXcwY2t3QTRJc1RSaVdoRUZEa0tuaWVmZk1HZ0V3VnhXcTlESHVyamx0RWFYVzRqcnlISG01VkQ1QnQ5UU9kbUN3RUZpbCtqVkFKbTRUU2grbit1MkdzKy9sN3dsNnd6MnE4N2k1Z1MwNDl2VldiRE1wMTFWcjBHcURFSXYwdmFvelN0Ly9sQS91SXV4Nyt5aTRWSVRnclVHZm5YMzBvOFh5R0lUUGFuVmxjNUtaYlVsQi9HeXVLZ1JUSFY4bDNxQnl6UVNwYWsremY4c2MrMXhSN1lUQTVnTE80c29Uc2xPUEhUTFRtK3E0Zmp6UmVYU0xab3lNcWtkSFBRLysvTGFTNW5sdjdYRzNYM2xQQ2FJa0MvYnA5cG02Q1RyOVE2RUhXZ0xEdHlLdlpXZzhEdkw5Qjg1YmhBbXBXZEpzTjdJcDk0UUgySXN3UVhFZXBsRUhUQVZLeUMxd2dDcTgvYnhMUmtna1pUekVvUEZSNnUrNXdHbUszMjlzd01pRVRSQUxSd3Bzd0FkRnI1SlAyMFhiRkNXV3JoU0ZyaENIcFRDNENMdHpkdHBnOGp1cm5BSmNIZkNNN0laQnpldWtxL1JQTW5jZm43ckg5QmxNSlRNTy8yRUoyMVhmc1BTVVd0Q3VTdWJmMXVISXVvYXFkVU43a2c0QWYwdWgyM2ZuZGNrb0ZqZ0ZxMU40WVVoY2MwSjIxWEdjY1A2UnZwS2ZJRmxpWlZqMVNhRUw4SzB4TUJyZ2gyb2VnK0VJd3B0dncvZ3BscXFpZHRDQVVtcHJKVUR0bVNJYTBVZTNJSVZ5d3c2eHBtakxqN013VEZGOUFZenRDOHdoMzhJTVBKeFZTL1lnUFA1MFZBaWZDL2xwb2tBcjhDcS82QUp2QUZkLy9KT2g0MlQ0UE00RFR4cytiU1Y3NG45dFVQQy9TRGwzRFZWcEc3NWo3QUhpUld6VkRqWDNlenRuem0vN2thRUpwbUVWaG5ia1gybjFxKzVIeVYvYTZiMGJydnViZnU5emRLOFpkSWNJOXJvRWxMKzRoellPMzFOaitlMXJLNW41K09BZkE5TW5vbFYrZDFsMzRDQUVlczhzd0RXRWRrOXUrRlFGTW96WlVkN3A1N3FCalRsZ1VEQVNoTzNOb2ZscWtLVzZ2endMN0UwNENqc1dLZFVSQU1jTWI3T2g0Syt2SnVlZlBKRXZZTC81S0E1cHhkUFpGcHdrU0Z6Q2ZzMWRJTnBmZkdFYnQxS1NIMTI2eWFUdWlteEliSTIvYzFPTGEzNi9LZ2ZvN202WVdiOTAzcUxSUGVEREFZbXp4SGg3cU9GOVE3S3k3VGFQeFFnQ2xRMVVNRXhTcjlrb1JrWVNMVlRZTEs5NUxBYWZCODh1QjlEeUY0QUM0RHkvbDJRaklYeEpwcS8zQ0E1Q3NHbDF5dVQyQXZKcjg4WkIyeWhxS0VjU3piVkZnbFYzQ2ZjdjYrNThhZWFaTzdDMzJLMy9NQTBoZEZBQk1ONlRnRHg5TzNKN0t6L0RvQUlCWUhuWEZkc3hudWxhbFpqMHZ2RkFTenpSZWJlM2RkM3dxQ2QyR2s4MWpieVNzcGZxNUxCVUlJSmUzMURRdkNXYkJaOXZDM0o2SStldUxvd01HMTRpSi9NdzV6MURwbUc5Mk5BaHRQVlBQeC9ucVJ0bGpWeXR5N1doQVNBNnBCNGhyYm9jNFF6ajVwR0s2ODhsVE9Yb0cxalVLWUxPU0VOaWtGMmI3UDV1aE9zblhlc3k2VjFZcUZLWmlyS1hqbzg5d2V2ZE1yUjFtK0ZqcHhkejBua3RJczRvL1c2SnQ3ajluMTJyTnNpNWtiY2pKUmUxczRKbFZEM0RlWVZ0Z0tMRkI3cnJDZ3JMMHI3ekRZTGIvZU9OY3dYRngvZmdQVldZWlQvVG1qY0wvL1ZmSnEzYzNha3hIMUNSQVpkaXNPcGd1WHR6alNUZktjcDBiR2dGeWJQeEw5bU9YdG11Wis1YVRUQ0l0d0dtZzZQb3M5V1ZBbUM5Ly9UL0M3OTR6QkZpN3lqOTRjMERSaDEvN2FObWJ2Smp2NzROaXpoR2ZxblZSdWY4VHg3NC9kMjBwMUpsNTRzRERRUEtsOFQybkRhSTd2ZnpUc001QTV3MkR1UVpMWXJHd2hQcTdsMHZta0VzckVMdkVTQnUvaDE2QzcxZ1d6YmlxV3k0bU1aSDUzWi9LZVZVUlViVnZkRWFFbUE1K2FicDNMRDlES0tWUlZVSlJsZGpZY3pVbGdMVXJtWm1wMitnNmVFM0xjNFBaMHFjY3dndk1FUlNSTWJQVlQ2aDNNRXdhc1lWTnUzckxKNnNCdVcwMGdrNWc4cUY2MGE0enRwa0EwSzBPRitPYnIvL0RCcURxck00YjBtZXBFbnhZdTJ0OHozZ2Vqc1QxR2FXV3gvS3prSFZOL05MQldhUVNpQlJWZnBZL0J0V3ZHTFg5SzZoSjNDZFJWbHlUeFl5anNFVjZ6bGt5b0djUGtCOWpseVliSHJHWHJLOStFcnpXMDhpUjdsT2RuN2lKeXNVNDUvYTkrZXlVdCsxVU9oYVpGajJVT3NsdVl6S09EVEF1SXlYS3QrdTk3ZlRTaFZ0VHJsejZUV0FZQ0VXL1l5cTdscU5PdCt2Q1lYaXl2TnNTWUh6MGNaSm44SGJ0OFRJZDNoQk4vZmhOU0pJeVdxUFlrQmNUeFVSVjU3OEZWcklrekdoWXNVZ1Bsb1VZZzliSHR5T0NpQWV5RS9SV1dOUWhuNXdWOWlCWW5acVRURXVEc0ovYnNzRjBITjlpZTRYR0RCc05xM2JsM0xPR2MyZXk3QmllT0NVaEUyeG5peXQwM1RoU254aUg5bS9mc0xvUFVWeDJpR2haa0VPVW96WXdYanROZTdEcTg2NkpyYUo1U1FCUm1ENzd5d2lpV3BJeDY0a2RHcmk5Nis0bXBkWWxLUkkrc2ZmVmRGZGlydnVKVTNwdnlwNmRuSmlqUmIxZGNLdUNEaVBqMHBQLy9UL2Z6Q0hhdzN1ZmlZcGFqekpqRGtpQUhrS3A2djN4dHJLNzMwMW1CRjlsMURQazNXbE5kc2dJWkJ1YTZDTkZFYzdpbzQ1alhRa1BCVGplakw3OFM3OFpNYXZnbnBQMVAwOGNEL01ibmROcm4xb2JPYVVZQjlTVWdnSEdNSzJhNGpEdHcrRFlVYVdOZWw0TUJJRzRpL3RVRmdUZlFPZVIraERvSTJoeXdpcEp5Uk1xZ25FVzB5RHY4OVdzY0wxeCtpNndJeEhLTDVNSHh5MjlRWFNVa3ZEclE4TTM3Tm1RZVp4L2U2UThraHpRTEVDVjdzdHVCYmFmL0N0clRObjg4RisrTWo4dlozMWlwMitING90K1EzMG5FcVlyQWt3SXMvMjUxZ1hRN0VRMGpKV3U4d0hWcDd4V3BwR0syZ1ZvaFRjeksxWnoyTmZ4S3I1SzJwNjhVYjk4MktZMTQxWG5CT0E3NkQ2OUhTSGJyZHBkU2lzRnNpQVQ0ZHRBYzA4OFFBUXJPMEJPaSs5eitIRkR5cE5JTXRhUDlVZTlvZlNNTlpKOHFPZTVRSTFNRGdFZ1BJTDJBb1NJKzVvVnJTcE4wdGhQb0VMcDZaTTBPL3pLRHpPbVBmbkdUZDdJUkQvRndIdjJTWnNMaCtGQUZ2VGNBamxtZVkwY1RWWHBpbHJKenhZb21PWjdZMi80bFdWOGg5WE1CdURQd0ZMZWdhdFpvcVYvL1BpWnFIbjg3UWJrK0pRR05qYzYyV0hnMnlsYkRwSHR2cStMSWRQSk43TVIzemlGN2YvL0t6cmpvRFRTUE84M29PQzBKZ3N5aWlGek9XeUpvVnB5Z3ExMEFoTVBDYXN1MFIyTlkwak03cndvQmh4TVppVXRkb0FOTDZMamVNUzVtWlNWOExxcFNqVU5BdFBxamhFakdSaTloUFZ5bHNPOFpoTTNTY1hKMXN4NUNUZXh6dHJ6M1hkcmF0YTM4ajc3ZjZwU3FYVFR6L1A3ZmIrZno0N213ZjVYZjkwZVAzaUVESDI1ZTBGbkxsaGR6ckluWC9TU2lXd1dZMThaQUpuZU1yQUlPZk9DSFl4eG9OcnNHc0RYWjAwR2UwTVdnMEN2clJkOWUxV09jR1k1dC9iZk12YmVyQUx0cTBoMzJrbndNVnBlYjZIUXRwcThLU1c0TU9MOURXb3RHMFQxY1Z1bnNDMW5wcUpxc0wzZFFtcHVmOThIeHVTZEkyOUp6RldsR0RoK1B6Um53TndCSE9hZWdWSXQvbVo1OTROY3NaSU85Y2gzRS9pNmVUcmRtOXk3dVhKbXZLS0ZWS1l5ZWliZGdxemE5U2dFOXo3bzVYUFV1MlNCQVVIUFhLTzlWZ0t5aFpqdGJKTkU5Q3crZjJLOHJKMFBJWkJYNVpPRHN2UFVZekVsNkRUT2ZBOVlzSm1LL3VOdHh5amdTREtobmF6YVMxNkFMS1lIOGY5MWlEQjM0NmttODZwUzZyeVVLWitUWkFXNklWS0R1NjdNK3B3K0E4TzdLTGxWek14OFkwVm9TWXMzNFRic21YSk1kRXhXNnlybWpERy9sOTVOcEpxQ2NEamtpaTc0SnM4YVVpbjEwamNyZ3N5QnBLelZ3b3pTVWo4YzB5Njh4ay92cVovRkhaK2tKYzZXUEs4K3JqVFJmdUNqTnJSQkxENzBvN1BkOCs5L3pWN2FuV2xLYzVUQ2JqVGJ0cVdiNGx6Rlk4ZDh6MVpyV3FjOHIvNzZMM1VpZDJkaEZQb1dMZkxNTS9lcm9NeUhZd2UrRzUzMUJ2OXpON01pSU1zdWlSaDZDZVFDcnEwZnZhRmJmdTlYL3hSSWlpNi9VU0x3VGVXT0c0VUFNcEVYd1h0a1ZKRGNkbVdFTWEvMWF2ajFzSXdxQ2VwR0gzMiswdXY2YTFZdWNnUzQwK25veFVlTWpjWGZaNi80L3BUMUg2OGdnd0VFa2FlUkpXSjZHY1VxVDF6S1ZVS3JBWGpwK2lvWGU0RG9Tc25xUTlXREE1MFg5TUZJKzJKOHJxd3J6WEhBUnkvKzVadnkzT3FWbGhPczc3ajVFMlFTeWUxR1pLTWZmSnViWlJuN3Y2S0Z4cjRmZjNrckZ0eFdERm5zY3BUN01FMDJSU2NXTU1yVGdhaFZBQUFnQUVsRVFWVDUxbE1KWmlTRTNpeEo3QWM2b3NLeGZ3MXNPd1FsWldxR0dVNkxaWGlTcDBvOXh3cWpic3Q3VFhBaUdTeVVHRlZ3Q0dqbklJZU15c2VtUTFnQmxlWjh2aU1rSndpNnJFOSs0aFpNUXpJU2FJT21sOEhzUVc4bEN3NnE4V290b3ZjWFIrZWRiLzljUFZ4SHNubHpxK3VSMjJyMFJVNndOYkVleDFYc2huQjNac1I0cTBnRDFYWU1wVUJhUjBxQlc0MmJPZUJPcnUyTTNFSEhwWndBVjNFM29FWUcyd044V0xwQk9vUU9JQUZyK3I5MkkwbE8vKzVPWHRvZzZmOGFmMllsc3oxSGYvTVorWEtKUGJ6VUhYcXptZGdQNE9jQXVZWWh3NnRnTkkrZFg2WVNCVHM0WVF4MFRTV2xCakNhZ05LNTN3ZVNsYzJmLzNkQUgwOUsxK3RKZnFOTk5rcUdpZ0dkbXZ5N3VPcGh2bHE2Z1pOTzh2dHFQWU1YSUlhcFV6R1VqUVkvYlNpVTczeThzTWJ6K1lNQWNSRHZ5TnZCczhuS0Q4bTV3V3lPZDl4dnFiK01aeGg4WEdwNDVtOFVkTXVIeXhmV0c5U0FKZWxETW9TVVFuLzlWV09NWWpuQW01d0lMQzRWbEUwRTJ2NXUrRkUxRmZaemRTRjI4TmphbE8yQ3ZEeGx2QU8rTm9JcHRiY2I5SkZQTVMyUXNIR2ZQWXppMC9kYWZYckRXUzFOWERsTG5zNFZ1a0FuTXVpbU1IMW5qU3JuOTM0bFZHd0tTKzlJZ0RNSzZKOWhUQnpwR0tLN1ZqTWJ6d1JpdjdBWG8rc1ZERHljTzA0SnYvMHpsYTNCSkFySUg5ZW9VWkRnYk01dkw1QTlwMld3b1FiYzVJT1lUNzc3SHZpUHpZQ0RpRWlXcmNFdi9Ud3I4RHd6UWRoR2x6UXVGclg2MXFUdnEySEQyckNYcE9MUGoxNWtOWEw0eFhRWmNTc3NQVWU0SU9mRHNoTDliNy9uQTBVRDA4ai9xSHIyMENaNUtXcnBONWk4RUg5RXJBOFJTbmhVUnN0RzViSVIxeklzMjQrNHJUQjVDWkR2L0c3dGFBTG8wQlhZWk9BZGlVWTREb0JZSXMzRkg4SnhJN0hTeDJJKzZMYXZhdEpKSnVHc1drblpKS29IRGxFSFhPNVpseUcxTDloZHU2SnhCaC9Gbk51dUtORnBYSEFaOGkyMkdXV25NY3ZPeUJJcXdMeEZrS0w4VTNzNHA1VG9HVEhnZEUyNHd6RWUyUUdaN1I5M052S3lWOUhwZXhOZnZzYXo4UDZuQy9JVjRzVGNxa2ROYVI0S3lrdmN5N1RSVnljZVpyQWlZdUFIRmZUMlgwWVh1RFY4THVWZ3psekRyNVZkTlRndkxrY0R6cmIybGd5THJFcnJ0ZUlabmF3VzNoUHpOUm96dkZPYm9UZUh0cHEwaVczMTE4NDhwbGwxeUwwRkVCS2oxSjMvVmlzSE5XUUNDTGVGRUJDVi8rWXpqOG9zV0twS3JVQ3l4THNKMmRpeUxvUEw5MzZaM3FmeXFIT3ZubUJMVXNKM0lkQm5iZFAza3E2djV1b3dDM003cTcwOG9rUGwyS0dMZmxHMURBSmZpc3B6RlE3Q1o4aGJBVG5JK0M4TkZ4Sy8vbDNsVUJ2bVVMSUkrbzlYQjBrcWJLQlNBRFl2YUZmU0syUGxPbkNxMExiNXUzaGFqVHgvblVuVGc4bm9tNElaSFJheEtOS1Q4VXVvYVpDUU15eEcyTHArVHkxc3NXS2I0WmdNOVJJMWJXTFIxaWdrMm5acHNieHpWMUdoVXB5cWZMMzB6VDArL1Z2eSs3NUVWd1ZrZEFIL0VBRFZ0UHJDSEZ0b1BpNmVja0JZODIrc09ZejhkbTZMQ1JnNWZibSszc3I4RTZRYVBINXAzK0NwSjRzMlEyMy9aMkNMR2RudUV3cllBS0MwSDF4TDBrdjhGSXNXaGpQQm45d05aMUNHYWtmRjNCQ0JuRlBRTzcrNm4wNTB0YUZNcXd6cEROZHREMUQ2R0RmVEtBb25ITThlSzBkKzB3QzVWdUJHcE94cTBGYWhVdDB0T2Vja1pPT051RXRDdFU0NTN0bGQraGJGQjZLZWJBZEpBd1dvUXBlQnBzRjVCS2tzbmV5NzRoeEh2UFEraUhDNlAvL0IyV0pkZUs5cXF2RDFjak80MDBpcEdKcVNWa3FlTytmRHNwcThmU3J5a3N4ejBoeFV0TWM0ZVJDTFhkb3FBSVVmQTQwV0hiTytmTjFRZEZtUGZDUUdVVWtkNzhVTzBiV3JRSndLOElmQW1GVVF3Qy9yZGY0ODVFQnNZWW5ZZy92WWtrWm1kR29ySjlUaTlUVlVjVC9xTjB6ZWJQdjFqemxsQXcrYWx0RWpraVZ3QnlWYmFsOGlDVVdlQld4aTlaQWhML3FUWExXdjlOTGhMQ3lYK1ZOQTR6ZHhzaXlRTitLdnFaVDRRTHZlSEFQS09TOXNrN0FweEhyaDF6OU1LUUMyUEllWjZkTHlYSkhJZXdXbHJWQjdTZnpKNWtDR2ladkNpY2dkeW52Qk1MdDNVOE9lQXArZjVXTXBSQjdDeHlHV21Pb1VkYkVFTWVDbWdtVm1WdGJEcng1cVFwRGtDbWI4TCtCVGwrZzRjN2ROKzdsWWJWWmRIMll1NkIrbTY3TTlKN0twaFNrNzN2LzZYbUIvZVAyMzJYb281SDcvdkJGc05DMlFHOUdQZW0ydk4yaDhJQWpxZURMT0o5b1YzSmZIWVJLdDNhVkFVMXRpR2Z0cHVHcFp1akNHTmc0dlNIWExIS1dVaFlrSFZmbHVuZGxNdXRlQ21qQUNyUUtucGN5UEEzK0RMNlNXakdtN2wwNW5uckRjcWR4L2p3NlVzdEV1Q1JCYkQxUFFGT21rK1l5ZVFSWmxJcU83ZDAzY1RDMDh2MTM5ejdkdThHb3dZekpIRzE0ZkJjNDB5UUNsazg3V3FDcC9iT2ZxM2RIc0ttUnEzbjd3TXQwTXJKUDhCN2crUjF2K3JUekNHZ1BmbEJodjNJMGM4SCs3RDZqWW1kSVNBSllPemtVTGx0Zmw5YXFIT3prQ3ZRN1J2VUh6a1ROSEdwTGl0SGQwWDVXUDB3MHFQWkI4V2VwRFNwV2p6ajZjcnJ5ckRDY0FYUjZKT0ZuLytVWmZ4cHFqMnd1ZVRTOC9odER2Rnh6c0EwV0tWWmQvME5Nbk5iOXBoUE5aZlZIVEZuTjQ2d05YNlM4SnRDU1d5VzM5MnhsSWwvdmV5YlJQZnZobHhiWFh3QTlwc241Yk5wL3E1RGRDSGtNZnd1WHd3VDBOK3JCYUdyMDVydnZBSnc2R2MrVEl3YmVtU2tzTVFzeWkxb2JSMUppMmdOYzNyRy82cHhJRmdwOHZMd1l5RVhxSTdWV0NUTEpsc0dva3BZaXRyZmpCcDVjUHdXYlFQQ3N0K1JwenRoYlhqZ2ZqbXFjWlRvK3MxTTM0bXhyWTBYNjAweVlETmpPQmFjcFR0VUhCM1AzR21ISy80ZGhQWjNVaEFuc1RTWWNXNlZBMzdPMVVyamNpSDhjVk0wRGFqdElySXJ0SW5XVjdEVDFXWU9CWlBFNlFZblRnZDNNb3A5M1IvV1R0NDJkSU9Cdzc5QXMwMU1Kd0ZDSDdwSnV1VDl2QjVqbG56M3dESDdnSnU3WHRkRVF2bGpIQjFuelJ1Nnh5MXd5dVZLMmxPM3RKemF4SS9hUVA4UjFXb3FsVUt6ZmxLTktRcWpXT0FWb0ZtNGM1VlByRjIxSnRkeVNSM0c4Yk5wQ0xRS2tnRkJJNXlKSk5vUzFtSDBwZFl5aGJKTFVlN2ZLTHhPSTZ2dTIzSGRwa0x4ZVNBVGRHb204d1N6Y24rdEZGRk1abkRaWUluS21iTmR0am9GejJtcGZOTThRM296ZWVzVWRxa29qK29HZXpZQVY5V1JvWXVqVDBhaFZrN3U4NjhFQ09GaXIyaFZvNWJhUGdJVUZuZ0pCaDZ2STVUcjlXZHdVbVJvZkRTTzUwV2pjeWwyWWFENUIyL01YdlBaa1NmKzZueURLdnloOUQvbmd5WGZvZDhwcTdsTE9vUGRNYVUyWWVVZHV6UW93ZlBGMVJRMWhJSCtLN1Q4WndUNnU2ZkszNWFYNGQ1R2YySGtIWkp3THpLUDRLM1NpWnhOU1Bab0J1WlZyQ3Vjb2loQTQ1YjJzV1VKSzRubm5waHFjUGVZUzc0YTZkdzRDOVdkc2YwcGprR1ptNTNkbTNmTXRTVkEyR3FqV1paeVptQ285cm5KNy8rTUI1S2Izcm0wcXU4UUJBUThsZTI5WEpob0VCNThHWmVlQkRWYkU0Z0ZxWDZ3Qi93OFpjMlRRYVMrZWVBczhPV1NJRFhpaEtxUFE3Q1owZkVNdHphcWEvVnU2b2tjbExvZXNTUkFPc3l4Q1Q4RHpWU1RjbUxwWWE3M2dmdWF6YytUODBmMXV1MFVtR3JuTlUwVTNvZzM2TGJBYXdTZnJxVTRrK3IvT21XcUpHRHR1bDZQWmxCamc5R2E2eDdXalY0ZSs0SUdXRkZZalFaQTJMQU4zMWhIdWhLSEYxZlJkbXpZN3hlaWE3OElIS1hhMkZZZGVGbVROZzRYSGJiUkhnWndPNUFSUHBZUlpxdjltQkJieitvQW5nZjlCMWxLWkFZUUZ2Q3djTEpJbTVvb0ovR0FBSDlySzM3N2Y2OHplUlFRSUM0RXJVM1d3aFB6OEVVTmt2RDltblhra3JOaTNKZzFXVE41b0VEZmJVRi8xVTlHM3NpcUtXMksvVGZXamNyc0xCY0ZxcmVYMzBhZ1pJdVNjdWw3ODRzRUF1UUtsdkFNZm05c1I4TURRT3B4WjBnTS94UXlCYm40V2RkaWtaUGUwWG5RYW1WeUVzSlh1T1VxNjlBS1l1R0RIaDFuZVIwa1gwNWk5MXl6SHlZeExFZHJiSFFZY2NGQUpEN2JPeU04UlJHaWZBd29HKytJTzhTRVBmcXdyaGkrUWR5SWZtR0Z5dlY3THdqR215ZTZETWJsUXU3cWpXcE0yVkI5eWRxb1orUXpBUEFDdTdWd0NvV1NWVjZQZUIrZElXSkphS0tpTTVnUEVRdC9RK0FCU0VQQzJRKzBrR1VGeHpBVjRHaWtQL2N0dnZZYjNlR1k0ejdmanM4eWVFb1RNSHRSSlhWOE1MWVo1eFlDblFtM0tqNFlSbms4a0YyWk1IdDhDWVgvcDdxcXJDdU1DWTdzNHJRUnY5Rnp0R2RVaCtLTnN5L0lYcVNDazJZQUJIVFNhNkJmSkdzZEZuVk0vYWFzSjRoenBhcUpUWUhCd3k4K2JyNWVuZElwV3pCVkJpa0dDN0MyMUtpNVJMTGc2NWJoMEgvUGNZSm8rZUdwTm1RY1l1QTdhaFl0d0hySE53MnNFWXc2SENOSWRZSDVVYWt5ZGU3U2JZQ09NRnNVTGl2ZDhEOFNQSDRkcXgwR2tPdVJCZnNIcGVkTklKTW03QitHUk9QYWxpWWo0WkJMTG5oanpPR1JkMjMwTmVXamJQZzlFdnlaWmFzMzQzQ2ZaMUE0YndsYjYxWnVnRTNrOE5qc2ZOMXdSSENhVFlqd0NBRzNyWmdJeTlRZWM3bWVvVlJ2YytPMUpwa0xDTjBYNThpa3k5UXZ6Q3p3ZkJ2N3l3WWZPZC83Y09HMEFVYXRhVGxCOC9uZjZDeU1LZDdOV2FOc2RqYU5TY295NjFuZDY1c0JQb0tuMnhCMjhka3pqZGV0M2VMc1FjcHBzbEJNdHpjNDZrMTBCUjY5cFl2U2RyYklVUjVPQkwyMUJWL1JrUVR3amhnYXJvTmN1U1BaOHQyNlBSempkKzVaSk43NTdMZ3hBY291cGJ3bWt1aytvRmhsb2dRNHpvOUoyZ2ljK3Y2QUVrc1FYMkNpd3RPbGFtd0dZcCt3OUtvbUxpclZXUUJScjI1b1ZNM0ZsQUlZa3pmeWhoZ3NXYzZ2d25KeWYvZUdNMi9VQUlMb3l0RVJ2Q0s4QnhBbVBndEVETWdoRnZYbEJqQXVtemMybzBESDZvQVlzZnd4YUE4cEhiQTRvMzBrZGljeUNvMFZIZHQydXFOZ0FQTnMyYzBZZ3BtTW9mNEZWWEhQSDZQN2xmVEJjVjNPTUh5UjRUQkV0dndiNFZKRm1CRVV4TXR1Y1dpSWo0WSttYXljOUxsd1lXZFRKQk0wVUE0SktyVHIzTHUxRWFLUGpMZGtBM3dpVXdPdnBLWHRaaG5FbTRMZXg4eVpFbFl0Wm9ibUh2UGoxVGZjVkJsNHB6UG52TDdKd2dYL3BOa0JDRWpWYnl6cm5wa0lPSzh6ZTZXUG5DZ2oreC9mcjh3cDB6amxUS3hNbDVMQzgxcHJBd2pTU3ljTytzdWYrSFFsRlBLVnRua0NXakF4V25FZlNUcjY0YmpHSmVWeTZwMWtHNVN2Z2NLWXhSSE5MaC9ITGwvVG04RDlFRFVtQk9FSDR5cnA5SG5mK3gydVlQQmlBNkFnOEd0TzIyYzBZQ2hXcTNKeFQ0UkNFU2hGazV1TGZrUUZ6OXFPTm5oVFovems2TytSbjhZSzJCL080TjF5NXZJbHNvNDQyM3E3ak04UWsxNStZbUxQK2pueVFjVXoyKyt1a1ZVSEJhRmRyTCttQmVINUdPU1BvUTIvSjYrUllsZFZiVHY3dDQrTTNTbUZ2dmZZcHNTTU55RUdZQWFQbFFmelA0TEVpZzIySk9rb1M0YmZBWms2b3A4NUdMMHo4SUFOc0VGUjhvVmZWMi8yMkMwZ2x3a2VELzBhZDFqSXJJUHNvUzQyRG1Wcm0xUmNBMGJoQmpYeWpnWHBNWlUwOU9nNUJsbXA2Ukpuc0ZiVW5mWUx0SnBJQXFLOERkekZhUE1Wd3VmdmFaNUYxZTc3YmRYVkZBZ1k4cTBJNkhIUHozeDhQQjltcUpzZGlXam1XbUdDSDd4QXNhK2VoaXBsRTZ1V1d3eElLQ085TG5GZjJaSVRBRitJNUcrV0VaeENuNXFLQ0dvY2c1YTJ3WXlSenFvK0Npa2EwZzBZdHROa29kbExGa0NIdzBHUTVnYjJjYUlSUU00Q04raFhXV3hkNE56WnU1UGRaUDAwZS9RMEc3QnpOUk1GMTZTdGVzR3prRldMZGpPMUJ1QUM5RXh4cnNneHF4WkNFMkhHd3ZSSU91RVp6b2dZOTNBWDQyNzlzUVAvOEZiR3kzQVprVjRNYVpJSjlPQXVXem4zeWJSamdLWCtNd3lDMnBsb3ZnNU9GMk1QVWVCWTFlQi9zdlYyUGd2TG9sSFUyMFRWc3ZOYTgzZkdsNDQ2MVVRd2RRTlhBdW44QXZvWHhKZTJzT3dKV1lNS3RiTEtVelFScTFPR1BHZ2FudnBJK0I4dG13ci9Ya1hYekFNT1Y4T3hmbUJDRFBIQkx0ZHZabGZHOFU1cEk5NGVnUmtRT0FxTmNkWHJvdW9EWlU3MVg0RUFJQmFmNFd6VThEckw0bHUxUkxNQXorNjlmTGtweTdON014UytYWHJ6Nks5U0VvLy8zVzZuOG9sRXZzTzEyVWRHYlAweWo5MW82RXZHUDQ4RHFEUXQ3OWViS2pnV2QrNFhyVFBmR01tVDNES3hUR09FSWlabjFwYU0xSUdMWVhISWdZeml5RzVtVzhPVUZGVU1PcHB1cFVRS3VRTENkdFdKZW9vNDdSVFBQRXJBVW9ZY09jUjhEcnRhcmtVKzF1WGE3Q2FsZEtYb1NWTXVUNHhOejlYeDkwaDgxdUJGRlVBQ0VQSjB3SjRtMm03VHVsRXpmV1ZxUHpXaUZwczRHUXdTVE1ubUlDRnFwRFV0d01tRTh6c3ljVTVxcWZxYXUvYXJkVGxJa2JveUJUcVQzaWREOXVPblFTakZURG5UbGFJb3lOZmFiMHFLMUVESHRuMVFBWjErdHNqWEFqMmVocmhnVDdaNzFuMFc3NDNvRDhwemRnM2haWGRKRlRHR1hyWlVJK1JmR0RRZzlwTjlpWTQvMmN4bHdIek1Jc1l1T3lZc2JDVU0wa0c2UTJCWGxXUmRQSytOZHNVRDZqVitnS3NnOC9IV3duNTlHakxVci9maGdFaEM3QUZ4RGVBbG1OOGcwaVVKRTk4bk03cnE0VmM5cmRleDA5WG5pOTFLZUM5cFFGUElCMTFQV1hMdlFaSGs0VVBoblhrUnp3K29PaE96Mmlubkx3Smk2TDlZOFc5QWxtcmVFRjFuU0ZaUHVGbGdHNUFjWDFIa0xKNFBQd3ZqbkpjMEJvOWt6MFVaMzdTUk9zZFlTcDRKa3ViR3A3L29SR2I4c0g3NEkwYUZwb0hOWWhHZGxhdW1aUHJHK25sZ2E0N0prOFBaZTl5MmNrYnZNQ3NKOWNlKy94MWlqbFpSdFhqY25oOTJQdUoydXRlKzFuS1d6cTVCc3ZEM1lqUHNOemxyd0ZvdUxnaUZqSEhsNFdBaUhFOEFNRWRPd2ZuVGtkMlRjQjBxUUFYVW13aEFsWDJrRDFCZ3hoNC9OYjMzeEYwT0ZJT3hldTRVSzlOWW9JaG1HRVFoWVJ3RE1MS1NWcmY1QWs0aTI5dHFFa1lyYVFIZ0lRaUpianBzMUl6YWx5RThGSjlxVFhJbkpaZTc3TkZQNkRHZ0ZCVDdWaGRoalVhc0pkWmZnQStGNnJHQ0F5emoyUy8vakNZdzArelhHK0ExRkdoYS9tY01GS2FSSVFDS2tGOHpjU2lFazFzK1gzd2R1MEx3V2dZM09TY3hQSG5nUStRWE05ZHNSd0o5MzREQXB6K3BCaFlLZWxQQTZndEJ4Uk1HRWRlU0k3b1dyMERNUERCTTNiL2grcmp5bXpkZXN4ZlpBTWtyUDRweGdpY3NrTm9IU21CcmZMMWUrNzNWNklHRktSNzduNFV1bnRIcjh5Mm9kMlNEWWx4Vk5aQldlZ0diUzhhRitwRSt3eElKMnNqb3lKdGd5YncvWGtJc0p6d3hRdGdta2h1S1RmdjFnMmpyS0lvc1V5YUU0VzFtVXE3MDVWVDQ3cnJkaTJ4K084dVEwZ09ZMEhBcTI0aFdDR0cxeVNlSTh4ek9uTlppMnU5Q3FJZUdsTjcyMXZ1OGRPWkgxdmRNa3p5OUZmcFAzNkpWS1RCUzNiVVliamRDWEszUmNXbUZwS0JjR1ZEV1NnKzI4cG0zUGtBbjdhbjdjdm9QNFlpVjZXVStGNHU2YXRHdVhjaklNWStBcWZPMkU2YXFlUkRUSkppYTdGQ2ZoWkNIUzB1a1pJQUtVRWNXOFBhUnM5dXBrWHVpWXdPcUY1RnR3TEpGWUVoYW1tZjlkZUNQSWUreTFkMG8wWTFaWkxZamdoMWlaZ1NCZVBMRFphdDZITmlHVUtoQnlKQmJNNkZhc0RzS3BXV29JaytteklsSU9zeGhraGlVVGllSDlueGFiNVpackNDUGFxYW1QN3Vrd0VUdHhCT05VSnNqMmdzR0pLU2pENjNwdWRrUEI1bmpkU3U3VmZ0VmJPK0FSYzUrZDNqNlVTWDA3V0tNaVM0KzV5b2dZNGpUejlvM2ZKczBHblhlY1hHRHR5aWNjZUFscHNOZFJ1Um5vSDZranQyM2VWMDh0Z0kraGJhU1NaVWN2UVlpcEVudEpaRmNEa092a3UyRk1JaURqaHg5ay92ZG1GMHMyd0Y0dkVqT0p6MEhaV0ZldTlWVk1ZNmhTUXc4SzI0SnVqcFc3aHBSMlp4OEgrVTBCRDJoRlNrT2RiOWxuMC9za0owdjJvbFdCcXV1LzNBQTlzRXdvUDgxeGN5MW9Rb0lJM0hHdi91a1dFM2dyTitvM2RmeUFNdFFHelE0UFBjMWRKd0hrcVNGTndyWXZ6ZDgrd0xvZ3UrRFBaKzRJdkV4aWJ2N1h5UWUwMU90RDl1OU0raE5QWmtVRkxnclo2MEZZdmE3UFF3YUtTMjJvOVN5MFRISi9vMFlWb0dXWGtxSHQxb1U3blJCUDVMNGNHWWlFN0w4dkVjRnJLak9vNTg3dGFxblBSMjdWUCtWN2UxWHZueDM0d1Z1N21TbTdjbG8rNEtlYzFjRGRqc1pITXJoUnNCSmRlclZIeXN1NURGek4xM2FBWkhlaytvZGxZSEgzZW04MnJYTDBGazZXQXFMWmRLZGJpbm41V09rZW5nd3lxeGlKb0Zpb0d6WUp6RS9DK3dMbzErK3lOdnFhVldxWmsyY0FPWVVEdmRySzBuVDJKMlRuaTJGcVpTdGQrWmNKdU1pRjVrNlNkMlcvWTB4Z3lsb2hjUzZtY2VsdUVoRFNhaklHZkdiS3BtZzFtOExxejJpVy9PTTdmOHl3MjJGSjVYNVZtMFQ0WnM3cFo1SGN0NHpaRWtETW9MZmJoMVNjVU9sNTM5S1EralpTVFluOVR0UHY1T3BwaUxKTHpJd1d2ZzJoWEd0OWFZK1djNDY3WFpFTFRDQlEwS2xnTVBVZ2N0NS8vUDQ2ZTZGVkVSRDQydXBNVmpoNWY4d0p3NEhRMGF3ay9xTWp5azlZU3RMS2ltSFpHUEFPaGQ5SHZQaUEvTFZXRzVrWU5YSEhGZHVBc3UxNDdpN0hJL3RjUld4cnYxa3pGbHV5STRtREh5dC8vczJScm85NVJNTnd3MzZpVkE2U0xkKzVFOEdJNWFZbWR1U1kwOU1tVWVsd3hHN2ZnaGJPN1BtOGJXeUFQK1dib0VmQXJmN3hmS0grOUNxaW1VWmQwOGlScWFDenFmbExDUU1ydUJyZjJDSEJUU2t1K3ZwWFhjSlhCTWFMSVF6enB3SFRTdG1IRHFVd2trNmhHQVFPWDByZVhWVzNFWkU3WVduQS9xOXpPT213SDduRHpjS0M4bVZxTUs1QmNENm1HcWJPN2grV0o2eERZL20wNG9LdHBjSFJRU2picE5PeG5xZlQ0eGZ1R3VTdUVmaVp2clVHVnF3eCtYd1dnSnByRHlmS2JkM3JqT2NhZytEWWZNZXFrMG56RmlFUE13dDRwSHl3RWoyOGJ3SWdtWEJrVmdwSUtsSUNLVlNPa0R3NUx1dzJDK2lSTTVRMDZURTZqYzl6TWp1VFQ3OUVvZTllUTlod1JoRDY1WHpOdFBQUktsL1o2UVpqOExvRWw5OW1MaUljK0EvYVVra2RpamVKQmgzbmJ2cmFiam1BbUJUT0tOSEwwOFI1bEdNQ3JxeUpQV1dOZ2ZaNVRsejJiTUQyWUlVcmRQYkxlQjVvSFhxd1F4Zko2YlpIZC9ldFc4bUd0OVRKTEhlS3FRN01iVmRLRzAraDZ4cXRkTUJCd2hOaS92ZlRwYTJzUzJTNVl0a0V6bTJPNTArVnNYWVhtN0RuMTQ5SFJvVUIza2FhbTFSK08zQVpzc2lCN0dkd0hieEVOYjBkZmpKbUgvbk10N1UyM3l0TWpiUE5QL2sxeDFLVUhoZGh5SW16d1NmbTVoRC91ZnIyNzY5emVycnJuZzhKVDhCUTk1STZUK0xSR0tycjRaM3hXWHBZVkJXNmNZQXRBSU9KNFlYbS9BY3lid29iaGlEbzN3elRuQnBwdzgyS3doUmNlc0k1ZitTYnoxU1ZFSHhHRTYxS3VGU214bDF4U3JBR0VIK0dUSWxEZG14azVVckZ1Szd2cGZsVDg3YjlldGV3RE9RRXRGSHZpb0VmbWZuRGFLK3lBSFcrRDhxa1dPWFRvSWhqMlAveHhMdTJYZjNIeWZySU0vQ2o4NUM3ZzRzclFmUGNpeXlHWCtJN25iUFl1QU1ZMUFEcG9RbDFsTDNWZURQWTRzRTF1bUp6KzJxUGVOMTdQdnVJV3N2LzhUdWwvK1NtZW5haG5CNHNJMHNHZjJtU0tPbVMxYWlsNTRwVkFzcjZHUk1KV3o2YllzUFNiTWh0bXZQQmZFakV6Z3l6d0ZrOUFWRk1tSXdIaEJmeVlnNU5jWERYU1FWcWVtUkpXN1cxcGtnQjF6WVRHVkFOSTB1cDloVFNTMG1LMjJNekRIMnhDWnZpY28yYTJvUzlXOGMxa3lMVW02YzVmdHhhRDIwL0VYSFBqdUdOaXkzejFpZ24rVzVxcVVNWVZtRDlGUTNiSzJYR0ZIenNqVU5KbFYxRjlyNG1xSHN5aGJCNDRYekgwNWQ1c1FUbTNXTUJPWHpHcWJHWDlveU5uSzlNaDdMYlRmbVRWZWcyd3BZOW9VeUlpK1p5ZW1wTk1RamtHMm11dWl1SVQ4OG9wR3lDWjBiUlVMK2NaTHpaTUwxT2NhN1JSakJqRVU4d1JIa0NyNFQyOEFjcllNK28zd25zWTNMUEZVY2U4dG5idlFtYm9Nb09JenBKOURNU0lyaCtmQ0NRVGVkWUJZQ3lzL0xmTDY5eUYreGRYN3JxczdhMjRISzBac2NkS3I4YStKanpkOHVNMHNvd2ZpZHJyUHFudy9Bb3RYNFFBWndSUTRrSWR6SlJ6T2dLaWQrOHJUMm45NXh5RTVIenpvOENDcXJmbjRQLzhjeTRVVHJnZVhkTUZneFBaOHp0SHZ5bWJtSm1YNlp0UVlUVWkveXNCNHlkN2ZqeVBaSkJiaUZSYUVxclpNclJWcVBGRjNjaXMxOThSdmNiQUJoSklpUk5rYUp2TmN3bUZpbHBYZW5DL0VsZHpDdi9jNTZkL2RsSit5TFZCZE4vL0RmREtUTFpJelprd0lyUkI2Wm8ybWc2OTh5TWJpV2tGNGhtT0s1MFA5bkpEYzZHQkw5UUZxelc0NjR5eVNCQWc0ZjRLNTdhN0tUTTRqZUpnRnlrVFFFL0xpZWtya0QvaE1uQmgwOTEvLzIwZmNqUXZWNUhYVEV0bkdobG1EUG02WnZGOUlEaklTZVhiWUVSMlpXQVF3NDYxZWRkQkZrYWFFNExaRXNFc3R4TVQ3Q244dWJ2VE9CMVNVMmpCRlNDRnUvZEsyd1p1Ymh5YTh6QXR2Y0MxTUwyZGZLb0hDZVlobERTKzRHN3lJalp2REpteVJXZ0J1QUF3K1JnY1QwYjdZMlhIRWxsbForRU9tYTh1NnFNZ3JsQzU0S2NvcnFxcFZMblkyV1pRY1JWU1E3ZGtUQUpSSTBrL01JV3Yvc3YvSmxWQTNpM3YrUk5iU3VYb1N0blFzTlp0bnZmZUdmSUVNRm9HQ1JlRFo0ZHUybjFTRUV1Q3czOEVRd1VxL0VqSm5ETjFQS0VWdkduL09yejh1VVI4WmZwUEE4alJtekg3b2NKOS83Z0RBaEpKNlpQdkpEMXBaajFOY1JtY0hKQkw0S1pNSkg5QjJPSWxSZ0hjVkhRWnVGekw1cVZEQkNobmhWUzZoTUZHSldWNWFTNHBFY3N6NVI0VjE3bkZrQVlpMWRMOFhMMHJEVVB6NkMrUERvQTFOT1Y1bnRKN2ppdy9Td08rdnQ3QTZSRmUwSk93cUZjaHhjNUw4dTZxZFlhanB3L2V2SlpCNmtsRjdXWW5XVkI2L2ZYN1IyWll2a2tpZVAyell3dnlCTVcydmx5V28wZlBIN3lldGt0aUJMSUc5bUFib3VSWnlwRSsxYlFyY29QaHpNQnFKN2pQaDlxNk1qNHZCSzdVTW90a1FPSllaYWVMMnVSOHM0Tzcvc2dTWmlFeURDVlA3K1plWHVHbkRycjhUM21CTG1CSThDd28yYWdOSWxqSGdsMFNTT1h2VGZQMWdOdFlyeFJ3a3doQVRlSGtMRC9ZR3VsTDQxVXIvbUNYN2o3UlE5VUdHaGxaYlI5THdVbWxrckhLZThUSHlqV0pLUWFJVVFQSW1ZSlY1M2VsMHlqVy9XR2Z3ZWIzNVJjVm9PZllEL1p1a3VvNHdoL0xmQTJBbG9pcVZFTzg0VW9YeC9POEpvMGg4aXhVNHIxVGRyWStIc093OEdnK3NYZGVMNFFGY29tSmEzUlROWnFFSFJHeXBmS29ZNEFTVVBnQ3dmanFJZUJTQmhFT3RFM0t5TVNzbm8rcXlqMVZQTGV2WXB3TEhnTmZ0S05jZ1lpK0F4djlwdEZvdjRIOVcxSXBrT0hnWk0xNWpsZW41M1p3TURKRXROUExORzlBYW56blQ4YlRuNTFFUzZiaUtvWXhoT3R1dW1RaDlvTUlpWGRvRVJsMWZ2Zjl5enBaTVdoeVdDOW5ZdGEyQTJxeUViS0lDaGZTVm5GK3RwVnIwZWpEVkcrcmZxcU5QMHdodmJjOTN3Y2c0OER5OVJWRzlpQ1MzUTlFa3piN2liR3ZJVDNTT0hVcUhScW9TT0x1R2hoVVhrUGkvQkpaN3MzdGlSdHhMd0VHZ0QxYWZFNDZWTDB5TVc4WSs3a3EwR3JVMUZUOU1HOFFSd2NlODMwUGFGRnZYRDl3S0UrZDZVUVhpcHZ1RWM5b1RyYzA0eTZ2SVE3TWdjbDRxQXJSYTRFRFRWU1kyVGV1cTRzeFB2bUszeTJUbDN0K1pRNldnTUdmNDdCTjFmQ2xVUlptUFFYMmpIMTlGZGtlM2tscG5XclVjL084Tkh6OCtrZGljbjQzYTJLMFI3dmlLVFlDVFpjbnRScXFtQkdraUdKQkVBRHI0SnQyUDN3QUFBQ1hTVVJCVkNLUzc3c2x1eExvSlRrMzlOcWxUWWc4b3JwWGhRclk1a0lKVW14T2doZXQvTTV6cnpGZ3d1UjVhSnd1Zjg3VVhnUjArajlsQytWbzdjdEkwMm9zTGJTbHM4ZTQweGw1T3V5ZmVTUkdDME9ta21pMkN0WFYwNDNER2M3NVhVbTJLNEdCMzNTa3VMd0xpcjRkZW11SENwWlEweDhTMXI3UjBNUG0zRDYvbGFTN0syWXRsdlIyNFM1KzFnYUtleUdpWnY3L0EyUHlid1FoVWtIb0FBQUFBRWxGVGtTdVFtQ0NcXFwiKTtcXG4gIGJhY2tncm91bmQtc2l6ZTogNiU7XFxuICBhbmltYXRpb246IGdyYWluIDVzIHN0ZXBzKDEwKSBpbmZpbml0ZTsgfVxcblxcbkBrZXlmcmFtZXMgZ3JhaW4ge1xcbiAgMCUsIDEwMCUge1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgwLCAwKTsgfVxcbiAgMTAlIHtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUlLCAtMTAlKTsgfVxcbiAgMjAlIHtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTE1JSwgNSUpOyB9XFxuICAzMCUge1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSg3JSwgLTI1JSk7IH1cXG4gIDQwJSB7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01JSwgMjUlKTsgfVxcbiAgNTAlIHtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTE1JSwgMTAlKTsgfVxcbiAgNjAlIHtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoMTUlLCAwJSk7IH1cXG4gIDcwJSB7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKDAlLCAxNSUpOyB9XFxuICA4MCUge1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgzJSwgMzUlKTsgfVxcbiAgOTAlIHtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTEwJSwgMTAlKTsgfSB9XFxuXCIsXCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcXHJcXG5NSVhJTlMgRmlsZVxcclxcblxcclxcbkRlc2NyaXB0aW9uOlxcdFN0b3JlIFNDU1MgbWl4aW5zIGhlcmVcXHJcXG5cXHJcXG5DYWxsOiBAaW5jbHVkZSBiYWNrZ3JvdW5kU3RhbmRhcmQ7XFxyXFxuXFxyXFxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxyXFxuXFxyXFxuXFxyXFxuQG1peGluIGZsZXhfY2VudGVyIHtcXHJcXG5cXHRkaXNwbGF5OiBmbGV4O1xcclxcblxcdGZsZXgtZGlyZWN0aW9uOiByb3c7XFxyXFxuXFx0anVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxyXFxuXFx0YWxpZ24taXRlbXM6IGNlbnRlcjtcXHJcXG59XFxyXFxuXFxyXFxuQG1peGluIGJhY2tncm91bmRTdGFuZGFyZCB7XFxyXFxuXFx0YmFja2dyb3VuZC1zaXplOiBjb3ZlcjtcXHJcXG5cXHRiYWNrZ3JvdW5kLXBvc2l0aW9uOiBjZW50ZXI7XFxyXFxuXFx0YmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXHJcXG59XFxyXFxuXFxyXFxuQG1peGluIHNvbGlkU2hhZG93SG92ZXIge1xcclxcblxcdCY6aG92ZXJ7XFxyXFxuXFx0XFx0dGV4dC1zaGFkb3c6ICR0ZXh0LXNoYWRvdy1yZWQ7XFxyXFxuXFx0fVxcclxcbn1cXHJcXG5cXHJcXG5AbWl4aW4gbWF4V2lkdGgoJG1heFdpZHRoKSB7XFxyXFxuXFx0d2lkdGg6IDEwMCU7XFxyXFxuXFx0bWF4LXdpZHRoOiAkbWF4V2lkdGg7XFxyXFxuXFx0bWFyZ2luLWxlZnQ6IGF1dG87XFxyXFxuXFx0bWFyZ2luLXJpZ2h0OiBhdXRvO1xcclxcbn1cXHJcXG5cXHJcXG5AbWl4aW4gcGFwZXJUZXh0dXJle1xcclxcblxcdCY6YWZ0ZXJ7XFxyXFxuXFx0XFx0Y29udGVudDonJztcXHJcXG5cXHRcXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuXFx0XFx0aGVpZ2h0OiAxMDAlO1xcclxcblxcdFxcdHdpZHRoOiAxMDAlO1xcclxcblxcdFxcdHRvcDogMDtcXHJcXG5cXHRcXHRsZWZ0OiAwO1xcclxcblxcdFxcdG9wYWNpdHk6IC41O1xcclxcblxcdFxcdHBvaW50ZXItZXZlbnRzOiBub25lO1xcclxcblxcdFxcdGJhY2tncm91bmQtaW1hZ2U6IHVybCgnL2ltZy90ZXh0dXJlcy9uYXR1cmFsLXBhcGVyLnBuZycpO1xcclxcblxcdFxcdGJhY2tncm91bmQtcmVwZWF0OiByZXBlYXQ7XFxyXFxuXFx0XFx0Ly9taXgtYmxlbmQtbW9kZTogbGlnaHRlbjtcXHJcXG5cXHRcXHQvL2ZpbHRlcjogY29udHJhc3QoMS41KTtcXHJcXG5cXHRcXHRiYWNrZ3JvdW5kLXNpemU6IGNvdmVyO1xcclxcblxcdH1cXHJcXG59XCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5sb2NhbHMgPSB7XG5cdFwiZmlsbUdyYWluRmlsdGVyXCI6IFwiRmlsbUdyYWluRmlsdGVyX2ZpbG1HcmFpbkZpbHRlcl9fZklqaHlcIixcblx0XCJncmFpblwiOiBcIkZpbG1HcmFpbkZpbHRlcl9ncmFpbl9fM3A2ZF9cIlxufTtcbm1vZHVsZS5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iLCIvLyBJbXBvcnRzXG52YXIgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fID0gcmVxdWlyZShcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9hcGkuanNcIik7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18odHJ1ZSk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcXHJcXG5WQVJTIEZpbGVcXHJcXG5cXHJcXG5EZXNjcmlwdGlvbjpcXHRTdG9yZSBTQ1NTIHZhcnMgaGVyZVxcclxcblxcclxcblxcclxcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qKioqKiBDb2xvciBWYXJpYWJsZXMgKioqKiovXFxuLyoqKioqIE5hbWVkIENvbG9ycyAqKioqKi9cXG4vKioqKiogRm9udHMgKioqKiovXFxuLyoqKioqIEZvbnQgU2l6ZXMgKioqKiovXFxuLyoqKioqIExldHRlciBTcGFjaW5nICoqKioqL1xcbi8qKioqKiBDb250ZW50IFdpZHRocyAqKioqKi9cXG4vKioqKiogVHJhbnNpdGlvbiBUaW1pbmdzICoqKioqL1xcbi8qKioqKiBTaGFkb3dzICoqKioqL1xcbi8qIHNvdXJjZTogaHR0cHM6Ly9icnVtbS5hZi9zaGFkb3dzICovXFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXFxyXFxuTUlYSU5TIEZpbGVcXHJcXG5cXHJcXG5EZXNjcmlwdGlvbjpcXHRTdG9yZSBTQ1NTIG1peGlucyBoZXJlXFxyXFxuXFxyXFxuQ2FsbDogQGluY2x1ZGUgYmFja2dyb3VuZFN0YW5kYXJkO1xcclxcblxcclxcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi5Db21wb25lbnRNZXRhX2Rlc2NyaXB0aW9uV3JhcHBlcl9fM2l6cGkge1xcbiAgcGFkZGluZzogMzVweCAwO1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXgtd3JhcDogd3JhcDsgfVxcbiAgLkNvbXBvbmVudE1ldGFfZGVzY3JpcHRpb25XcmFwcGVyX18zaXpwaSAuQ29tcG9uZW50TWV0YV9yb3dfX3JmUzR0IHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgZmxleC1kaXJlY3Rpb246IHJvdztcXG4gICAgd2lkdGg6IDEwMCU7IH1cXG4gICAgLkNvbXBvbmVudE1ldGFfZGVzY3JpcHRpb25XcmFwcGVyX18zaXpwaSAuQ29tcG9uZW50TWV0YV9yb3dfX3JmUzR0Om5vdCg6bGFzdC1vZi10eXBlKSAuQ29tcG9uZW50TWV0YV9jZWxsX19xcUkzNyB7XFxuICAgICAgYm9yZGVyLWJvdHRvbTogMHB4OyB9XFxuICAuQ29tcG9uZW50TWV0YV9kZXNjcmlwdGlvbldyYXBwZXJfXzNpenBpIC5Db21wb25lbnRNZXRhX2NlbGxfX3FxSTM3IHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICAgIGFsaWduLWl0ZW1zOiBmbGV4LXN0YXJ0O1xcbiAgICBwYWRkaW5nOiAxNXB4O1xcbiAgICBib3JkZXI6IHNvbGlkIDFweCAjMjEyMTIxOyB9XFxuICAgIC5Db21wb25lbnRNZXRhX2Rlc2NyaXB0aW9uV3JhcHBlcl9fM2l6cGkgLkNvbXBvbmVudE1ldGFfY2VsbF9fcXFJMzc6bm90KDpmaXJzdC1vZi10eXBlKSB7XFxuICAgICAgYm9yZGVyLWxlZnQ6IHNvbGlkIDBweCAjMjEyMTIxOyB9XFxuICAgIC5Db21wb25lbnRNZXRhX2Rlc2NyaXB0aW9uV3JhcHBlcl9fM2l6cGkgLkNvbXBvbmVudE1ldGFfY2VsbF9fcXFJMzcuQ29tcG9uZW50TWV0YV90aXRsZV9fMTBQOUcge1xcbiAgICAgIHdpZHRoOiA0MDBweDsgfVxcbiAgICAuQ29tcG9uZW50TWV0YV9kZXNjcmlwdGlvbldyYXBwZXJfXzNpenBpIC5Db21wb25lbnRNZXRhX2NlbGxfX3FxSTM3LkNvbXBvbmVudE1ldGFfZGVzY3JpcHRpb25fXzIwXzFEIHtcXG4gICAgICB3aWR0aDogY2FsYygxMDAlIC0gNDAwcHgpOyB9XFxuICAgIC5Db21wb25lbnRNZXRhX2Rlc2NyaXB0aW9uV3JhcHBlcl9fM2l6cGkgLkNvbXBvbmVudE1ldGFfY2VsbF9fcXFJMzcuQ29tcG9uZW50TWV0YV9jb250ZW50UHJvcHNfXzNTMDZNIHtcXG4gICAgICB3aWR0aDogY2FsYygxMDAlIC0gNTAwcHgpOyB9XFxuICAgIC5Db21wb25lbnRNZXRhX2Rlc2NyaXB0aW9uV3JhcHBlcl9fM2l6cGkgLkNvbXBvbmVudE1ldGFfY2VsbF9fcXFJMzcuQ29tcG9uZW50TWV0YV9saWJyYXJpZXNfXzFXYm1nIHtcXG4gICAgICB3aWR0aDogNTAwcHg7IH1cXG4gICAgLkNvbXBvbmVudE1ldGFfZGVzY3JpcHRpb25XcmFwcGVyX18zaXpwaSAuQ29tcG9uZW50TWV0YV9jZWxsX19xcUkzNyAuQ29tcG9uZW50TWV0YV9pbm5lcl9fM3ZjTDUge1xcbiAgICAgIGxpc3Qtc3R5bGU6IG5vbmU7XFxuICAgICAgd2lkdGg6IDEwMCU7IH1cXG4gICAgICAuQ29tcG9uZW50TWV0YV9kZXNjcmlwdGlvbldyYXBwZXJfXzNpenBpIC5Db21wb25lbnRNZXRhX2NlbGxfX3FxSTM3IC5Db21wb25lbnRNZXRhX2lubmVyX18zdmNMNSBsaSB7XFxuICAgICAgICBtYXJnaW4tYm90dG9tOiAxMHB4OyB9XFxuICAgICAgICAuQ29tcG9uZW50TWV0YV9kZXNjcmlwdGlvbldyYXBwZXJfXzNpenBpIC5Db21wb25lbnRNZXRhX2NlbGxfX3FxSTM3IC5Db21wb25lbnRNZXRhX2lubmVyX18zdmNMNSBsaSBzcGFuIHtcXG4gICAgICAgICAgZm9udC13ZWlnaHQ6IDYwMDtcXG4gICAgICAgICAgZGlzcGxheTogYmxvY2s7XFxuICAgICAgICAgIHdpZHRoOiAxMDAlO1xcbiAgICAgICAgICBib3JkZXItYm90dG9tOiBzb2xpZCAxcHggIzIxMjEyMTtcXG4gICAgICAgICAgbWFyZ2luLWJvdHRvbTogMTBweDsgfVxcblwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uLi8uLi8uLi9zdHlsZXMvdmFycy5zY3NzXCIsXCJ3ZWJwYWNrOi8vQ29tcG9uZW50TWV0YS5tb2R1bGUuc2Nzc1wiLFwid2VicGFjazovLy4uLy4uLy4uL3N0eWxlcy9taXhpbnMuc2Nzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTs7Ozs7O2tEQ01rRDtBREdsRCw0QkFBQTtBQVVDLHlCQUFBO0FBU0Qsa0JBQUE7QUFLQSx1QkFBQTtBQU1BLDJCQUFBO0FBSUEsMkJBQUE7QUFNQSwrQkFBQTtBQU1BLG9CQUFBO0FBRUMscUNBQUE7QUV6REQ7Ozs7Ozs7a0REdUJrRDtBQW5CbEQ7RUFDQyxlQUFlO0VBQ2YsYUFBYTtFQUNiLGVBQWUsRUFBQTtFQUhoQjtJQU1FLGFBQWE7SUFDYixtQkFBbUI7SUFDbkIsV0FBVyxFQUFBO0lBUmI7TUFXUyxrQkFBa0IsRUFBQTtFQVgzQjtJQWtCRSxhQUFhO0lBQ2IsdUJBQXVCO0lBQ3ZCLHVCQUF1QjtJQUN2QixhQUFZO0lBQ1oseUJEaEJnQixFQUFBO0lDTmxCO01Bd0JHLDhCRGxCZSxFQUFBO0lDTmxCO01BMEJVLFlBQVcsRUFBQTtJQTFCckI7TUEyQmdCLHlCQUF3QixFQUFBO0lBM0J4QztNQTZCaUIseUJBQXdCLEVBQUE7SUE3QnpDO01BOEJjLFlBQVcsRUFBQTtJQTlCekI7TUFpQ0csZ0JBQWdCO01BQ2hCLFdBQVcsRUFBQTtNQWxDZDtRQXFDSSxtQkFBbUIsRUFBQTtRQXJDdkI7VUF3Q0ssZ0JBQWdCO1VBQ2hCLGNBQWM7VUFDZCxXQUFXO1VBQ1gsZ0NEckNhO1VDc0NiLG1CQUFtQixFQUFBXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxcclxcblZBUlMgRmlsZVxcclxcblxcclxcbkRlc2NyaXB0aW9uOlxcdFN0b3JlIFNDU1MgdmFycyBoZXJlXFxyXFxuXFxyXFxuXFxyXFxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxyXFxuXFxyXFxuXFxyXFxuLyoqKioqIENvbG9yIFZhcmlhYmxlcyAqKioqKi9cXHJcXG5cXHQkYmxhY2s6IFxcdFxcdCMyMTIxMjE7XFxyXFxuXFx0JHdoaXRlOiBcXHRcXHQjZmFmYWZhO1xcclxcblxcdCRncmV5XzE6XFx0XFx0I2VjZWNlYztcXHJcXG5cXHQkZ3JleV8yOlxcdFxcdCMzZTNlM2U7XFxyXFxuXFxyXFxuXFx0JHJlZDogXFx0XFx0XFx0I2ZiMDAwMDtcXHJcXG5cXHRcXHJcXG5cXHQkbmFzYV9ncmV5OlxcdCNEMUQzRDQ7XFxyXFxuXFxyXFxuXFx0LyoqKioqIE5hbWVkIENvbG9ycyAqKioqKi9cXHJcXG5cXHRcXHQkcHJpbWFyeV9jb2xvcjpcXHRcXHQkYmxhY2s7XFxyXFxuXFx0XFx0JHNlY29uZGFyeV9jb2xvcjpcXHRcXHQkd2hpdGU7XFxyXFxuXFxyXFxuXFx0XFx0JGJhY2tncm91bmRfY29sb3I6XFx0JHdoaXRlO1xcclxcblxcdFxcdCR0ZXh0X2NvbG9yOlxcdFxcdFxcdCRibGFjaztcXHJcXG5cXHRcXHQkYWNjZW50X2NvbG9yOlxcdFxcdCRncmV5XzE7XFxyXFxuXFxyXFxuXFxyXFxuLyoqKioqIEZvbnRzICoqKioqL1xcclxcblxcdCRmb250X2JvZHk6XFx0XFx0XFxcIk15VW5kZXJ3b29kXFxcIjtcXHJcXG5cXHQkZm9udF9kaXNwbGF5OlxcdFxcXCJBbmNpZW50TWVkaXVtXFxcIjtcXHJcXG5cXHQkZm9udF9hbHQ6XFx0XFx0XFx0XFxcIkltcGFjdExhYmVsXFxcIjtcXHJcXG5cXHJcXG4vKioqKiogRm9udCBTaXplcyAqKioqKi9cXHJcXG5cXHQkZm9udF9zaXplX2hlYWRpbmc6XFx0NjVweDtcXHJcXG5cXHQkZm9udF9zaXplX3N1YmhlYWQ6XFx0MzZweDtcXHJcXG5cXHQkZm9udF9zaXplX2JvZHk6XFx0XFx0MjBweDtcXHJcXG5cXHQkZm9udF9zaXplX2RldGFpbDpcXHQxNnB4O1xcclxcblxcclxcbi8qKioqKiBMZXR0ZXIgU3BhY2luZyAqKioqKi9cXHJcXG5cXHQkbGV0dGVyU3BhY2luZ1dpZGU6XFx0XFx0MC4wMzVlbTtcXHJcXG5cXHQkbGV0dGVyU3BhY2luZ05vcm1hbDpcXHQwLjAzNWVtO1xcclxcblxcclxcbi8qKioqKiBDb250ZW50IFdpZHRocyAqKioqKi9cXHJcXG5cXHQkY29udGVudF93aWR0aF9zOiBcXHQ2NTBweDtcXHJcXG5cXHQkY29udGVudF93aWR0aF9tOiBcXHQ5MjBweDtcXHJcXG5cXHQkY29udGVudF93aWR0aF9sOiBcXHQxNDUwcHg7XFxyXFxuXFxyXFxuXFxyXFxuLyoqKioqIFRyYW5zaXRpb24gVGltaW5ncyAqKioqKi9cXHJcXG5cXHQkdHJhbnNpdGlvbl9mYXN0OlxcdFxcdDAuMXMgZWFzZS1pbi1vdXQ7XFxyXFxuXFx0JHRyYW5zaXRpb25fbWVkaXVtOlxcdDAuMjVzIGVhc2UtaW4tb3V0O1xcclxcblxcdCR0cmFuc2l0aW9uX3Nsb3c6XFx0XFx0MC41cyBlYXNlLWluLW91dDtcXHJcXG5cXHJcXG5cXHJcXG4vKioqKiogU2hhZG93cyAqKioqKi9cXHJcXG5cXHJcXG5cXHQvKiBzb3VyY2U6IGh0dHBzOi8vYnJ1bW0uYWYvc2hhZG93cyAqL1xcclxcblxcdCRuaWNlX3NoYWRvdzpcXHJcXG5cXHRcXHQwIDIuOHB4IDIuMnB4IHJnYmEoMCwgMCwgMCwgMC4wMiksXFxyXFxuXFx0XFx0MCA2LjdweCA1LjNweCByZ2JhKDAsIDAsIDAsIDAuMDI4KSxcXHJcXG5cXHRcXHQwIDEyLjVweCAxMHB4IHJnYmEoMCwgMCwgMCwgMC4wMzUpLFxcclxcblxcdFxcdDAgMjIuM3B4IDE3LjlweCByZ2JhKDAsIDAsIDAsIDAuMDQyKSxcXHJcXG5cXHRcXHQwIDQxLjhweCAzMy40cHggcmdiYSgwLCAwLCAwLCAwLjA1KSxcXHJcXG5cXHRcXHQwIDEwMHB4IDgwcHggcmdiYSgwLCAwLCAwLCAwLjA3KTtcXHJcXG5cXHJcXG5cXHJcXG5cXHQkdGV4dC1zaGFkb3ctcmVkOlxcclxcblxcdFxcdDFweCAxcHggJHJlZCwgXFxyXFxuXFx0XFx0MnB4IDJweCAkcmVkLCBcXHJcXG5cXHRcXHQzcHggM3B4ICRyZWQsIFxcclxcblxcdFxcdDRweCA0cHggJHJlZCwgXFxyXFxuXFx0XFx0NXB4IDVweCAkcmVkO1xcclxcblxcdCAgXFxyXFxuXFx0JHRleHQtZ2xvdy1yZWQ6XFxyXFxuXFx0XFx0MCAwIDF2dyAkcmVkLCBcXHJcXG5cXHRcXHQwIDAgM3Z3ICRyZWQsIFxcclxcblxcdFxcdDAgMCAxMHZ3ICRyZWQsIFxcclxcblxcdFxcdDAgMCAxMHZ3ICRyZWQsIFxcclxcblxcdFxcdDAgMCAuNHZ3ICRyZWQsIFxcclxcblxcdFxcdC4yNXZ3IC4yNXZ3IC4xdncgIzgwNjkxNDtcXHJcXG5cIixcIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxcclxcblZBUlMgRmlsZVxcclxcblxcclxcbkRlc2NyaXB0aW9uOlxcdFN0b3JlIFNDU1MgdmFycyBoZXJlXFxyXFxuXFxyXFxuXFxyXFxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyoqKioqIENvbG9yIFZhcmlhYmxlcyAqKioqKi9cXG4vKioqKiogTmFtZWQgQ29sb3JzICoqKioqL1xcbi8qKioqKiBGb250cyAqKioqKi9cXG4vKioqKiogRm9udCBTaXplcyAqKioqKi9cXG4vKioqKiogTGV0dGVyIFNwYWNpbmcgKioqKiovXFxuLyoqKioqIENvbnRlbnQgV2lkdGhzICoqKioqL1xcbi8qKioqKiBUcmFuc2l0aW9uIFRpbWluZ3MgKioqKiovXFxuLyoqKioqIFNoYWRvd3MgKioqKiovXFxuLyogc291cmNlOiBodHRwczovL2JydW1tLmFmL3NoYWRvd3MgKi9cXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcXHJcXG5NSVhJTlMgRmlsZVxcclxcblxcclxcbkRlc2NyaXB0aW9uOlxcdFN0b3JlIFNDU1MgbWl4aW5zIGhlcmVcXHJcXG5cXHJcXG5DYWxsOiBAaW5jbHVkZSBiYWNrZ3JvdW5kU3RhbmRhcmQ7XFxyXFxuXFxyXFxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLmRlc2NyaXB0aW9uV3JhcHBlciB7XFxuICBwYWRkaW5nOiAzNXB4IDA7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleC13cmFwOiB3cmFwOyB9XFxuICAuZGVzY3JpcHRpb25XcmFwcGVyIC5yb3cge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBmbGV4LWRpcmVjdGlvbjogcm93O1xcbiAgICB3aWR0aDogMTAwJTsgfVxcbiAgICAuZGVzY3JpcHRpb25XcmFwcGVyIC5yb3c6bm90KDpsYXN0LW9mLXR5cGUpIC5jZWxsIHtcXG4gICAgICBib3JkZXItYm90dG9tOiAwcHg7IH1cXG4gIC5kZXNjcmlwdGlvbldyYXBwZXIgLmNlbGwge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgYWxpZ24taXRlbXM6IGZsZXgtc3RhcnQ7XFxuICAgIHBhZGRpbmc6IDE1cHg7XFxuICAgIGJvcmRlcjogc29saWQgMXB4ICMyMTIxMjE7IH1cXG4gICAgLmRlc2NyaXB0aW9uV3JhcHBlciAuY2VsbDpub3QoOmZpcnN0LW9mLXR5cGUpIHtcXG4gICAgICBib3JkZXItbGVmdDogc29saWQgMHB4ICMyMTIxMjE7IH1cXG4gICAgLmRlc2NyaXB0aW9uV3JhcHBlciAuY2VsbC50aXRsZSB7XFxuICAgICAgd2lkdGg6IDQwMHB4OyB9XFxuICAgIC5kZXNjcmlwdGlvbldyYXBwZXIgLmNlbGwuZGVzY3JpcHRpb24ge1xcbiAgICAgIHdpZHRoOiBjYWxjKDEwMCUgLSA0MDBweCk7IH1cXG4gICAgLmRlc2NyaXB0aW9uV3JhcHBlciAuY2VsbC5jb250ZW50UHJvcHMge1xcbiAgICAgIHdpZHRoOiBjYWxjKDEwMCUgLSA1MDBweCk7IH1cXG4gICAgLmRlc2NyaXB0aW9uV3JhcHBlciAuY2VsbC5saWJyYXJpZXMge1xcbiAgICAgIHdpZHRoOiA1MDBweDsgfVxcbiAgICAuZGVzY3JpcHRpb25XcmFwcGVyIC5jZWxsIC5pbm5lciB7XFxuICAgICAgbGlzdC1zdHlsZTogbm9uZTtcXG4gICAgICB3aWR0aDogMTAwJTsgfVxcbiAgICAgIC5kZXNjcmlwdGlvbldyYXBwZXIgLmNlbGwgLmlubmVyIGxpIHtcXG4gICAgICAgIG1hcmdpbi1ib3R0b206IDEwcHg7IH1cXG4gICAgICAgIC5kZXNjcmlwdGlvbldyYXBwZXIgLmNlbGwgLmlubmVyIGxpIHNwYW4ge1xcbiAgICAgICAgICBmb250LXdlaWdodDogNjAwO1xcbiAgICAgICAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgICAgICAgd2lkdGg6IDEwMCU7XFxuICAgICAgICAgIGJvcmRlci1ib3R0b206IHNvbGlkIDFweCAjMjEyMTIxO1xcbiAgICAgICAgICBtYXJnaW4tYm90dG9tOiAxMHB4OyB9XFxuXCIsXCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcXHJcXG5NSVhJTlMgRmlsZVxcclxcblxcclxcbkRlc2NyaXB0aW9uOlxcdFN0b3JlIFNDU1MgbWl4aW5zIGhlcmVcXHJcXG5cXHJcXG5DYWxsOiBAaW5jbHVkZSBiYWNrZ3JvdW5kU3RhbmRhcmQ7XFxyXFxuXFxyXFxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxyXFxuXFxyXFxuXFxyXFxuQG1peGluIGZsZXhfY2VudGVyIHtcXHJcXG5cXHRkaXNwbGF5OiBmbGV4O1xcclxcblxcdGZsZXgtZGlyZWN0aW9uOiByb3c7XFxyXFxuXFx0anVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxyXFxuXFx0YWxpZ24taXRlbXM6IGNlbnRlcjtcXHJcXG59XFxyXFxuXFxyXFxuQG1peGluIGJhY2tncm91bmRTdGFuZGFyZCB7XFxyXFxuXFx0YmFja2dyb3VuZC1zaXplOiBjb3ZlcjtcXHJcXG5cXHRiYWNrZ3JvdW5kLXBvc2l0aW9uOiBjZW50ZXI7XFxyXFxuXFx0YmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXHJcXG59XFxyXFxuXFxyXFxuQG1peGluIHNvbGlkU2hhZG93SG92ZXIge1xcclxcblxcdCY6aG92ZXJ7XFxyXFxuXFx0XFx0dGV4dC1zaGFkb3c6ICR0ZXh0LXNoYWRvdy1yZWQ7XFxyXFxuXFx0fVxcclxcbn1cXHJcXG5cXHJcXG5AbWl4aW4gbWF4V2lkdGgoJG1heFdpZHRoKSB7XFxyXFxuXFx0d2lkdGg6IDEwMCU7XFxyXFxuXFx0bWF4LXdpZHRoOiAkbWF4V2lkdGg7XFxyXFxuXFx0bWFyZ2luLWxlZnQ6IGF1dG87XFxyXFxuXFx0bWFyZ2luLXJpZ2h0OiBhdXRvO1xcclxcbn1cXHJcXG5cXHJcXG5AbWl4aW4gcGFwZXJUZXh0dXJle1xcclxcblxcdCY6YWZ0ZXJ7XFxyXFxuXFx0XFx0Y29udGVudDonJztcXHJcXG5cXHRcXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuXFx0XFx0aGVpZ2h0OiAxMDAlO1xcclxcblxcdFxcdHdpZHRoOiAxMDAlO1xcclxcblxcdFxcdHRvcDogMDtcXHJcXG5cXHRcXHRsZWZ0OiAwO1xcclxcblxcdFxcdG9wYWNpdHk6IC41O1xcclxcblxcdFxcdHBvaW50ZXItZXZlbnRzOiBub25lO1xcclxcblxcdFxcdGJhY2tncm91bmQtaW1hZ2U6IHVybCgnL2ltZy90ZXh0dXJlcy9uYXR1cmFsLXBhcGVyLnBuZycpO1xcclxcblxcdFxcdGJhY2tncm91bmQtcmVwZWF0OiByZXBlYXQ7XFxyXFxuXFx0XFx0Ly9taXgtYmxlbmQtbW9kZTogbGlnaHRlbjtcXHJcXG5cXHRcXHQvL2ZpbHRlcjogY29udHJhc3QoMS41KTtcXHJcXG5cXHRcXHRiYWNrZ3JvdW5kLXNpemU6IGNvdmVyO1xcclxcblxcdH1cXHJcXG59XCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5sb2NhbHMgPSB7XG5cdFwiZGVzY3JpcHRpb25XcmFwcGVyXCI6IFwiQ29tcG9uZW50TWV0YV9kZXNjcmlwdGlvbldyYXBwZXJfXzNpenBpXCIsXG5cdFwicm93XCI6IFwiQ29tcG9uZW50TWV0YV9yb3dfX3JmUzR0XCIsXG5cdFwiY2VsbFwiOiBcIkNvbXBvbmVudE1ldGFfY2VsbF9fcXFJMzdcIixcblx0XCJ0aXRsZVwiOiBcIkNvbXBvbmVudE1ldGFfdGl0bGVfXzEwUDlHXCIsXG5cdFwiZGVzY3JpcHRpb25cIjogXCJDb21wb25lbnRNZXRhX2Rlc2NyaXB0aW9uX18yMF8xRFwiLFxuXHRcImNvbnRlbnRQcm9wc1wiOiBcIkNvbXBvbmVudE1ldGFfY29udGVudFByb3BzX18zUzA2TVwiLFxuXHRcImxpYnJhcmllc1wiOiBcIkNvbXBvbmVudE1ldGFfbGlicmFyaWVzX18xV2JtZ1wiLFxuXHRcImlubmVyXCI6IFwiQ29tcG9uZW50TWV0YV9pbm5lcl9fM3ZjTDVcIlxufTtcbm1vZHVsZS5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iLCIvLyBJbXBvcnRzXG52YXIgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fID0gcmVxdWlyZShcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9hcGkuanNcIik7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18odHJ1ZSk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCIvKioqKiogPT09PT09PT09PSAqKioqKi9cXG4vKioqKiogQ09OVEFJTkVSICAqKioqKi9cXG4vKioqKiogPT09PT09PT09PSAqKioqKi9cXG4uQ29udGFpbmVyX2NvbnRhaW5lcl9fMlJRNzMge1xcbiAgbWF4LXdpZHRoOiAxNDUwcHg7XFxuICB3aWR0aDogMTAwJTtcXG4gIG1hcmdpbjogMCBhdXRvO1xcbiAgcGFkZGluZzogMCAzNXB4O1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTsgfVxcbiAgLkNvbnRhaW5lcl9jb250YWluZXJfXzJSUTczLkNvbnRhaW5lcl9mbGV4X18xTnFseSB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyOyB9XFxuXCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovL0NvbnRhaW5lci5tb2R1bGUuc2Nzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQSx1QkFBQTtBQUNBLHVCQUFBO0FBQ0EsdUJBQUE7QUFDQTtFQUNDLGlCQUFpQjtFQUNqQixXQUFXO0VBQ1gsY0FBYztFQUNkLGVBQWU7RUFDZixzQkFBc0I7RUFDdEIsa0JBQWtCLEVBQUE7RUFObkI7SUFTRSxhQUFhO0lBQ2IsbUJBQW1CO0lBQ25CLHVCQUF1QjtJQUN2QixtQkFBbUIsRUFBQVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCIvKioqKiogPT09PT09PT09PSAqKioqKi9cXHJcXG4vKioqKiogQ09OVEFJTkVSICAqKioqKi9cXHJcXG4vKioqKiogPT09PT09PT09PSAqKioqKi9cXHJcXG4uY29udGFpbmVyIHtcXHJcXG5cXHRtYXgtd2lkdGg6IDE0NTBweDtcXHJcXG5cXHR3aWR0aDogMTAwJTtcXHJcXG5cXHRtYXJnaW46IDAgYXV0bztcXHJcXG5cXHRwYWRkaW5nOiAwIDM1cHg7XFxyXFxuXFx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcXHJcXG5cXHRwb3NpdGlvbjogcmVsYXRpdmU7XFxyXFxuXFxyXFxuXFx0Ji5mbGV4e1xcclxcblxcdFxcdGRpc3BsYXk6IGZsZXg7XFxyXFxuXFx0XFx0ZmxleC1kaXJlY3Rpb246IHJvdztcXHJcXG5cXHRcXHRqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXHJcXG5cXHRcXHRhbGlnbi1pdGVtczogY2VudGVyO1xcclxcblxcdH1cXHJcXG59XCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5sb2NhbHMgPSB7XG5cdFwiY29udGFpbmVyXCI6IFwiQ29udGFpbmVyX2NvbnRhaW5lcl9fMlJRNzNcIixcblx0XCJmbGV4XCI6IFwiQ29udGFpbmVyX2ZsZXhfXzFOcWx5XCJcbn07XG5tb2R1bGUuZXhwb3J0cyA9IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIiwiLy8gSW1wb3J0c1xudmFyIF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvYXBpLmpzXCIpO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKHRydWUpO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXFxyXFxuVkFSUyBGaWxlXFxyXFxuXFxyXFxuRGVzY3JpcHRpb246XFx0U3RvcmUgU0NTUyB2YXJzIGhlcmVcXHJcXG5cXHJcXG5cXHJcXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKioqKiogQ29sb3IgVmFyaWFibGVzICoqKioqL1xcbi8qKioqKiBOYW1lZCBDb2xvcnMgKioqKiovXFxuLyoqKioqIEZvbnRzICoqKioqL1xcbi8qKioqKiBGb250IFNpemVzICoqKioqL1xcbi8qKioqKiBMZXR0ZXIgU3BhY2luZyAqKioqKi9cXG4vKioqKiogQ29udGVudCBXaWR0aHMgKioqKiovXFxuLyoqKioqIFRyYW5zaXRpb24gVGltaW5ncyAqKioqKi9cXG4vKioqKiogU2hhZG93cyAqKioqKi9cXG4vKiBzb3VyY2U6IGh0dHBzOi8vYnJ1bW0uYWYvc2hhZG93cyAqL1xcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxcclxcbk1JWElOUyBGaWxlXFxyXFxuXFxyXFxuRGVzY3JpcHRpb246XFx0U3RvcmUgU0NTUyBtaXhpbnMgaGVyZVxcclxcblxcclxcbkNhbGw6IEBpbmNsdWRlIGJhY2tncm91bmRTdGFuZGFyZDtcXHJcXG5cXHJcXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4uRm9vdGVyX2Zvb3Rlcl9fM2FVd2Ige1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDEwMHB4O1xcbiAgYm9yZGVyLXRvcDogMXB4IHNvbGlkICNlYWVhZWE7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgbWFyZ2luLXRvcDogMTUwcHg7IH1cXG4gIC5Gb290ZXJfZm9vdGVyX18zYVV3YiAuRm9vdGVyX2Zvb3Rlcl9tZXNzYWdlX19Yc1lodiB7XFxuICAgIGZvbnQtc2l6ZTogM3JlbTtcXG4gICAgZm9udC1mYW1pbHk6IFxcXCJBbmNpZW50TWVkaXVtXFxcIjsgfVxcblwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uLi8uLi8uLi9zdHlsZXMvdmFycy5zY3NzXCIsXCJ3ZWJwYWNrOi8vRm9vdGVyLm1vZHVsZS5zY3NzXCIsXCJ3ZWJwYWNrOi8vLi4vLi4vLi4vc3R5bGVzL21peGlucy5zY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBOzs7Ozs7a0RDTWtEO0FER2xELDRCQUFBO0FBVUMseUJBQUE7QUFTRCxrQkFBQTtBQUtBLHVCQUFBO0FBTUEsMkJBQUE7QUFJQSwyQkFBQTtBQU1BLCtCQUFBO0FBTUEsb0JBQUE7QUFFQyxxQ0FBQTtBRXpERDs7Ozs7OztrRER1QmtEO0FBbEJsRDtFQUNDLFdBQVc7RUFDWCxhQUFhO0VBQ2IsNkJBQTZCO0VBQzdCLGFBQWE7RUFDYix1QkFBdUI7RUFDdkIsbUJBQW1CO0VBQ25CLGlCQUFpQixFQUFBO0VBUGxCO0lBVUUsZUFBZTtJQUNmLDRCRGM2QixFQUFBXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxcclxcblZBUlMgRmlsZVxcclxcblxcclxcbkRlc2NyaXB0aW9uOlxcdFN0b3JlIFNDU1MgdmFycyBoZXJlXFxyXFxuXFxyXFxuXFxyXFxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxyXFxuXFxyXFxuXFxyXFxuLyoqKioqIENvbG9yIFZhcmlhYmxlcyAqKioqKi9cXHJcXG5cXHQkYmxhY2s6IFxcdFxcdCMyMTIxMjE7XFxyXFxuXFx0JHdoaXRlOiBcXHRcXHQjZmFmYWZhO1xcclxcblxcdCRncmV5XzE6XFx0XFx0I2VjZWNlYztcXHJcXG5cXHQkZ3JleV8yOlxcdFxcdCMzZTNlM2U7XFxyXFxuXFxyXFxuXFx0JHJlZDogXFx0XFx0XFx0I2ZiMDAwMDtcXHJcXG5cXHRcXHJcXG5cXHQkbmFzYV9ncmV5OlxcdCNEMUQzRDQ7XFxyXFxuXFxyXFxuXFx0LyoqKioqIE5hbWVkIENvbG9ycyAqKioqKi9cXHJcXG5cXHRcXHQkcHJpbWFyeV9jb2xvcjpcXHRcXHQkYmxhY2s7XFxyXFxuXFx0XFx0JHNlY29uZGFyeV9jb2xvcjpcXHRcXHQkd2hpdGU7XFxyXFxuXFxyXFxuXFx0XFx0JGJhY2tncm91bmRfY29sb3I6XFx0JHdoaXRlO1xcclxcblxcdFxcdCR0ZXh0X2NvbG9yOlxcdFxcdFxcdCRibGFjaztcXHJcXG5cXHRcXHQkYWNjZW50X2NvbG9yOlxcdFxcdCRncmV5XzE7XFxyXFxuXFxyXFxuXFxyXFxuLyoqKioqIEZvbnRzICoqKioqL1xcclxcblxcdCRmb250X2JvZHk6XFx0XFx0XFxcIk15VW5kZXJ3b29kXFxcIjtcXHJcXG5cXHQkZm9udF9kaXNwbGF5OlxcdFxcXCJBbmNpZW50TWVkaXVtXFxcIjtcXHJcXG5cXHQkZm9udF9hbHQ6XFx0XFx0XFx0XFxcIkltcGFjdExhYmVsXFxcIjtcXHJcXG5cXHJcXG4vKioqKiogRm9udCBTaXplcyAqKioqKi9cXHJcXG5cXHQkZm9udF9zaXplX2hlYWRpbmc6XFx0NjVweDtcXHJcXG5cXHQkZm9udF9zaXplX3N1YmhlYWQ6XFx0MzZweDtcXHJcXG5cXHQkZm9udF9zaXplX2JvZHk6XFx0XFx0MjBweDtcXHJcXG5cXHQkZm9udF9zaXplX2RldGFpbDpcXHQxNnB4O1xcclxcblxcclxcbi8qKioqKiBMZXR0ZXIgU3BhY2luZyAqKioqKi9cXHJcXG5cXHQkbGV0dGVyU3BhY2luZ1dpZGU6XFx0XFx0MC4wMzVlbTtcXHJcXG5cXHQkbGV0dGVyU3BhY2luZ05vcm1hbDpcXHQwLjAzNWVtO1xcclxcblxcclxcbi8qKioqKiBDb250ZW50IFdpZHRocyAqKioqKi9cXHJcXG5cXHQkY29udGVudF93aWR0aF9zOiBcXHQ2NTBweDtcXHJcXG5cXHQkY29udGVudF93aWR0aF9tOiBcXHQ5MjBweDtcXHJcXG5cXHQkY29udGVudF93aWR0aF9sOiBcXHQxNDUwcHg7XFxyXFxuXFxyXFxuXFxyXFxuLyoqKioqIFRyYW5zaXRpb24gVGltaW5ncyAqKioqKi9cXHJcXG5cXHQkdHJhbnNpdGlvbl9mYXN0OlxcdFxcdDAuMXMgZWFzZS1pbi1vdXQ7XFxyXFxuXFx0JHRyYW5zaXRpb25fbWVkaXVtOlxcdDAuMjVzIGVhc2UtaW4tb3V0O1xcclxcblxcdCR0cmFuc2l0aW9uX3Nsb3c6XFx0XFx0MC41cyBlYXNlLWluLW91dDtcXHJcXG5cXHJcXG5cXHJcXG4vKioqKiogU2hhZG93cyAqKioqKi9cXHJcXG5cXHJcXG5cXHQvKiBzb3VyY2U6IGh0dHBzOi8vYnJ1bW0uYWYvc2hhZG93cyAqL1xcclxcblxcdCRuaWNlX3NoYWRvdzpcXHJcXG5cXHRcXHQwIDIuOHB4IDIuMnB4IHJnYmEoMCwgMCwgMCwgMC4wMiksXFxyXFxuXFx0XFx0MCA2LjdweCA1LjNweCByZ2JhKDAsIDAsIDAsIDAuMDI4KSxcXHJcXG5cXHRcXHQwIDEyLjVweCAxMHB4IHJnYmEoMCwgMCwgMCwgMC4wMzUpLFxcclxcblxcdFxcdDAgMjIuM3B4IDE3LjlweCByZ2JhKDAsIDAsIDAsIDAuMDQyKSxcXHJcXG5cXHRcXHQwIDQxLjhweCAzMy40cHggcmdiYSgwLCAwLCAwLCAwLjA1KSxcXHJcXG5cXHRcXHQwIDEwMHB4IDgwcHggcmdiYSgwLCAwLCAwLCAwLjA3KTtcXHJcXG5cXHJcXG5cXHJcXG5cXHQkdGV4dC1zaGFkb3ctcmVkOlxcclxcblxcdFxcdDFweCAxcHggJHJlZCwgXFxyXFxuXFx0XFx0MnB4IDJweCAkcmVkLCBcXHJcXG5cXHRcXHQzcHggM3B4ICRyZWQsIFxcclxcblxcdFxcdDRweCA0cHggJHJlZCwgXFxyXFxuXFx0XFx0NXB4IDVweCAkcmVkO1xcclxcblxcdCAgXFxyXFxuXFx0JHRleHQtZ2xvdy1yZWQ6XFxyXFxuXFx0XFx0MCAwIDF2dyAkcmVkLCBcXHJcXG5cXHRcXHQwIDAgM3Z3ICRyZWQsIFxcclxcblxcdFxcdDAgMCAxMHZ3ICRyZWQsIFxcclxcblxcdFxcdDAgMCAxMHZ3ICRyZWQsIFxcclxcblxcdFxcdDAgMCAuNHZ3ICRyZWQsIFxcclxcblxcdFxcdC4yNXZ3IC4yNXZ3IC4xdncgIzgwNjkxNDtcXHJcXG5cIixcIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxcclxcblZBUlMgRmlsZVxcclxcblxcclxcbkRlc2NyaXB0aW9uOlxcdFN0b3JlIFNDU1MgdmFycyBoZXJlXFxyXFxuXFxyXFxuXFxyXFxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyoqKioqIENvbG9yIFZhcmlhYmxlcyAqKioqKi9cXG4vKioqKiogTmFtZWQgQ29sb3JzICoqKioqL1xcbi8qKioqKiBGb250cyAqKioqKi9cXG4vKioqKiogRm9udCBTaXplcyAqKioqKi9cXG4vKioqKiogTGV0dGVyIFNwYWNpbmcgKioqKiovXFxuLyoqKioqIENvbnRlbnQgV2lkdGhzICoqKioqL1xcbi8qKioqKiBUcmFuc2l0aW9uIFRpbWluZ3MgKioqKiovXFxuLyoqKioqIFNoYWRvd3MgKioqKiovXFxuLyogc291cmNlOiBodHRwczovL2JydW1tLmFmL3NoYWRvd3MgKi9cXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcXHJcXG5NSVhJTlMgRmlsZVxcclxcblxcclxcbkRlc2NyaXB0aW9uOlxcdFN0b3JlIFNDU1MgbWl4aW5zIGhlcmVcXHJcXG5cXHJcXG5DYWxsOiBAaW5jbHVkZSBiYWNrZ3JvdW5kU3RhbmRhcmQ7XFxyXFxuXFxyXFxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLmZvb3RlciB7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMTAwcHg7XFxuICBib3JkZXItdG9wOiAxcHggc29saWQgI2VhZWFlYTtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBtYXJnaW4tdG9wOiAxNTBweDsgfVxcbiAgLmZvb3RlciAuZm9vdGVyX21lc3NhZ2Uge1xcbiAgICBmb250LXNpemU6IDNyZW07XFxuICAgIGZvbnQtZmFtaWx5OiBcXFwiQW5jaWVudE1lZGl1bVxcXCI7IH1cXG5cIixcIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxcclxcbk1JWElOUyBGaWxlXFxyXFxuXFxyXFxuRGVzY3JpcHRpb246XFx0U3RvcmUgU0NTUyBtaXhpbnMgaGVyZVxcclxcblxcclxcbkNhbGw6IEBpbmNsdWRlIGJhY2tncm91bmRTdGFuZGFyZDtcXHJcXG5cXHJcXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXHJcXG5cXHJcXG5cXHJcXG5AbWl4aW4gZmxleF9jZW50ZXIge1xcclxcblxcdGRpc3BsYXk6IGZsZXg7XFxyXFxuXFx0ZmxleC1kaXJlY3Rpb246IHJvdztcXHJcXG5cXHRqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXHJcXG5cXHRhbGlnbi1pdGVtczogY2VudGVyO1xcclxcbn1cXHJcXG5cXHJcXG5AbWl4aW4gYmFja2dyb3VuZFN0YW5kYXJkIHtcXHJcXG5cXHRiYWNrZ3JvdW5kLXNpemU6IGNvdmVyO1xcclxcblxcdGJhY2tncm91bmQtcG9zaXRpb246IGNlbnRlcjtcXHJcXG5cXHRiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcclxcbn1cXHJcXG5cXHJcXG5AbWl4aW4gc29saWRTaGFkb3dIb3ZlciB7XFxyXFxuXFx0Jjpob3ZlcntcXHJcXG5cXHRcXHR0ZXh0LXNoYWRvdzogJHRleHQtc2hhZG93LXJlZDtcXHJcXG5cXHR9XFxyXFxufVxcclxcblxcclxcbkBtaXhpbiBtYXhXaWR0aCgkbWF4V2lkdGgpIHtcXHJcXG5cXHR3aWR0aDogMTAwJTtcXHJcXG5cXHRtYXgtd2lkdGg6ICRtYXhXaWR0aDtcXHJcXG5cXHRtYXJnaW4tbGVmdDogYXV0bztcXHJcXG5cXHRtYXJnaW4tcmlnaHQ6IGF1dG87XFxyXFxufVxcclxcblxcclxcbkBtaXhpbiBwYXBlclRleHR1cmV7XFxyXFxuXFx0JjphZnRlcntcXHJcXG5cXHRcXHRjb250ZW50OicnO1xcclxcblxcdFxcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG5cXHRcXHRoZWlnaHQ6IDEwMCU7XFxyXFxuXFx0XFx0d2lkdGg6IDEwMCU7XFxyXFxuXFx0XFx0dG9wOiAwO1xcclxcblxcdFxcdGxlZnQ6IDA7XFxyXFxuXFx0XFx0b3BhY2l0eTogLjU7XFxyXFxuXFx0XFx0cG9pbnRlci1ldmVudHM6IG5vbmU7XFxyXFxuXFx0XFx0YmFja2dyb3VuZC1pbWFnZTogdXJsKCcvaW1nL3RleHR1cmVzL25hdHVyYWwtcGFwZXIucG5nJyk7XFxyXFxuXFx0XFx0YmFja2dyb3VuZC1yZXBlYXQ6IHJlcGVhdDtcXHJcXG5cXHRcXHQvL21peC1ibGVuZC1tb2RlOiBsaWdodGVuO1xcclxcblxcdFxcdC8vZmlsdGVyOiBjb250cmFzdCgxLjUpO1xcclxcblxcdFxcdGJhY2tncm91bmQtc2l6ZTogY292ZXI7XFxyXFxuXFx0fVxcclxcbn1cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLmxvY2FscyA9IHtcblx0XCJmb290ZXJcIjogXCJGb290ZXJfZm9vdGVyX18zYVV3YlwiLFxuXHRcImZvb3Rlcl9tZXNzYWdlXCI6IFwiRm9vdGVyX2Zvb3Rlcl9tZXNzYWdlX19Yc1lodlwiXG59O1xubW9kdWxlLmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSByZXF1aXJlKFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2FwaS5qc1wiKTtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyh0cnVlKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxcclxcblZBUlMgRmlsZVxcclxcblxcclxcbkRlc2NyaXB0aW9uOlxcdFN0b3JlIFNDU1MgdmFycyBoZXJlXFxyXFxuXFxyXFxuXFxyXFxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyoqKioqIENvbG9yIFZhcmlhYmxlcyAqKioqKi9cXG4vKioqKiogTmFtZWQgQ29sb3JzICoqKioqL1xcbi8qKioqKiBGb250cyAqKioqKi9cXG4vKioqKiogRm9udCBTaXplcyAqKioqKi9cXG4vKioqKiogTGV0dGVyIFNwYWNpbmcgKioqKiovXFxuLyoqKioqIENvbnRlbnQgV2lkdGhzICoqKioqL1xcbi8qKioqKiBUcmFuc2l0aW9uIFRpbWluZ3MgKioqKiovXFxuLyoqKioqIFNoYWRvd3MgKioqKiovXFxuLyogc291cmNlOiBodHRwczovL2JydW1tLmFmL3NoYWRvd3MgKi9cXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcXHJcXG5NSVhJTlMgRmlsZVxcclxcblxcclxcbkRlc2NyaXB0aW9uOlxcdFN0b3JlIFNDU1MgbWl4aW5zIGhlcmVcXHJcXG5cXHJcXG5DYWxsOiBAaW5jbHVkZSBiYWNrZ3JvdW5kU3RhbmRhcmQ7XFxyXFxuXFxyXFxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLkhlYWRlcl9oZWFkZXJfXzJ0WGszIHtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI0QxRDNENDsgfVxcblxcbi5IZWFkZXJfY29udGFpbmVyX19iNlV1eCB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleC1kaXJlY3Rpb246IHJvdztcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47IH1cXG5cXG4uSGVhZGVyX2NvbnRlbnRMZWZ0X19IUGRRTyB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleC1kaXJlY3Rpb246IHJvdztcXG4gIGp1c3RpZnktY29udGVudDogZmxleC1zdGFydDtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICB3aWR0aDogMTAwJTtcXG4gIG1heC13aWR0aDogMTAwJTsgfVxcbiAgLkhlYWRlcl9jb250ZW50TGVmdF9fSFBkUU8gLkhlYWRlcl9sb2dvX18zU2I1OSB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBwYWRkaW5nOiAxMHB4O1xcbiAgICBtYXJnaW4tcmlnaHQ6IDMwcHg7XFxuICAgIGJvcmRlcjogbm9uZTsgfVxcbiAgLkhlYWRlcl9jb250ZW50TGVmdF9fSFBkUU8gLkhlYWRlcl90aXRsZV9fMWhFVTcge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBmbGV4LWRpcmVjdGlvbjogcm93O1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBmb250LXNpemU6IDY1cHg7XFxuICAgIHBhZGRpbmc6IDEwcHggMDsgfVxcblxcbi5IZWFkZXJfY29udGVudFJpZ2h0X18xRjNWVCB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleC1kaXJlY3Rpb246IHJvdztcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgbWF4LXdpZHRoOiBjYWxjKDEwMCUgLSAkc3RhdGljX3dpZHRoKTsgfVxcblwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uLi8uLi8uLi9zdHlsZXMvdmFycy5zY3NzXCIsXCJ3ZWJwYWNrOi8vSGVhZGVyLm1vZHVsZS5zY3NzXCIsXCJ3ZWJwYWNrOi8vLi4vLi4vLi4vc3R5bGVzL21peGlucy5zY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBOzs7Ozs7a0RDTWtEO0FER2xELDRCQUFBO0FBVUMseUJBQUE7QUFTRCxrQkFBQTtBQUtBLHVCQUFBO0FBTUEsMkJBQUE7QUFJQSwyQkFBQTtBQU1BLCtCQUFBO0FBTUEsb0JBQUE7QUFFQyxxQ0FBQTtBRXpERDs7Ozs7OztrRER1QmtEO0FBbkJsRDtFQUNDLFdBQVc7RUFDWCx5QkRXbUIsRUFBQTs7QUNQcEI7RUFDQyxhQUFhO0VBQ2IsbUJBQW1CO0VBQ25CLG1CQUFtQjtFQUNuQiw4QkFBOEIsRUFBQTs7QUFNL0I7RUFDQyxhQUFhO0VBQ2IsbUJBQW1CO0VBQ25CLDJCQUEyQjtFQUMzQixtQkFBbUI7RUFDbkIsV0FBVztFQUNYLGVBUmtCLEVBQUE7RUFFbkI7SUNUQyxhQUFhO0lBQ2IsbUJBQW1CO0lBQ25CLHVCQUF1QjtJQUN2QixtQkFBbUI7SURnQmxCLGFBQWE7SUFDYixrQkFBa0I7SUFDbEIsWUFBWSxFQUFBO0VBWmQ7SUNUQyxhQUFhO0lBQ2IsbUJBQW1CO0lBQ25CLHVCQUF1QjtJQUN2QixtQkFBbUI7SUR1QmxCLGtCQUFrQjtJQUNsQixlREp1QjtJQ0t2QixlQUFlLEVBQUE7O0FBSWpCO0VBQ0MsYUFBYTtFQUNiLG1CQUFtQjtFQUNuQix1QkFBdUI7RUFDdkIsbUJBQW1CO0VBQ25CLFdBQVc7RUFDWCxxQ0FBcUMsRUFBQVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcXHJcXG5WQVJTIEZpbGVcXHJcXG5cXHJcXG5EZXNjcmlwdGlvbjpcXHRTdG9yZSBTQ1NTIHZhcnMgaGVyZVxcclxcblxcclxcblxcclxcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcclxcblxcclxcblxcclxcbi8qKioqKiBDb2xvciBWYXJpYWJsZXMgKioqKiovXFxyXFxuXFx0JGJsYWNrOiBcXHRcXHQjMjEyMTIxO1xcclxcblxcdCR3aGl0ZTogXFx0XFx0I2ZhZmFmYTtcXHJcXG5cXHQkZ3JleV8xOlxcdFxcdCNlY2VjZWM7XFxyXFxuXFx0JGdyZXlfMjpcXHRcXHQjM2UzZTNlO1xcclxcblxcclxcblxcdCRyZWQ6IFxcdFxcdFxcdCNmYjAwMDA7XFxyXFxuXFx0XFxyXFxuXFx0JG5hc2FfZ3JleTpcXHQjRDFEM0Q0O1xcclxcblxcclxcblxcdC8qKioqKiBOYW1lZCBDb2xvcnMgKioqKiovXFxyXFxuXFx0XFx0JHByaW1hcnlfY29sb3I6XFx0XFx0JGJsYWNrO1xcclxcblxcdFxcdCRzZWNvbmRhcnlfY29sb3I6XFx0XFx0JHdoaXRlO1xcclxcblxcclxcblxcdFxcdCRiYWNrZ3JvdW5kX2NvbG9yOlxcdCR3aGl0ZTtcXHJcXG5cXHRcXHQkdGV4dF9jb2xvcjpcXHRcXHRcXHQkYmxhY2s7XFxyXFxuXFx0XFx0JGFjY2VudF9jb2xvcjpcXHRcXHQkZ3JleV8xO1xcclxcblxcclxcblxcclxcbi8qKioqKiBGb250cyAqKioqKi9cXHJcXG5cXHQkZm9udF9ib2R5OlxcdFxcdFxcXCJNeVVuZGVyd29vZFxcXCI7XFxyXFxuXFx0JGZvbnRfZGlzcGxheTpcXHRcXFwiQW5jaWVudE1lZGl1bVxcXCI7XFxyXFxuXFx0JGZvbnRfYWx0OlxcdFxcdFxcdFxcXCJJbXBhY3RMYWJlbFxcXCI7XFxyXFxuXFxyXFxuLyoqKioqIEZvbnQgU2l6ZXMgKioqKiovXFxyXFxuXFx0JGZvbnRfc2l6ZV9oZWFkaW5nOlxcdDY1cHg7XFxyXFxuXFx0JGZvbnRfc2l6ZV9zdWJoZWFkOlxcdDM2cHg7XFxyXFxuXFx0JGZvbnRfc2l6ZV9ib2R5OlxcdFxcdDIwcHg7XFxyXFxuXFx0JGZvbnRfc2l6ZV9kZXRhaWw6XFx0MTZweDtcXHJcXG5cXHJcXG4vKioqKiogTGV0dGVyIFNwYWNpbmcgKioqKiovXFxyXFxuXFx0JGxldHRlclNwYWNpbmdXaWRlOlxcdFxcdDAuMDM1ZW07XFxyXFxuXFx0JGxldHRlclNwYWNpbmdOb3JtYWw6XFx0MC4wMzVlbTtcXHJcXG5cXHJcXG4vKioqKiogQ29udGVudCBXaWR0aHMgKioqKiovXFxyXFxuXFx0JGNvbnRlbnRfd2lkdGhfczogXFx0NjUwcHg7XFxyXFxuXFx0JGNvbnRlbnRfd2lkdGhfbTogXFx0OTIwcHg7XFxyXFxuXFx0JGNvbnRlbnRfd2lkdGhfbDogXFx0MTQ1MHB4O1xcclxcblxcclxcblxcclxcbi8qKioqKiBUcmFuc2l0aW9uIFRpbWluZ3MgKioqKiovXFxyXFxuXFx0JHRyYW5zaXRpb25fZmFzdDpcXHRcXHQwLjFzIGVhc2UtaW4tb3V0O1xcclxcblxcdCR0cmFuc2l0aW9uX21lZGl1bTpcXHQwLjI1cyBlYXNlLWluLW91dDtcXHJcXG5cXHQkdHJhbnNpdGlvbl9zbG93OlxcdFxcdDAuNXMgZWFzZS1pbi1vdXQ7XFxyXFxuXFxyXFxuXFxyXFxuLyoqKioqIFNoYWRvd3MgKioqKiovXFxyXFxuXFxyXFxuXFx0Lyogc291cmNlOiBodHRwczovL2JydW1tLmFmL3NoYWRvd3MgKi9cXHJcXG5cXHQkbmljZV9zaGFkb3c6XFxyXFxuXFx0XFx0MCAyLjhweCAyLjJweCByZ2JhKDAsIDAsIDAsIDAuMDIpLFxcclxcblxcdFxcdDAgNi43cHggNS4zcHggcmdiYSgwLCAwLCAwLCAwLjAyOCksXFxyXFxuXFx0XFx0MCAxMi41cHggMTBweCByZ2JhKDAsIDAsIDAsIDAuMDM1KSxcXHJcXG5cXHRcXHQwIDIyLjNweCAxNy45cHggcmdiYSgwLCAwLCAwLCAwLjA0MiksXFxyXFxuXFx0XFx0MCA0MS44cHggMzMuNHB4IHJnYmEoMCwgMCwgMCwgMC4wNSksXFxyXFxuXFx0XFx0MCAxMDBweCA4MHB4IHJnYmEoMCwgMCwgMCwgMC4wNyk7XFxyXFxuXFxyXFxuXFxyXFxuXFx0JHRleHQtc2hhZG93LXJlZDpcXHJcXG5cXHRcXHQxcHggMXB4ICRyZWQsIFxcclxcblxcdFxcdDJweCAycHggJHJlZCwgXFxyXFxuXFx0XFx0M3B4IDNweCAkcmVkLCBcXHJcXG5cXHRcXHQ0cHggNHB4ICRyZWQsIFxcclxcblxcdFxcdDVweCA1cHggJHJlZDtcXHJcXG5cXHQgIFxcclxcblxcdCR0ZXh0LWdsb3ctcmVkOlxcclxcblxcdFxcdDAgMCAxdncgJHJlZCwgXFxyXFxuXFx0XFx0MCAwIDN2dyAkcmVkLCBcXHJcXG5cXHRcXHQwIDAgMTB2dyAkcmVkLCBcXHJcXG5cXHRcXHQwIDAgMTB2dyAkcmVkLCBcXHJcXG5cXHRcXHQwIDAgLjR2dyAkcmVkLCBcXHJcXG5cXHRcXHQuMjV2dyAuMjV2dyAuMXZ3ICM4MDY5MTQ7XFxyXFxuXCIsXCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcXHJcXG5WQVJTIEZpbGVcXHJcXG5cXHJcXG5EZXNjcmlwdGlvbjpcXHRTdG9yZSBTQ1NTIHZhcnMgaGVyZVxcclxcblxcclxcblxcclxcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qKioqKiBDb2xvciBWYXJpYWJsZXMgKioqKiovXFxuLyoqKioqIE5hbWVkIENvbG9ycyAqKioqKi9cXG4vKioqKiogRm9udHMgKioqKiovXFxuLyoqKioqIEZvbnQgU2l6ZXMgKioqKiovXFxuLyoqKioqIExldHRlciBTcGFjaW5nICoqKioqL1xcbi8qKioqKiBDb250ZW50IFdpZHRocyAqKioqKi9cXG4vKioqKiogVHJhbnNpdGlvbiBUaW1pbmdzICoqKioqL1xcbi8qKioqKiBTaGFkb3dzICoqKioqL1xcbi8qIHNvdXJjZTogaHR0cHM6Ly9icnVtbS5hZi9zaGFkb3dzICovXFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXFxyXFxuTUlYSU5TIEZpbGVcXHJcXG5cXHJcXG5EZXNjcmlwdGlvbjpcXHRTdG9yZSBTQ1NTIG1peGlucyBoZXJlXFxyXFxuXFxyXFxuQ2FsbDogQGluY2x1ZGUgYmFja2dyb3VuZFN0YW5kYXJkO1xcclxcblxcclxcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi5oZWFkZXIge1xcbiAgd2lkdGg6IDEwMCU7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjRDFEM0Q0OyB9XFxuXFxuLmNvbnRhaW5lciB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleC1kaXJlY3Rpb246IHJvdztcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47IH1cXG5cXG4uY29udGVudExlZnQge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBtYXgtd2lkdGg6IDEwMCU7IH1cXG4gIC5jb250ZW50TGVmdCAubG9nbyB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBwYWRkaW5nOiAxMHB4O1xcbiAgICBtYXJnaW4tcmlnaHQ6IDMwcHg7XFxuICAgIGJvcmRlcjogbm9uZTsgfVxcbiAgLmNvbnRlbnRMZWZ0IC50aXRsZSB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIGZvbnQtc2l6ZTogNjVweDtcXG4gICAgcGFkZGluZzogMTBweCAwOyB9XFxuXFxuLmNvbnRlbnRSaWdodCB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleC1kaXJlY3Rpb246IHJvdztcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgbWF4LXdpZHRoOiBjYWxjKDEwMCUgLSAkc3RhdGljX3dpZHRoKTsgfVxcblwiLFwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXFxyXFxuTUlYSU5TIEZpbGVcXHJcXG5cXHJcXG5EZXNjcmlwdGlvbjpcXHRTdG9yZSBTQ1NTIG1peGlucyBoZXJlXFxyXFxuXFxyXFxuQ2FsbDogQGluY2x1ZGUgYmFja2dyb3VuZFN0YW5kYXJkO1xcclxcblxcclxcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcclxcblxcclxcblxcclxcbkBtaXhpbiBmbGV4X2NlbnRlciB7XFxyXFxuXFx0ZGlzcGxheTogZmxleDtcXHJcXG5cXHRmbGV4LWRpcmVjdGlvbjogcm93O1xcclxcblxcdGp1c3RpZnktY29udGVudDogY2VudGVyO1xcclxcblxcdGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxyXFxufVxcclxcblxcclxcbkBtaXhpbiBiYWNrZ3JvdW5kU3RhbmRhcmQge1xcclxcblxcdGJhY2tncm91bmQtc2l6ZTogY292ZXI7XFxyXFxuXFx0YmFja2dyb3VuZC1wb3NpdGlvbjogY2VudGVyO1xcclxcblxcdGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxyXFxufVxcclxcblxcclxcbkBtaXhpbiBzb2xpZFNoYWRvd0hvdmVyIHtcXHJcXG5cXHQmOmhvdmVye1xcclxcblxcdFxcdHRleHQtc2hhZG93OiAkdGV4dC1zaGFkb3ctcmVkO1xcclxcblxcdH1cXHJcXG59XFxyXFxuXFxyXFxuQG1peGluIG1heFdpZHRoKCRtYXhXaWR0aCkge1xcclxcblxcdHdpZHRoOiAxMDAlO1xcclxcblxcdG1heC13aWR0aDogJG1heFdpZHRoO1xcclxcblxcdG1hcmdpbi1sZWZ0OiBhdXRvO1xcclxcblxcdG1hcmdpbi1yaWdodDogYXV0bztcXHJcXG59XFxyXFxuXFxyXFxuQG1peGluIHBhcGVyVGV4dHVyZXtcXHJcXG5cXHQmOmFmdGVye1xcclxcblxcdFxcdGNvbnRlbnQ6Jyc7XFxyXFxuXFx0XFx0cG9zaXRpb246IGFic29sdXRlO1xcclxcblxcdFxcdGhlaWdodDogMTAwJTtcXHJcXG5cXHRcXHR3aWR0aDogMTAwJTtcXHJcXG5cXHRcXHR0b3A6IDA7XFxyXFxuXFx0XFx0bGVmdDogMDtcXHJcXG5cXHRcXHRvcGFjaXR5OiAuNTtcXHJcXG5cXHRcXHRwb2ludGVyLWV2ZW50czogbm9uZTtcXHJcXG5cXHRcXHRiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJy9pbWcvdGV4dHVyZXMvbmF0dXJhbC1wYXBlci5wbmcnKTtcXHJcXG5cXHRcXHRiYWNrZ3JvdW5kLXJlcGVhdDogcmVwZWF0O1xcclxcblxcdFxcdC8vbWl4LWJsZW5kLW1vZGU6IGxpZ2h0ZW47XFxyXFxuXFx0XFx0Ly9maWx0ZXI6IGNvbnRyYXN0KDEuNSk7XFxyXFxuXFx0XFx0YmFja2dyb3VuZC1zaXplOiBjb3ZlcjtcXHJcXG5cXHR9XFxyXFxufVwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ubG9jYWxzID0ge1xuXHRcImhlYWRlclwiOiBcIkhlYWRlcl9oZWFkZXJfXzJ0WGszXCIsXG5cdFwiY29udGFpbmVyXCI6IFwiSGVhZGVyX2NvbnRhaW5lcl9fYjZVdXhcIixcblx0XCJjb250ZW50TGVmdFwiOiBcIkhlYWRlcl9jb250ZW50TGVmdF9fSFBkUU9cIixcblx0XCJsb2dvXCI6IFwiSGVhZGVyX2xvZ29fXzNTYjU5XCIsXG5cdFwidGl0bGVcIjogXCJIZWFkZXJfdGl0bGVfXzFoRVU3XCIsXG5cdFwiY29udGVudFJpZ2h0XCI6IFwiSGVhZGVyX2NvbnRlbnRSaWdodF9fMUYzVlRcIlxufTtcbm1vZHVsZS5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iLCIvLyBJbXBvcnRzXG52YXIgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fID0gcmVxdWlyZShcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9hcGkuanNcIik7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18odHJ1ZSk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcXHJcXG5WQVJTIEZpbGVcXHJcXG5cXHJcXG5EZXNjcmlwdGlvbjpcXHRTdG9yZSBTQ1NTIHZhcnMgaGVyZVxcclxcblxcclxcblxcclxcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qKioqKiBDb2xvciBWYXJpYWJsZXMgKioqKiovXFxuLyoqKioqIE5hbWVkIENvbG9ycyAqKioqKi9cXG4vKioqKiogRm9udHMgKioqKiovXFxuLyoqKioqIEZvbnQgU2l6ZXMgKioqKiovXFxuLyoqKioqIExldHRlciBTcGFjaW5nICoqKioqL1xcbi8qKioqKiBDb250ZW50IFdpZHRocyAqKioqKi9cXG4vKioqKiogVHJhbnNpdGlvbiBUaW1pbmdzICoqKioqL1xcbi8qKioqKiBTaGFkb3dzICoqKioqL1xcbi8qIHNvdXJjZTogaHR0cHM6Ly9icnVtbS5hZi9zaGFkb3dzICovXFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXFxyXFxuTUlYSU5TIEZpbGVcXHJcXG5cXHJcXG5EZXNjcmlwdGlvbjpcXHRTdG9yZSBTQ1NTIG1peGlucyBoZXJlXFxyXFxuXFxyXFxuQ2FsbDogQGluY2x1ZGUgYmFja2dyb3VuZFN0YW5kYXJkO1xcclxcblxcclxcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi5TYW5kYm94X3NhbmRib3hfXzEzWEJoIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBwYWRkaW5nOiAwcHggMDsgfVxcbiAgLlNhbmRib3hfc2FuZGJveF9fMTNYQmggLlNhbmRib3hfY29udGVudF9fMVNFeXkge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRDFEM0Q0O1xcbiAgICBwYWRkaW5nOiAyNXB4IDM1cHggMzVweDtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGJvcmRlci1yYWRpdXM6IDUwcHg7XFxuICAgIGJveC1zaGFkb3c6IDAgMi44cHggMi4ycHggcmdiYSgwLCAwLCAwLCAwLjAyKSwgMCA2LjdweCA1LjNweCByZ2JhKDAsIDAsIDAsIDAuMDI4KSwgMCAxMi41cHggMTBweCByZ2JhKDAsIDAsIDAsIDAuMDM1KSwgMCAyMi4zcHggMTcuOXB4IHJnYmEoMCwgMCwgMCwgMC4wNDIpLCAwIDQxLjhweCAzMy40cHggcmdiYSgwLCAwLCAwLCAwLjA1KSwgMCAxMDBweCA4MHB4IHJnYmEoMCwgMCwgMCwgMC4wNyk7IH1cXG4gIC5TYW5kYm94X3NhbmRib3hfXzEzWEJoIC5TYW5kYm94X3RpdGxlX19RODZhViB7XFxuICAgIGZvbnQtc2l6ZTogMTJweDtcXG4gICAgbWFyZ2luLWJvdHRvbTogMTVweDtcXG4gICAgZGlzcGxheTogYmxvY2s7IH1cXG4gIC5TYW5kYm94X3NhbmRib3hfXzEzWEJoIC5TYW5kYm94X2lubmVyX18xRnlHcyB7XFxuICAgIHBhZGRpbmc6IDM1cHg7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIGJvcmRlcjogMnB4IGRhc2hlZCAjMjEyMTIxO1xcbiAgICBtaW4taGVpZ2h0OiA1MDBweDtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGZsZXgtd3JhcDogd3JhcDsgfVxcblwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uLi8uLi8uLi9zdHlsZXMvdmFycy5zY3NzXCIsXCJ3ZWJwYWNrOi8vU2FuZGJveC5tb2R1bGUuc2Nzc1wiLFwid2VicGFjazovLy4uLy4uLy4uL3N0eWxlcy9taXhpbnMuc2Nzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTs7Ozs7O2tEQ01rRDtBREdsRCw0QkFBQTtBQVVDLHlCQUFBO0FBU0Qsa0JBQUE7QUFLQSx1QkFBQTtBQU1BLDJCQUFBO0FBSUEsMkJBQUE7QUFNQSwrQkFBQTtBQU1BLG9CQUFBO0FBRUMscUNBQUE7QUV6REQ7Ozs7Ozs7a0REdUJrRDtBQXBCbEQ7RUFDQyxjQUFjO0VBQ2QsV0FBVztFQUNYLGNBQWMsRUFBQTtFQUhmO0lBTUUseUJEUWtCO0lDUGxCLHVCQUF3QjtJQUN4QixXQUFXO0lBRVgsbUJBQW1CO0lBQ25CLGtPRGtEZ0MsRUFBQTtFQzdEbEM7SUFlRSxlQUFlO0lBQ2YsbUJBQW1CO0lBQ25CLGNBQWMsRUFBQTtFQWpCaEI7SUFxQkUsYUFBYTtJQUNiLFdBQVc7SUFDWCxZQUFZO0lBQ1osMEJEakJnQjtJQ2tCaEIsaUJBQWlCO0lBQ2pCLGFBQWE7SUFDYix1QkFBdUI7SUFDdkIsbUJBQW1CO0lBQ25CLGVBQWUsRUFBQVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcXHJcXG5WQVJTIEZpbGVcXHJcXG5cXHJcXG5EZXNjcmlwdGlvbjpcXHRTdG9yZSBTQ1NTIHZhcnMgaGVyZVxcclxcblxcclxcblxcclxcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcclxcblxcclxcblxcclxcbi8qKioqKiBDb2xvciBWYXJpYWJsZXMgKioqKiovXFxyXFxuXFx0JGJsYWNrOiBcXHRcXHQjMjEyMTIxO1xcclxcblxcdCR3aGl0ZTogXFx0XFx0I2ZhZmFmYTtcXHJcXG5cXHQkZ3JleV8xOlxcdFxcdCNlY2VjZWM7XFxyXFxuXFx0JGdyZXlfMjpcXHRcXHQjM2UzZTNlO1xcclxcblxcclxcblxcdCRyZWQ6IFxcdFxcdFxcdCNmYjAwMDA7XFxyXFxuXFx0XFxyXFxuXFx0JG5hc2FfZ3JleTpcXHQjRDFEM0Q0O1xcclxcblxcclxcblxcdC8qKioqKiBOYW1lZCBDb2xvcnMgKioqKiovXFxyXFxuXFx0XFx0JHByaW1hcnlfY29sb3I6XFx0XFx0JGJsYWNrO1xcclxcblxcdFxcdCRzZWNvbmRhcnlfY29sb3I6XFx0XFx0JHdoaXRlO1xcclxcblxcclxcblxcdFxcdCRiYWNrZ3JvdW5kX2NvbG9yOlxcdCR3aGl0ZTtcXHJcXG5cXHRcXHQkdGV4dF9jb2xvcjpcXHRcXHRcXHQkYmxhY2s7XFxyXFxuXFx0XFx0JGFjY2VudF9jb2xvcjpcXHRcXHQkZ3JleV8xO1xcclxcblxcclxcblxcclxcbi8qKioqKiBGb250cyAqKioqKi9cXHJcXG5cXHQkZm9udF9ib2R5OlxcdFxcdFxcXCJNeVVuZGVyd29vZFxcXCI7XFxyXFxuXFx0JGZvbnRfZGlzcGxheTpcXHRcXFwiQW5jaWVudE1lZGl1bVxcXCI7XFxyXFxuXFx0JGZvbnRfYWx0OlxcdFxcdFxcdFxcXCJJbXBhY3RMYWJlbFxcXCI7XFxyXFxuXFxyXFxuLyoqKioqIEZvbnQgU2l6ZXMgKioqKiovXFxyXFxuXFx0JGZvbnRfc2l6ZV9oZWFkaW5nOlxcdDY1cHg7XFxyXFxuXFx0JGZvbnRfc2l6ZV9zdWJoZWFkOlxcdDM2cHg7XFxyXFxuXFx0JGZvbnRfc2l6ZV9ib2R5OlxcdFxcdDIwcHg7XFxyXFxuXFx0JGZvbnRfc2l6ZV9kZXRhaWw6XFx0MTZweDtcXHJcXG5cXHJcXG4vKioqKiogTGV0dGVyIFNwYWNpbmcgKioqKiovXFxyXFxuXFx0JGxldHRlclNwYWNpbmdXaWRlOlxcdFxcdDAuMDM1ZW07XFxyXFxuXFx0JGxldHRlclNwYWNpbmdOb3JtYWw6XFx0MC4wMzVlbTtcXHJcXG5cXHJcXG4vKioqKiogQ29udGVudCBXaWR0aHMgKioqKiovXFxyXFxuXFx0JGNvbnRlbnRfd2lkdGhfczogXFx0NjUwcHg7XFxyXFxuXFx0JGNvbnRlbnRfd2lkdGhfbTogXFx0OTIwcHg7XFxyXFxuXFx0JGNvbnRlbnRfd2lkdGhfbDogXFx0MTQ1MHB4O1xcclxcblxcclxcblxcclxcbi8qKioqKiBUcmFuc2l0aW9uIFRpbWluZ3MgKioqKiovXFxyXFxuXFx0JHRyYW5zaXRpb25fZmFzdDpcXHRcXHQwLjFzIGVhc2UtaW4tb3V0O1xcclxcblxcdCR0cmFuc2l0aW9uX21lZGl1bTpcXHQwLjI1cyBlYXNlLWluLW91dDtcXHJcXG5cXHQkdHJhbnNpdGlvbl9zbG93OlxcdFxcdDAuNXMgZWFzZS1pbi1vdXQ7XFxyXFxuXFxyXFxuXFxyXFxuLyoqKioqIFNoYWRvd3MgKioqKiovXFxyXFxuXFxyXFxuXFx0Lyogc291cmNlOiBodHRwczovL2JydW1tLmFmL3NoYWRvd3MgKi9cXHJcXG5cXHQkbmljZV9zaGFkb3c6XFxyXFxuXFx0XFx0MCAyLjhweCAyLjJweCByZ2JhKDAsIDAsIDAsIDAuMDIpLFxcclxcblxcdFxcdDAgNi43cHggNS4zcHggcmdiYSgwLCAwLCAwLCAwLjAyOCksXFxyXFxuXFx0XFx0MCAxMi41cHggMTBweCByZ2JhKDAsIDAsIDAsIDAuMDM1KSxcXHJcXG5cXHRcXHQwIDIyLjNweCAxNy45cHggcmdiYSgwLCAwLCAwLCAwLjA0MiksXFxyXFxuXFx0XFx0MCA0MS44cHggMzMuNHB4IHJnYmEoMCwgMCwgMCwgMC4wNSksXFxyXFxuXFx0XFx0MCAxMDBweCA4MHB4IHJnYmEoMCwgMCwgMCwgMC4wNyk7XFxyXFxuXFxyXFxuXFxyXFxuXFx0JHRleHQtc2hhZG93LXJlZDpcXHJcXG5cXHRcXHQxcHggMXB4ICRyZWQsIFxcclxcblxcdFxcdDJweCAycHggJHJlZCwgXFxyXFxuXFx0XFx0M3B4IDNweCAkcmVkLCBcXHJcXG5cXHRcXHQ0cHggNHB4ICRyZWQsIFxcclxcblxcdFxcdDVweCA1cHggJHJlZDtcXHJcXG5cXHQgIFxcclxcblxcdCR0ZXh0LWdsb3ctcmVkOlxcclxcblxcdFxcdDAgMCAxdncgJHJlZCwgXFxyXFxuXFx0XFx0MCAwIDN2dyAkcmVkLCBcXHJcXG5cXHRcXHQwIDAgMTB2dyAkcmVkLCBcXHJcXG5cXHRcXHQwIDAgMTB2dyAkcmVkLCBcXHJcXG5cXHRcXHQwIDAgLjR2dyAkcmVkLCBcXHJcXG5cXHRcXHQuMjV2dyAuMjV2dyAuMXZ3ICM4MDY5MTQ7XFxyXFxuXCIsXCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcXHJcXG5WQVJTIEZpbGVcXHJcXG5cXHJcXG5EZXNjcmlwdGlvbjpcXHRTdG9yZSBTQ1NTIHZhcnMgaGVyZVxcclxcblxcclxcblxcclxcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qKioqKiBDb2xvciBWYXJpYWJsZXMgKioqKiovXFxuLyoqKioqIE5hbWVkIENvbG9ycyAqKioqKi9cXG4vKioqKiogRm9udHMgKioqKiovXFxuLyoqKioqIEZvbnQgU2l6ZXMgKioqKiovXFxuLyoqKioqIExldHRlciBTcGFjaW5nICoqKioqL1xcbi8qKioqKiBDb250ZW50IFdpZHRocyAqKioqKi9cXG4vKioqKiogVHJhbnNpdGlvbiBUaW1pbmdzICoqKioqL1xcbi8qKioqKiBTaGFkb3dzICoqKioqL1xcbi8qIHNvdXJjZTogaHR0cHM6Ly9icnVtbS5hZi9zaGFkb3dzICovXFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXFxyXFxuTUlYSU5TIEZpbGVcXHJcXG5cXHJcXG5EZXNjcmlwdGlvbjpcXHRTdG9yZSBTQ1NTIG1peGlucyBoZXJlXFxyXFxuXFxyXFxuQ2FsbDogQGluY2x1ZGUgYmFja2dyb3VuZFN0YW5kYXJkO1xcclxcblxcclxcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi5zYW5kYm94IHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBwYWRkaW5nOiAwcHggMDsgfVxcbiAgLnNhbmRib3ggLmNvbnRlbnQge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRDFEM0Q0O1xcbiAgICBwYWRkaW5nOiAyNXB4IDM1cHggMzVweDtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGJvcmRlci1yYWRpdXM6IDUwcHg7XFxuICAgIGJveC1zaGFkb3c6IDAgMi44cHggMi4ycHggcmdiYSgwLCAwLCAwLCAwLjAyKSwgMCA2LjdweCA1LjNweCByZ2JhKDAsIDAsIDAsIDAuMDI4KSwgMCAxMi41cHggMTBweCByZ2JhKDAsIDAsIDAsIDAuMDM1KSwgMCAyMi4zcHggMTcuOXB4IHJnYmEoMCwgMCwgMCwgMC4wNDIpLCAwIDQxLjhweCAzMy40cHggcmdiYSgwLCAwLCAwLCAwLjA1KSwgMCAxMDBweCA4MHB4IHJnYmEoMCwgMCwgMCwgMC4wNyk7IH1cXG4gIC5zYW5kYm94IC50aXRsZSB7XFxuICAgIGZvbnQtc2l6ZTogMTJweDtcXG4gICAgbWFyZ2luLWJvdHRvbTogMTVweDtcXG4gICAgZGlzcGxheTogYmxvY2s7IH1cXG4gIC5zYW5kYm94IC5pbm5lciB7XFxuICAgIHBhZGRpbmc6IDM1cHg7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIGJvcmRlcjogMnB4IGRhc2hlZCAjMjEyMTIxO1xcbiAgICBtaW4taGVpZ2h0OiA1MDBweDtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGZsZXgtd3JhcDogd3JhcDsgfVxcblwiLFwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXFxyXFxuTUlYSU5TIEZpbGVcXHJcXG5cXHJcXG5EZXNjcmlwdGlvbjpcXHRTdG9yZSBTQ1NTIG1peGlucyBoZXJlXFxyXFxuXFxyXFxuQ2FsbDogQGluY2x1ZGUgYmFja2dyb3VuZFN0YW5kYXJkO1xcclxcblxcclxcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcclxcblxcclxcblxcclxcbkBtaXhpbiBmbGV4X2NlbnRlciB7XFxyXFxuXFx0ZGlzcGxheTogZmxleDtcXHJcXG5cXHRmbGV4LWRpcmVjdGlvbjogcm93O1xcclxcblxcdGp1c3RpZnktY29udGVudDogY2VudGVyO1xcclxcblxcdGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxyXFxufVxcclxcblxcclxcbkBtaXhpbiBiYWNrZ3JvdW5kU3RhbmRhcmQge1xcclxcblxcdGJhY2tncm91bmQtc2l6ZTogY292ZXI7XFxyXFxuXFx0YmFja2dyb3VuZC1wb3NpdGlvbjogY2VudGVyO1xcclxcblxcdGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxyXFxufVxcclxcblxcclxcbkBtaXhpbiBzb2xpZFNoYWRvd0hvdmVyIHtcXHJcXG5cXHQmOmhvdmVye1xcclxcblxcdFxcdHRleHQtc2hhZG93OiAkdGV4dC1zaGFkb3ctcmVkO1xcclxcblxcdH1cXHJcXG59XFxyXFxuXFxyXFxuQG1peGluIG1heFdpZHRoKCRtYXhXaWR0aCkge1xcclxcblxcdHdpZHRoOiAxMDAlO1xcclxcblxcdG1heC13aWR0aDogJG1heFdpZHRoO1xcclxcblxcdG1hcmdpbi1sZWZ0OiBhdXRvO1xcclxcblxcdG1hcmdpbi1yaWdodDogYXV0bztcXHJcXG59XFxyXFxuXFxyXFxuQG1peGluIHBhcGVyVGV4dHVyZXtcXHJcXG5cXHQmOmFmdGVye1xcclxcblxcdFxcdGNvbnRlbnQ6Jyc7XFxyXFxuXFx0XFx0cG9zaXRpb246IGFic29sdXRlO1xcclxcblxcdFxcdGhlaWdodDogMTAwJTtcXHJcXG5cXHRcXHR3aWR0aDogMTAwJTtcXHJcXG5cXHRcXHR0b3A6IDA7XFxyXFxuXFx0XFx0bGVmdDogMDtcXHJcXG5cXHRcXHRvcGFjaXR5OiAuNTtcXHJcXG5cXHRcXHRwb2ludGVyLWV2ZW50czogbm9uZTtcXHJcXG5cXHRcXHRiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJy9pbWcvdGV4dHVyZXMvbmF0dXJhbC1wYXBlci5wbmcnKTtcXHJcXG5cXHRcXHRiYWNrZ3JvdW5kLXJlcGVhdDogcmVwZWF0O1xcclxcblxcdFxcdC8vbWl4LWJsZW5kLW1vZGU6IGxpZ2h0ZW47XFxyXFxuXFx0XFx0Ly9maWx0ZXI6IGNvbnRyYXN0KDEuNSk7XFxyXFxuXFx0XFx0YmFja2dyb3VuZC1zaXplOiBjb3ZlcjtcXHJcXG5cXHR9XFxyXFxufVwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ubG9jYWxzID0ge1xuXHRcInNhbmRib3hcIjogXCJTYW5kYm94X3NhbmRib3hfXzEzWEJoXCIsXG5cdFwiY29udGVudFwiOiBcIlNhbmRib3hfY29udGVudF9fMVNFeXlcIixcblx0XCJ0aXRsZVwiOiBcIlNhbmRib3hfdGl0bGVfX1E4NmFWXCIsXG5cdFwiaW5uZXJcIjogXCJTYW5kYm94X2lubmVyX18xRnlHc1wiXG59O1xubW9kdWxlLmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIm1vZHVsZS5leHBvcnRzID1cbi8qKioqKiovIChmdW5jdGlvbigpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZXNfXyA9ICh7XG5cbi8qKiovIDkzMTpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcmlnaW5hbE1vZHVsZSkge1xuXHRpZiAoIW9yaWdpbmFsTW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xuXHRcdHZhciBtb2R1bGUgPSBPYmplY3QuY3JlYXRlKG9yaWdpbmFsTW9kdWxlKTtcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcblx0XHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJleHBvcnRzXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWVcblx0XHR9KTtcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcblx0fVxuXHRyZXR1cm4gbW9kdWxlO1xufTtcblxuXG4vKioqLyB9KVxuXG4vKioqKioqLyBcdH0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdHZhciB0aHJldyA9IHRydWU7XG4vKioqKioqLyBcdFx0dHJ5IHtcbi8qKioqKiovIFx0XHRcdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fbmNjd3Bja19yZXF1aXJlX18pO1xuLyoqKioqKi8gXHRcdFx0dGhyZXcgPSBmYWxzZTtcbi8qKioqKiovIFx0XHR9IGZpbmFsbHkge1xuLyoqKioqKi8gXHRcdFx0aWYodGhyZXcpIGRlbGV0ZSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvY29tcGF0ICovXG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRfX25jY3dwY2tfcmVxdWlyZV9fLmFiID0gX19kaXJuYW1lICsgXCIvXCI7LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Ly8gbW9kdWxlIGV4cG9ydHMgbXVzdCBiZSByZXR1cm5lZCBmcm9tIHJ1bnRpbWUgc28gZW50cnkgaW5saW5pbmcgaXMgZGlzYWJsZWRcbi8qKioqKiovIFx0Ly8gc3RhcnR1cFxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fbmNjd3Bja19yZXF1aXJlX18oOTMxKTtcbi8qKioqKiovIH0pKClcbjsiLCJtb2R1bGUuZXhwb3J0cyA9XG4vKioqKioqLyAoZnVuY3Rpb24oKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVzX18gPSAoe1xuXG4vKioqLyA4ODA6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XG5cdGlmICghbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxuXHRcdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcblx0fVxuXHRyZXR1cm4gbW9kdWxlO1xufTtcblxuXG4vKioqLyB9KVxuXG4vKioqKioqLyBcdH0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdHZhciB0aHJldyA9IHRydWU7XG4vKioqKioqLyBcdFx0dHJ5IHtcbi8qKioqKiovIFx0XHRcdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fbmNjd3Bja19yZXF1aXJlX18pO1xuLyoqKioqKi8gXHRcdFx0dGhyZXcgPSBmYWxzZTtcbi8qKioqKiovIFx0XHR9IGZpbmFsbHkge1xuLyoqKioqKi8gXHRcdFx0aWYodGhyZXcpIGRlbGV0ZSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvY29tcGF0ICovXG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRfX25jY3dwY2tfcmVxdWlyZV9fLmFiID0gX19kaXJuYW1lICsgXCIvXCI7LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Ly8gbW9kdWxlIGV4cG9ydHMgbXVzdCBiZSByZXR1cm5lZCBmcm9tIHJ1bnRpbWUgc28gZW50cnkgaW5saW5pbmcgaXMgZGlzYWJsZWRcbi8qKioqKiovIFx0Ly8gc3RhcnR1cFxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fbmNjd3Bja19yZXF1aXJlX18oODgwKTtcbi8qKioqKiovIH0pKClcbjsiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5cbmV4cG9ydCBjb25zdCBBbXBTdGF0ZUNvbnRleHQ6IFJlYWN0LkNvbnRleHQ8YW55PiA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoe30pXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIEFtcFN0YXRlQ29udGV4dC5kaXNwbGF5TmFtZSA9ICdBbXBTdGF0ZUNvbnRleHQnXG59XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBBbXBTdGF0ZUNvbnRleHQgfSBmcm9tICcuL2FtcC1jb250ZXh0J1xuXG5leHBvcnQgZnVuY3Rpb24gaXNJbkFtcE1vZGUoe1xuICBhbXBGaXJzdCA9IGZhbHNlLFxuICBoeWJyaWQgPSBmYWxzZSxcbiAgaGFzUXVlcnkgPSBmYWxzZSxcbn0gPSB7fSk6IGJvb2xlYW4ge1xuICByZXR1cm4gYW1wRmlyc3QgfHwgKGh5YnJpZCAmJiBoYXNRdWVyeSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUFtcCgpOiBib29sZWFuIHtcbiAgLy8gRG9uJ3QgYXNzaWduIHRoZSBjb250ZXh0IHZhbHVlIHRvIGEgdmFyaWFibGUgdG8gc2F2ZSBieXRlc1xuICByZXR1cm4gaXNJbkFtcE1vZGUoUmVhY3QudXNlQ29udGV4dChBbXBTdGF0ZUNvbnRleHQpKVxufVxuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuXG5leHBvcnQgY29uc3QgSGVhZE1hbmFnZXJDb250ZXh0OiBSZWFjdC5Db250ZXh0PHtcbiAgdXBkYXRlSGVhZD86IChzdGF0ZTogYW55KSA9PiB2b2lkXG4gIG1vdW50ZWRJbnN0YW5jZXM/OiBhbnlcbiAgdXBkYXRlU2NyaXB0cz86IChzdGF0ZTogYW55KSA9PiB2b2lkXG4gIHNjcmlwdHM/OiBhbnlcbn0+ID0gUmVhY3QuY3JlYXRlQ29udGV4dCh7fSlcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgSGVhZE1hbmFnZXJDb250ZXh0LmRpc3BsYXlOYW1lID0gJ0hlYWRNYW5hZ2VyQ29udGV4dCdcbn1cbiIsImltcG9ydCBSZWFjdCwgeyB1c2VDb250ZXh0IH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgRWZmZWN0IGZyb20gJy4vc2lkZS1lZmZlY3QnXG5pbXBvcnQgeyBBbXBTdGF0ZUNvbnRleHQgfSBmcm9tICcuL2FtcC1jb250ZXh0J1xuaW1wb3J0IHsgSGVhZE1hbmFnZXJDb250ZXh0IH0gZnJvbSAnLi9oZWFkLW1hbmFnZXItY29udGV4dCdcbmltcG9ydCB7IGlzSW5BbXBNb2RlIH0gZnJvbSAnLi9hbXAnXG5cbnR5cGUgV2l0aEluQW1wTW9kZSA9IHtcbiAgaW5BbXBNb2RlPzogYm9vbGVhblxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdEhlYWQoaW5BbXBNb2RlID0gZmFsc2UpOiBKU1guRWxlbWVudFtdIHtcbiAgY29uc3QgaGVhZCA9IFs8bWV0YSBjaGFyU2V0PVwidXRmLThcIiAvPl1cbiAgaWYgKCFpbkFtcE1vZGUpIHtcbiAgICBoZWFkLnB1c2goPG1ldGEgbmFtZT1cInZpZXdwb3J0XCIgY29udGVudD1cIndpZHRoPWRldmljZS13aWR0aFwiIC8+KVxuICB9XG4gIHJldHVybiBoZWFkXG59XG5cbmZ1bmN0aW9uIG9ubHlSZWFjdEVsZW1lbnQoXG4gIGxpc3Q6IEFycmF5PFJlYWN0LlJlYWN0RWxlbWVudDxhbnk+PixcbiAgY2hpbGQ6IFJlYWN0LlJlYWN0Q2hpbGRcbik6IEFycmF5PFJlYWN0LlJlYWN0RWxlbWVudDxhbnk+PiB7XG4gIC8vIFJlYWN0IGNoaWxkcmVuIGNhbiBiZSBcInN0cmluZ1wiIG9yIFwibnVtYmVyXCIgaW4gdGhpcyBjYXNlIHdlIGlnbm9yZSB0aGVtIGZvciBiYWNrd2FyZHMgY29tcGF0XG4gIGlmICh0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBjaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gbGlzdFxuICB9XG4gIC8vIEFkZHMgc3VwcG9ydCBmb3IgUmVhY3QuRnJhZ21lbnRcbiAgaWYgKGNoaWxkLnR5cGUgPT09IFJlYWN0LkZyYWdtZW50KSB7XG4gICAgcmV0dXJuIGxpc3QuY29uY2F0KFxuICAgICAgUmVhY3QuQ2hpbGRyZW4udG9BcnJheShjaGlsZC5wcm9wcy5jaGlsZHJlbikucmVkdWNlKFxuICAgICAgICAoXG4gICAgICAgICAgZnJhZ21lbnRMaXN0OiBBcnJheTxSZWFjdC5SZWFjdEVsZW1lbnQ8YW55Pj4sXG4gICAgICAgICAgZnJhZ21lbnRDaGlsZDogUmVhY3QuUmVhY3RDaGlsZFxuICAgICAgICApOiBBcnJheTxSZWFjdC5SZWFjdEVsZW1lbnQ8YW55Pj4gPT4ge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHR5cGVvZiBmcmFnbWVudENoaWxkID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgdHlwZW9mIGZyYWdtZW50Q2hpbGQgPT09ICdudW1iZXInXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gZnJhZ21lbnRMaXN0XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmcmFnbWVudExpc3QuY29uY2F0KGZyYWdtZW50Q2hpbGQpXG4gICAgICAgIH0sXG4gICAgICAgIFtdXG4gICAgICApXG4gICAgKVxuICB9XG4gIHJldHVybiBsaXN0LmNvbmNhdChjaGlsZClcbn1cblxuY29uc3QgTUVUQVRZUEVTID0gWyduYW1lJywgJ2h0dHBFcXVpdicsICdjaGFyU2V0JywgJ2l0ZW1Qcm9wJ11cblxuLypcbiByZXR1cm5zIGEgZnVuY3Rpb24gZm9yIGZpbHRlcmluZyBoZWFkIGNoaWxkIGVsZW1lbnRzXG4gd2hpY2ggc2hvdWxkbid0IGJlIGR1cGxpY2F0ZWQsIGxpa2UgPHRpdGxlLz5cbiBBbHNvIGFkZHMgc3VwcG9ydCBmb3IgZGVkdXBsaWNhdGVkIGBrZXlgIHByb3BlcnRpZXNcbiovXG5mdW5jdGlvbiB1bmlxdWUoKSB7XG4gIGNvbnN0IGtleXMgPSBuZXcgU2V0KClcbiAgY29uc3QgdGFncyA9IG5ldyBTZXQoKVxuICBjb25zdCBtZXRhVHlwZXMgPSBuZXcgU2V0KClcbiAgY29uc3QgbWV0YUNhdGVnb3JpZXM6IHsgW21ldGF0eXBlOiBzdHJpbmddOiBTZXQ8c3RyaW5nPiB9ID0ge31cblxuICByZXR1cm4gKGg6IFJlYWN0LlJlYWN0RWxlbWVudDxhbnk+KSA9PiB7XG4gICAgbGV0IGlzVW5pcXVlID0gdHJ1ZVxuICAgIGxldCBoYXNLZXkgPSBmYWxzZVxuXG4gICAgaWYgKGgua2V5ICYmIHR5cGVvZiBoLmtleSAhPT0gJ251bWJlcicgJiYgaC5rZXkuaW5kZXhPZignJCcpID4gMCkge1xuICAgICAgaGFzS2V5ID0gdHJ1ZVxuICAgICAgY29uc3Qga2V5ID0gaC5rZXkuc2xpY2UoaC5rZXkuaW5kZXhPZignJCcpICsgMSlcbiAgICAgIGlmIChrZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgIGlzVW5pcXVlID0gZmFsc2VcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleXMuYWRkKGtleSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVmYXVsdC1jYXNlXG4gICAgc3dpdGNoIChoLnR5cGUpIHtcbiAgICAgIGNhc2UgJ3RpdGxlJzpcbiAgICAgIGNhc2UgJ2Jhc2UnOlxuICAgICAgICBpZiAodGFncy5oYXMoaC50eXBlKSkge1xuICAgICAgICAgIGlzVW5pcXVlID0gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YWdzLmFkZChoLnR5cGUpXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ21ldGEnOlxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gTUVUQVRZUEVTLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgbWV0YXR5cGUgPSBNRVRBVFlQRVNbaV1cbiAgICAgICAgICBpZiAoIWgucHJvcHMuaGFzT3duUHJvcGVydHkobWV0YXR5cGUpKSBjb250aW51ZVxuXG4gICAgICAgICAgaWYgKG1ldGF0eXBlID09PSAnY2hhclNldCcpIHtcbiAgICAgICAgICAgIGlmIChtZXRhVHlwZXMuaGFzKG1ldGF0eXBlKSkge1xuICAgICAgICAgICAgICBpc1VuaXF1ZSA9IGZhbHNlXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtZXRhVHlwZXMuYWRkKG1ldGF0eXBlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjYXRlZ29yeSA9IGgucHJvcHNbbWV0YXR5cGVdXG4gICAgICAgICAgICBjb25zdCBjYXRlZ29yaWVzID0gbWV0YUNhdGVnb3JpZXNbbWV0YXR5cGVdIHx8IG5ldyBTZXQoKVxuICAgICAgICAgICAgaWYgKChtZXRhdHlwZSAhPT0gJ25hbWUnIHx8ICFoYXNLZXkpICYmIGNhdGVnb3JpZXMuaGFzKGNhdGVnb3J5KSkge1xuICAgICAgICAgICAgICBpc1VuaXF1ZSA9IGZhbHNlXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjYXRlZ29yaWVzLmFkZChjYXRlZ29yeSlcbiAgICAgICAgICAgICAgbWV0YUNhdGVnb3JpZXNbbWV0YXR5cGVdID0gY2F0ZWdvcmllc1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgIH1cblxuICAgIHJldHVybiBpc1VuaXF1ZVxuICB9XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBoZWFkRWxlbWVudHMgTGlzdCBvZiBtdWx0aXBsZSA8SGVhZD4gaW5zdGFuY2VzXG4gKi9cbmZ1bmN0aW9uIHJlZHVjZUNvbXBvbmVudHMoXG4gIGhlYWRFbGVtZW50czogQXJyYXk8UmVhY3QuUmVhY3RFbGVtZW50PGFueT4+LFxuICBwcm9wczogV2l0aEluQW1wTW9kZVxuKSB7XG4gIHJldHVybiBoZWFkRWxlbWVudHNcbiAgICAucmVkdWNlKFxuICAgICAgKGxpc3Q6IFJlYWN0LlJlYWN0Q2hpbGRbXSwgaGVhZEVsZW1lbnQ6IFJlYWN0LlJlYWN0RWxlbWVudDxhbnk+KSA9PiB7XG4gICAgICAgIGNvbnN0IGhlYWRFbGVtZW50Q2hpbGRyZW4gPSBSZWFjdC5DaGlsZHJlbi50b0FycmF5KFxuICAgICAgICAgIGhlYWRFbGVtZW50LnByb3BzLmNoaWxkcmVuXG4gICAgICAgIClcbiAgICAgICAgcmV0dXJuIGxpc3QuY29uY2F0KGhlYWRFbGVtZW50Q2hpbGRyZW4pXG4gICAgICB9LFxuICAgICAgW11cbiAgICApXG4gICAgLnJlZHVjZShvbmx5UmVhY3RFbGVtZW50LCBbXSlcbiAgICAucmV2ZXJzZSgpXG4gICAgLmNvbmNhdChkZWZhdWx0SGVhZChwcm9wcy5pbkFtcE1vZGUpKVxuICAgIC5maWx0ZXIodW5pcXVlKCkpXG4gICAgLnJldmVyc2UoKVxuICAgIC5tYXAoKGM6IFJlYWN0LlJlYWN0RWxlbWVudDxhbnk+LCBpOiBudW1iZXIpID0+IHtcbiAgICAgIGNvbnN0IGtleSA9IGMua2V5IHx8IGlcbiAgICAgIGlmIChcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdkZXZlbG9wbWVudCcgJiZcbiAgICAgICAgcHJvY2Vzcy5lbnYuX19ORVhUX09QVElNSVpFX0ZPTlRTICYmXG4gICAgICAgICFwcm9wcy5pbkFtcE1vZGVcbiAgICAgICkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgYy50eXBlID09PSAnbGluaycgJiZcbiAgICAgICAgICBjLnByb3BzWydocmVmJ10gJiZcbiAgICAgICAgICAvLyBUT0RPKHByYXRlZWtiaEApOiBSZXBsYWNlIHRoaXMgd2l0aCBjb25zdCBmcm9tIGBjb25zdGFudHNgIHdoZW4gdGhlIHRyZWUgc2hha2luZyB3b3Jrcy5cbiAgICAgICAgICBbJ2h0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzJ10uc29tZSgodXJsKSA9PlxuICAgICAgICAgICAgYy5wcm9wc1snaHJlZiddLnN0YXJ0c1dpdGgodXJsKVxuICAgICAgICAgIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgY29uc3QgbmV3UHJvcHMgPSB7IC4uLihjLnByb3BzIHx8IHt9KSB9XG4gICAgICAgICAgbmV3UHJvcHNbJ2RhdGEtaHJlZiddID0gbmV3UHJvcHNbJ2hyZWYnXVxuICAgICAgICAgIG5ld1Byb3BzWydocmVmJ10gPSB1bmRlZmluZWRcbiAgICAgICAgICByZXR1cm4gUmVhY3QuY2xvbmVFbGVtZW50KGMsIG5ld1Byb3BzKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gUmVhY3QuY2xvbmVFbGVtZW50KGMsIHsga2V5IH0pXG4gICAgfSlcbn1cblxuLyoqXG4gKiBUaGlzIGNvbXBvbmVudCBpbmplY3RzIGVsZW1lbnRzIHRvIGA8aGVhZD5gIG9mIHlvdXIgcGFnZS5cbiAqIFRvIGF2b2lkIGR1cGxpY2F0ZWQgYHRhZ3NgIGluIGA8aGVhZD5gIHlvdSBjYW4gdXNlIHRoZSBga2V5YCBwcm9wZXJ0eSwgd2hpY2ggd2lsbCBtYWtlIHN1cmUgZXZlcnkgdGFnIGlzIG9ubHkgcmVuZGVyZWQgb25jZS5cbiAqL1xuZnVuY3Rpb24gSGVhZCh7IGNoaWxkcmVuIH06IHsgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZSB9KSB7XG4gIGNvbnN0IGFtcFN0YXRlID0gdXNlQ29udGV4dChBbXBTdGF0ZUNvbnRleHQpXG4gIGNvbnN0IGhlYWRNYW5hZ2VyID0gdXNlQ29udGV4dChIZWFkTWFuYWdlckNvbnRleHQpXG4gIHJldHVybiAoXG4gICAgPEVmZmVjdFxuICAgICAgcmVkdWNlQ29tcG9uZW50c1RvU3RhdGU9e3JlZHVjZUNvbXBvbmVudHN9XG4gICAgICBoZWFkTWFuYWdlcj17aGVhZE1hbmFnZXJ9XG4gICAgICBpbkFtcE1vZGU9e2lzSW5BbXBNb2RlKGFtcFN0YXRlKX1cbiAgICA+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9FZmZlY3Q+XG4gIClcbn1cblxuLy8gVE9ETzogUmVtb3ZlIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2VcbkhlYWQucmV3aW5kID0gKCkgPT4ge31cblxuZXhwb3J0IGRlZmF1bHQgSGVhZFxuIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0J1xuXG5jb25zdCBpc1NlcnZlciA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnXG5cbnR5cGUgU3RhdGUgPSBKU1guRWxlbWVudFtdIHwgdW5kZWZpbmVkXG5cbnR5cGUgU2lkZUVmZmVjdFByb3BzID0ge1xuICByZWR1Y2VDb21wb25lbnRzVG9TdGF0ZTogPFQ+KFxuICAgIGNvbXBvbmVudHM6IEFycmF5PFJlYWN0LlJlYWN0RWxlbWVudDxhbnk+PixcbiAgICBwcm9wczogVFxuICApID0+IFN0YXRlXG4gIGhhbmRsZVN0YXRlQ2hhbmdlPzogKHN0YXRlOiBTdGF0ZSkgPT4gdm9pZFxuICBoZWFkTWFuYWdlcjogYW55XG4gIGluQW1wTW9kZT86IGJvb2xlYW5cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgZXh0ZW5kcyBDb21wb25lbnQ8U2lkZUVmZmVjdFByb3BzPiB7XG4gIHByaXZhdGUgX2hhc0hlYWRNYW5hZ2VyOiBib29sZWFuXG5cbiAgZW1pdENoYW5nZSA9ICgpOiB2b2lkID0+IHtcbiAgICBpZiAodGhpcy5faGFzSGVhZE1hbmFnZXIpIHtcbiAgICAgIHRoaXMucHJvcHMuaGVhZE1hbmFnZXIudXBkYXRlSGVhZChcbiAgICAgICAgdGhpcy5wcm9wcy5yZWR1Y2VDb21wb25lbnRzVG9TdGF0ZShcbiAgICAgICAgICBbLi4udGhpcy5wcm9wcy5oZWFkTWFuYWdlci5tb3VudGVkSW5zdGFuY2VzXSxcbiAgICAgICAgICB0aGlzLnByb3BzXG4gICAgICAgIClcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihwcm9wczogYW55KSB7XG4gICAgc3VwZXIocHJvcHMpXG4gICAgdGhpcy5faGFzSGVhZE1hbmFnZXIgPVxuICAgICAgdGhpcy5wcm9wcy5oZWFkTWFuYWdlciAmJiB0aGlzLnByb3BzLmhlYWRNYW5hZ2VyLm1vdW50ZWRJbnN0YW5jZXNcblxuICAgIGlmIChpc1NlcnZlciAmJiB0aGlzLl9oYXNIZWFkTWFuYWdlcikge1xuICAgICAgdGhpcy5wcm9wcy5oZWFkTWFuYWdlci5tb3VudGVkSW5zdGFuY2VzLmFkZCh0aGlzKVxuICAgICAgdGhpcy5lbWl0Q2hhbmdlKClcbiAgICB9XG4gIH1cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgaWYgKHRoaXMuX2hhc0hlYWRNYW5hZ2VyKSB7XG4gICAgICB0aGlzLnByb3BzLmhlYWRNYW5hZ2VyLm1vdW50ZWRJbnN0YW5jZXMuYWRkKHRoaXMpXG4gICAgfVxuICAgIHRoaXMuZW1pdENoYW5nZSgpXG4gIH1cbiAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgIHRoaXMuZW1pdENoYW5nZSgpXG4gIH1cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgaWYgKHRoaXMuX2hhc0hlYWRNYW5hZ2VyKSB7XG4gICAgICB0aGlzLnByb3BzLmhlYWRNYW5hZ2VyLm1vdW50ZWRJbnN0YW5jZXMuZGVsZXRlKHRoaXMpXG4gICAgfVxuICAgIHRoaXMuZW1pdENoYW5nZSgpXG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxuIiwiLyoqXG4gKiBJc29tb3JwaGljIGJhc2U2NCB0aGF0IHdvcmtzIG9uIHRoZSBzZXJ2ZXIgYW5kIGNsaWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CYXNlNjQoc3RyOiBzdHJpbmcpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHN0cikudG9TdHJpbmcoJ2Jhc2U2NCcpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHdpbmRvdy5idG9hKHN0cilcbiAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7ZXhwb3J0cy5fX2VzTW9kdWxlPXRydWU7ZXhwb3J0cy5pbWFnZUNvbmZpZ0RlZmF1bHQ9ZXhwb3J0cy5WQUxJRF9MT0FERVJTPXZvaWQgMDtjb25zdCBWQUxJRF9MT0FERVJTPVsnZGVmYXVsdCcsJ2ltZ2l4JywnY2xvdWRpbmFyeScsJ2FrYW1haSddO2V4cG9ydHMuVkFMSURfTE9BREVSUz1WQUxJRF9MT0FERVJTO2NvbnN0IGltYWdlQ29uZmlnRGVmYXVsdD17ZGV2aWNlU2l6ZXM6WzY0MCw3NTAsODI4LDEwODAsMTIwMCwxOTIwLDIwNDgsMzg0MF0saW1hZ2VTaXplczpbMTYsMzIsNDgsNjQsOTYsMTI4LDI1NiwzODRdLHBhdGg6Jy9fbmV4dC9pbWFnZScsbG9hZGVyOidkZWZhdWx0Jyxkb21haW5zOltdfTtleHBvcnRzLmltYWdlQ29uZmlnRGVmYXVsdD1pbWFnZUNvbmZpZ0RlZmF1bHQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbWFnZS1jb25maWcuanMubWFwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3QvbmV4dC1zZXJ2ZXIvbGliL2hlYWQnKVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3QvY2xpZW50L2ltYWdlJylcbiIsIi8qKiBAbGljZW5zZSBSZWFjdCB2MTcuMC4xXG4gKiByZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbi8vIEFUVEVOVElPTlxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSAweGVhYzc7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSAweGVhY2E7XG5leHBvcnRzLkZyYWdtZW50ID0gMHhlYWNiO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSAweGVhY2M7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IDB4ZWFkMjtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gMHhlYWNkO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IDB4ZWFjZTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gMHhlYWQwO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSAweGVhZDE7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gMHhlYWQ4O1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IDB4ZWFkMztcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSAweGVhZDQ7XG52YXIgUkVBQ1RfQkxPQ0tfVFlQRSA9IDB4ZWFkOTtcbnZhciBSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSA9IDB4ZWFkYTtcbnZhciBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gMHhlYWQ1O1xudmFyIFJFQUNUX1NDT1BFX1RZUEUgPSAweGVhZDc7XG52YXIgUkVBQ1RfT1BBUVVFX0lEX1RZUEUgPSAweGVhZTA7XG52YXIgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgPSAweGVhZTE7XG52YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSAweGVhZTI7XG52YXIgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFID0gMHhlYWUzO1xuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yKSB7XG4gIHZhciBzeW1ib2xGb3IgPSBTeW1ib2wuZm9yO1xuICBSRUFDVF9FTEVNRU5UX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbiAgUkVBQ1RfUE9SVEFMX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnBvcnRhbCcpO1xuICBleHBvcnRzLkZyYWdtZW50ID0gc3ltYm9sRm9yKCdyZWFjdC5mcmFnbWVudCcpO1xuICBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xuICBSRUFDVF9QUk9GSUxFUl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wcm9maWxlcicpO1xuICBSRUFDVF9QUk9WSURFUl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wcm92aWRlcicpO1xuICBSRUFDVF9DT05URVhUX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmNvbnRleHQnKTtcbiAgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbiAgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc3VzcGVuc2UnKTtcbiAgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG4gIFJFQUNUX01FTU9fVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubWVtbycpO1xuICBSRUFDVF9MQVpZX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmxhenknKTtcbiAgUkVBQ1RfQkxPQ0tfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuYmxvY2snKTtcbiAgUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnNlcnZlci5ibG9jaycpO1xuICBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5mdW5kYW1lbnRhbCcpO1xuICBSRUFDVF9TQ09QRV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zY29wZScpO1xuICBSRUFDVF9PUEFRVUVfSURfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Qub3BhcXVlLmlkJyk7XG4gIFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5kZWJ1Z190cmFjZV9tb2RlJyk7XG4gIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5vZmZzY3JlZW4nKTtcbiAgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5sZWdhY3lfaGlkZGVuJyk7XG59XG5cbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG5cbiAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9XG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuICcnICsgaXRlbTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbi8vIEZpbHRlciBjZXJ0YWluIERPTSBhdHRyaWJ1dGVzIChlLmcuIHNyYywgaHJlZikgaWYgdGhlaXIgdmFsdWVzIGFyZSBlbXB0eSBzdHJpbmdzLlxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gTm90ZTogdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgKGUuZy4gaWYgaXQncyBhIHBvbHlmaWxsKS5cblxuXG4gIGlmICh0eXBlID09PSBleHBvcnRzLkZyYWdtZW50IHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgfHwgZW5hYmxlU2NvcGVBUEkgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQkxPQ0tfVFlQRSB8fCB0eXBlWzBdID09PSBSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRXcmFwcGVkTmFtZShvdXRlclR5cGUsIGlubmVyVHlwZSwgd3JhcHBlck5hbWUpIHtcbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIG91dGVyVHlwZS5kaXNwbGF5TmFtZSB8fCAoZnVuY3Rpb25OYW1lICE9PSAnJyA/IHdyYXBwZXJOYW1lICsgXCIoXCIgKyBmdW5jdGlvbk5hbWUgKyBcIilcIiA6IHdyYXBwZXJOYW1lKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUodHlwZSkge1xuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgLy8gSG9zdCByb290LCB0ZXh0IG5vZGUgb3IganVzdCBpbnZhbGlkIHR5cGUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB7XG4gICAgaWYgKHR5cGVvZiB0eXBlLnRhZyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGVycm9yKCdSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBleHBvcnRzLkZyYWdtZW50OlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICB2YXIgY29udGV4dCA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShjb250ZXh0KSArICcuQ29uc3VtZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgIHZhciBwcm92aWRlciA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShwcm92aWRlci5fY29udGV4dCkgKyAnLlByb3ZpZGVyJztcblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZSh0eXBlLnR5cGUpO1xuXG4gICAgICBjYXNlIFJFQUNUX0JMT0NLX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKHR5cGUuX3JlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGxvZzogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZXYXJuXG4gICAgICAgIH0pLFxuICAgICAgICBlcnJvcjogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cEVuZDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRyb2w7XG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgIC8vIFNvbWV0aGluZyBzaG91bGQgYmUgc2V0dGluZyB0aGUgcHJvcHMgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lXG5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCAncHJvcHMnLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd29uJ3QgdGhyb3cgaW4gYSBub24tc3RyaWN0IG1vZGUgZnVuY3Rpb24uXG4gICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAvLyBmcmFtZXMgYWRkZWQgYnkgdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICB0cnkge1xuICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgRmFrZS5jYWxsKCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICBjb250cm9sID0geDtcbiAgICAgIH1cblxuICAgICAgZm4oKTtcbiAgICB9XG4gIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGUuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2wuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgdmFyIGMgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcblxuICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgLy8gVHlwaWNhbGx5IHRoaXMgd2lsbCBiZSB0aGUgcm9vdCBtb3N0IG9uZS4gSG93ZXZlciwgc3RhY2sgZnJhbWVzIG1heSBiZVxuICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAvLyBhbmQgdGhlcmUgZm9yIGN1dCBvZmYgZWFybGllci4gU28gd2Ugc2hvdWxkIGZpbmQgdGhlIHJvb3QgbW9zdCBmcmFtZSBpblxuICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgYy0tO1xuICAgICAgfVxuXG4gICAgICBmb3IgKDsgcyA+PSAxICYmIGMgPj0gMDsgcy0tLCBjLS0pIHtcbiAgICAgICAgLy8gTmV4dCB3ZSBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSB3aGljaCBzaG91bGQgYmUgdGhlXG4gICAgICAgIC8vIGZyYW1lIHRoYXQgY2FsbGVkIG91ciBzYW1wbGUgZnVuY3Rpb24gYW5kIHRoZSBjb250cm9sLlxuICAgICAgICBpZiAoc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIEluIFY4LCB0aGUgZmlyc3QgbGluZSBpcyBkZXNjcmliaW5nIHRoZSBtZXNzYWdlIGJ1dCBvdGhlciBWTXMgZG9uJ3QuXG4gICAgICAgICAgLy8gSWYgd2UncmUgYWJvdXQgdG8gcmV0dXJuIHRoZSBmaXJzdCBsaW5lLCBhbmQgdGhlIGNvbnRyb2wgaXMgYWxzbyBvbiB0aGUgc2FtZVxuICAgICAgICAgIC8vIGxpbmUsIHRoYXQncyBhIHByZXR0eSBnb29kIGluZGljYXRvciB0aGF0IG91ciBzYW1wbGUgdGhyZXcgYXQgc2FtZSBsaW5lIGFzXG4gICAgICAgICAgLy8gdGhlIGNvbnRyb2wuIEkuZS4gYmVmb3JlIHdlIGVudGVyZWQgdGhlIHNhbXBsZSBmcmFtZS4gU28gd2UgaWdub3JlIHRoaXMgcmVzdWx0LlxuICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgcGFzc2VkIGEgY2xhc3MgdG8gZnVuY3Rpb24gY29tcG9uZW50LCBvciBub24tZnVuY3Rpb24uXG4gICAgICAgICAgaWYgKHMgIT09IDEgfHwgYyAhPT0gMSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBzLS07XG4gICAgICAgICAgICAgIGMtLTsgLy8gV2UgbWF5IHN0aWxsIGhhdmUgc2ltaWxhciBpbnRlcm1lZGlhdGUgZnJhbWVzIGZyb20gdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICAgICAgICAvLyBUaGUgbmV4dCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSBzaG91bGQgYmUgb3VyIG1hdGNoIHRob3VnaC5cblxuICAgICAgICAgICAgICBpZiAoYyA8IDAgfHwgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgICAgICAgIC8vIFY4IGFkZHMgYSBcIm5ld1wiIHByZWZpeCBmb3IgbmF0aXZlIGNsYXNzZXMuIExldCdzIHJlbW92ZSBpdCB0byBtYWtlIGl0IHByZXR0aWVyLlxuICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPSAnXFxuJyArIHNhbXBsZUxpbmVzW3NdLnJlcGxhY2UoJyBhdCBuZXcgJywgJyBhdCAnKTtcblxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfQkxPQ0tfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLl9yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIExhenkgbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGluaXQocGF5bG9hZCksIHNvdXJjZSwgb3duZXJGbik7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50KSB7XG4gIHtcbiAgICAvLyAkRmxvd0ZpeE1lIFRoaXMgaXMgb2theSBidXQgRmxvdyBkb2Vzbid0IGtub3cgaXQuXG4gICAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcblxuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvciQxID0gdm9pZCAwOyAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMnICsgJyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IkMSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvciQxLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yJDEubWVzc2FnZV0gPSB0cnVlO1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIFJFU0VSVkVEX1BST1BTID0ge1xuICBrZXk6IHRydWUsXG4gIHJlZjogdHJ1ZSxcbiAgX19zZWxmOiB0cnVlLFxuICBfX3NvdXJjZTogdHJ1ZVxufTtcbnZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bjtcbnZhciBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bjtcbnZhciBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzO1xuXG57XG4gIGRpZFdhcm5BYm91dFN0cmluZ1JlZnMgPSB7fTtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRSZWYoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdyZWYnKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAncmVmJykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5yZWYgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5rZXkgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZikge1xuICB7XG4gICAgaWYgKHR5cGVvZiBjb25maWcucmVmID09PSAnc3RyaW5nJyAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ICYmIHNlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5zdGF0ZU5vZGUgIT09IHNlbGYpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgZ2V0Q29tcG9uZW50TmFtZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpLCBjb25maWcucmVmKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ3JlZicsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nUmVmLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxudmFyIFJlYWN0RWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn07XG4vKipcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdGpzL3JmY3MvcHVsbC8xMDdcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKi9cblxuZnVuY3Rpb24ganN4REVWKHR5cGUsIGNvbmZpZywgbWF5YmVLZXksIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHByb3BOYW1lOyAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG5cbiAgICB2YXIgcHJvcHMgPSB7fTtcbiAgICB2YXIga2V5ID0gbnVsbDtcbiAgICB2YXIgcmVmID0gbnVsbDsgLy8gQ3VycmVudGx5LCBrZXkgY2FuIGJlIHNwcmVhZCBpbiBhcyBhIHByb3AuIFRoaXMgY2F1c2VzIGEgcG90ZW50aWFsXG4gICAgLy8gaXNzdWUgaWYga2V5IGlzIGFsc28gZXhwbGljaXRseSBkZWNsYXJlZCAoaWUuIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+XG4gICAgLy8gb3IgPGRpdiBrZXk9XCJIaVwiIHsuLi5wcm9wc30gLz4gKS4gV2Ugd2FudCB0byBkZXByZWNhdGUga2V5IHNwcmVhZCxcbiAgICAvLyBidXQgYXMgYW4gaW50ZXJtZWRpYXJ5IHN0ZXAsIHdlIHdpbGwgdXNlIGpzeERFViBmb3IgZXZlcnl0aGluZyBleGNlcHRcbiAgICAvLyA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPiwgYmVjYXVzZSB3ZSBhcmVuJ3QgY3VycmVudGx5IGFibGUgdG8gdGVsbCBpZlxuICAgIC8vIGtleSBpcyBleHBsaWNpdGx5IGRlY2xhcmVkIHRvIGJlIHVuZGVmaW5lZCBvciBub3QuXG5cbiAgICBpZiAobWF5YmVLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAga2V5ID0gJycgKyBtYXliZUtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZik7XG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gICAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBAZmluYWxcbiAqL1xuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudChvYmplY3QpIHtcbiAge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuICB7XG4gICAgaWYgKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAge1xuICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cblxuXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB7XG4gICAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICAgIGlmICghaW5mbykge1xuICAgICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG5cbiAgICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50KSB7XG4gICAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cbiAgICAgIGNoaWxkT3duZXIgPSBcIiBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSBcIiArIGdldENvbXBvbmVudE5hbWUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuXG4gICAgZXJyb3IoJ0VhY2ggY2hpbGQgaW4gYSBsaXN0IHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4nICsgJyVzJXMgU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgY3VycmVudENvbXBvbmVudEVycm9ySW5mbywgY2hpbGRPd25lcik7XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICB9XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGV2ZXJ5IGVsZW1lbnQgZWl0aGVyIGlzIHBhc3NlZCBpbiBhIHN0YXRpYyBsb2NhdGlvbiwgaW4gYW5cbiAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxuICogd2l0aCB2YWxpZCBrZXkgcHJvcGVydHkuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZSBTdGF0aWNhbGx5IHBhc3NlZCBjaGlsZCBvZiBhbnkgdHlwZS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBub2RlJ3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAge1xuICAgIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG5cbiAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwcm9wVHlwZXM7XG5cbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIE5vdGU6IE1lbW8gb25seSBjaGVja3Mgb3V0ZXIgcHJvcHMgaGVyZS5cbiAgICAvLyBJbm5lciBwcm9wcyBhcmUgY2hlY2tlZCBpbiB0aGUgcmVjb25jaWxlci5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUpKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9wVHlwZXMpIHtcbiAgICAgIC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUodHlwZSk7XG4gICAgICBjaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIGVsZW1lbnQucHJvcHMsICdwcm9wJywgbmFtZSwgZWxlbWVudCk7XG4gICAgfSBlbHNlIGlmICh0eXBlLlByb3BUeXBlcyAhPT0gdW5kZWZpbmVkICYmICFwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bikge1xuICAgICAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSB0cnVlOyAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuXG4gICAgICB2YXIgX25hbWUgPSBnZXRDb21wb25lbnROYW1lKHR5cGUpO1xuXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShmcmFnbWVudCk7XG5cbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgcHJvcCBgJXNgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuICcgKyAnUmVhY3QuRnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBga2V5YCBhbmQgYGNoaWxkcmVuYCBwcm9wcy4nLCBrZXkpO1xuXG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24ganN4V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGtleSwgaXNTdGF0aWNDaGlsZHJlbiwgc291cmNlLCBzZWxmKSB7XG4gIHtcbiAgICB2YXIgdmFsaWRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpOyAvLyBXZSB3YXJuIGluIHRoaXMgY2FzZSBidXQgZG9uJ3QgdGhyb3cuIFdlIGV4cGVjdCB0aGUgZWxlbWVudCBjcmVhdGlvbiB0b1xuICAgIC8vIHN1Y2NlZWQgYW5kIHRoZXJlIHdpbGwgbGlrZWx5IGJlIGVycm9ycyBpbiByZW5kZXIuXG5cbiAgICBpZiAoIXZhbGlkVHlwZSkge1xuICAgICAgdmFyIGluZm8gPSAnJztcblxuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICAgIH1cblxuICAgICAgdmFyIHNvdXJjZUluZm8gPSBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpO1xuXG4gICAgICBpZiAoc291cmNlSW5mbykge1xuICAgICAgICBpbmZvICs9IHNvdXJjZUluZm87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmZvICs9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHlwZVN0cmluZztcblxuICAgICAgaWYgKHR5cGUgPT09IG51bGwpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdudWxsJztcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgICB0eXBlU3RyaW5nID0gJ2FycmF5JztcbiAgICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgICB0eXBlU3RyaW5nID0gXCI8XCIgKyAoZ2V0Q29tcG9uZW50TmFtZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBqc3hERVYodHlwZSwgcHJvcHMsIGtleSwgc291cmNlLCBzZWxmKTsgLy8gVGhlIHJlc3VsdCBjYW4gYmUgbnVsbGlzaCBpZiBhIG1vY2sgb3IgYSBjdXN0b20gZnVuY3Rpb24gaXMgdXNlZC5cbiAgICAvLyBUT0RPOiBEcm9wIHRoaXMgd2hlbiB0aGVzZSBhcmUgbm8gbG9uZ2VyIGFsbG93ZWQgYXMgdGhlIHR5cGUgYXJndW1lbnQuXG5cbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9IC8vIFNraXAga2V5IHdhcm5pbmcgaWYgdGhlIHR5cGUgaXNuJ3QgdmFsaWQgc2luY2Ugb3VyIGtleSB2YWxpZGF0aW9uIGxvZ2ljXG4gICAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmcgZXJyb3JzLlxuICAgIC8vIFdlIGRvbid0IHdhbnQgZXhjZXB0aW9uIGJlaGF2aW9yIHRvIGRpZmZlciBiZXR3ZWVuIGRldiBhbmQgcHJvZC5cbiAgICAvLyAoUmVuZGVyaW5nIHdpbGwgdGhyb3cgd2l0aCBhIGhlbHBmdWwgbWVzc2FnZSBhbmQgYXMgc29vbiBhcyB0aGUgdHlwZSBpc1xuICAgIC8vIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcblxuXG4gICAgaWYgKHZhbGlkVHlwZSkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG5cbiAgICAgIGlmIChjaGlsZHJlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChpc1N0YXRpY0NoaWxkcmVuKSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuW2ldLCB0eXBlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZShjaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVycm9yKCdSZWFjdC5qc3g6IFN0YXRpYyBjaGlsZHJlbiBzaG91bGQgYWx3YXlzIGJlIGFuIGFycmF5LiAnICsgJ1lvdSBhcmUgbGlrZWx5IGV4cGxpY2l0bHkgY2FsbGluZyBSZWFjdC5qc3hzIG9yIFJlYWN0LmpzeERFVi4gJyArICdVc2UgdGhlIEJhYmVsIHRyYW5zZm9ybSBpbnN0ZWFkLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbiwgdHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gZXhwb3J0cy5GcmFnbWVudCkge1xuICAgICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKGVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxufSAvLyBUaGVzZSB0d28gZnVuY3Rpb25zIGV4aXN0IHRvIHN0aWxsIGdldCBjaGlsZCB3YXJuaW5ncyBpbiBkZXZcblxudmFyIGpzeERFViQxID0gIGpzeFdpdGhWYWxpZGF0aW9uIDtcblxuZXhwb3J0cy5qc3hERVYgPSBqc3hERVYkMTtcbiAgfSkoKTtcbn1cbiIsIi8qKiBAbGljZW5zZSBSZWFjdCB2MTcuMC4xXG4gKiByZWFjdC5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG4vLyBUT0RPOiB0aGlzIGlzIHNwZWNpYWwgYmVjYXVzZSBpdCBnZXRzIGltcG9ydGVkIGR1cmluZyBidWlsZC5cbnZhciBSZWFjdFZlcnNpb24gPSAnMTcuMC4xJztcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IDB4ZWFjNztcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IDB4ZWFjYTtcbmV4cG9ydHMuRnJhZ21lbnQgPSAweGVhY2I7XG5leHBvcnRzLlN0cmljdE1vZGUgPSAweGVhY2M7XG5leHBvcnRzLlByb2ZpbGVyID0gMHhlYWQyO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSAweGVhY2Q7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gMHhlYWNlO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSAweGVhZDA7XG5leHBvcnRzLlN1c3BlbnNlID0gMHhlYWQxO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IDB4ZWFkODtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSAweGVhZDM7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gMHhlYWQ0O1xudmFyIFJFQUNUX0JMT0NLX1RZUEUgPSAweGVhZDk7XG52YXIgUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUgPSAweGVhZGE7XG52YXIgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IDB4ZWFkNTtcbnZhciBSRUFDVF9TQ09QRV9UWVBFID0gMHhlYWQ3O1xudmFyIFJFQUNUX09QQVFVRV9JRF9UWVBFID0gMHhlYWUwO1xudmFyIFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFID0gMHhlYWUxO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gMHhlYWUyO1xudmFyIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSA9IDB4ZWFlMztcblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcikge1xuICB2YXIgc3ltYm9sRm9yID0gU3ltYm9sLmZvcjtcbiAgUkVBQ1RfRUxFTUVOVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5lbGVtZW50Jyk7XG4gIFJFQUNUX1BPUlRBTF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wb3J0YWwnKTtcbiAgZXhwb3J0cy5GcmFnbWVudCA9IHN5bWJvbEZvcigncmVhY3QuZnJhZ21lbnQnKTtcbiAgZXhwb3J0cy5TdHJpY3RNb2RlID0gc3ltYm9sRm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xuICBleHBvcnRzLlByb2ZpbGVyID0gc3ltYm9sRm9yKCdyZWFjdC5wcm9maWxlcicpO1xuICBSRUFDVF9QUk9WSURFUl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wcm92aWRlcicpO1xuICBSRUFDVF9DT05URVhUX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmNvbnRleHQnKTtcbiAgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbiAgZXhwb3J0cy5TdXNwZW5zZSA9IHN5bWJvbEZvcigncmVhY3Quc3VzcGVuc2UnKTtcbiAgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG4gIFJFQUNUX01FTU9fVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubWVtbycpO1xuICBSRUFDVF9MQVpZX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmxhenknKTtcbiAgUkVBQ1RfQkxPQ0tfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuYmxvY2snKTtcbiAgUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnNlcnZlci5ibG9jaycpO1xuICBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5mdW5kYW1lbnRhbCcpO1xuICBSRUFDVF9TQ09QRV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zY29wZScpO1xuICBSRUFDVF9PUEFRVUVfSURfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Qub3BhcXVlLmlkJyk7XG4gIFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5kZWJ1Z190cmFjZV9tb2RlJyk7XG4gIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5vZmZzY3JlZW4nKTtcbiAgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5sZWdhY3lfaGlkZGVuJyk7XG59XG5cbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IGRpc3BhdGNoZXIuXG4gKi9cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEB0eXBlIHtSZWFjdENvbXBvbmVudH1cbiAgICovXG4gIGN1cnJlbnQ6IG51bGxcbn07XG5cbi8qKlxuICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgYmF0Y2gncyBjb25maWd1cmF0aW9uIHN1Y2ggYXMgaG93IGxvbmcgYW4gdXBkYXRlXG4gKiBzaG91bGQgc3VzcGVuZCBmb3IgaWYgaXQgbmVlZHMgdG8uXG4gKi9cbnZhciBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyA9IHtcbiAgdHJhbnNpdGlvbjogMFxufTtcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBvd25lci5cbiAqXG4gKiBUaGUgY3VycmVudCBvd25lciBpcyB0aGUgY29tcG9uZW50IHdobyBzaG91bGQgb3duIGFueSBjb21wb25lbnRzIHRoYXQgYXJlXG4gKiBjdXJyZW50bHkgYmVpbmcgY29uc3RydWN0ZWQuXG4gKi9cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAdHlwZSB7UmVhY3RDb21wb25lbnR9XG4gICAqL1xuICBjdXJyZW50OiBudWxsXG59O1xuXG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IHt9O1xudmFyIGN1cnJlbnRFeHRyYVN0YWNrRnJhbWUgPSBudWxsO1xuZnVuY3Rpb24gc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKSB7XG4gIHtcbiAgICBjdXJyZW50RXh0cmFTdGFja0ZyYW1lID0gc3RhY2s7XG4gIH1cbn1cblxue1xuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZSA9IGZ1bmN0aW9uIChzdGFjaykge1xuICAgIHtcbiAgICAgIGN1cnJlbnRFeHRyYVN0YWNrRnJhbWUgPSBzdGFjaztcbiAgICB9XG4gIH07IC8vIFN0YWNrIGltcGxlbWVudGF0aW9uIGluamVjdGVkIGJ5IHRoZSBjdXJyZW50IHJlbmRlcmVyLlxuXG5cbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2sgPSBudWxsO1xuXG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhY2sgPSAnJzsgLy8gQWRkIGFuIGV4dHJhIHRvcCBmcmFtZSB3aGlsZSBhbiBlbGVtZW50IGlzIGJlaW5nIHZhbGlkYXRlZFxuXG4gICAgaWYgKGN1cnJlbnRFeHRyYVN0YWNrRnJhbWUpIHtcbiAgICAgIHN0YWNrICs9IGN1cnJlbnRFeHRyYVN0YWNrRnJhbWU7XG4gICAgfSAvLyBEZWxlZ2F0ZSB0byB0aGUgaW5qZWN0ZWQgcmVuZGVyZXItc3BlY2lmaWMgaW1wbGVtZW50YXRpb25cblxuXG4gICAgdmFyIGltcGwgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjaztcblxuICAgIGlmIChpbXBsKSB7XG4gICAgICBzdGFjayArPSBpbXBsKCkgfHwgJyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YWNrO1xuICB9O1xufVxuXG4vKipcbiAqIFVzZWQgYnkgYWN0KCkgdG8gdHJhY2sgd2hldGhlciB5b3UncmUgaW5zaWRlIGFuIGFjdCgpIHNjb3BlLlxuICovXG52YXIgSXNTb21lUmVuZGVyZXJBY3RpbmcgPSB7XG4gIGN1cnJlbnQ6IGZhbHNlXG59O1xuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSB7XG4gIFJlYWN0Q3VycmVudERpc3BhdGNoZXI6IFJlYWN0Q3VycmVudERpc3BhdGNoZXIsXG4gIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnOiBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyxcbiAgUmVhY3RDdXJyZW50T3duZXI6IFJlYWN0Q3VycmVudE93bmVyLFxuICBJc1NvbWVSZW5kZXJlckFjdGluZzogSXNTb21lUmVuZGVyZXJBY3RpbmcsXG4gIC8vIFVzZWQgYnkgcmVuZGVyZXJzIHRvIGF2b2lkIGJ1bmRsaW5nIG9iamVjdC1hc3NpZ24gdHdpY2UgaW4gVU1EIGJ1bmRsZXM6XG4gIGFzc2lnbjogX2Fzc2lnblxufTtcblxue1xuICBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbn1cblxuLy8gYnkgY2FsbHMgdG8gdGhlc2UgbWV0aG9kcyBieSBhIEJhYmVsIHBsdWdpbi5cbi8vXG4vLyBJbiBQUk9EIChvciBpbiBwYWNrYWdlcyB3aXRob3V0IGFjY2VzcyB0byBSZWFjdCBpbnRlcm5hbHMpLFxuLy8gdGhleSBhcmUgbGVmdCBhcyB0aGV5IGFyZSBpbnN0ZWFkLlxuXG5mdW5jdGlvbiB3YXJuKGZvcm1hdCkge1xuICB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcHJpbnRXYXJuaW5nKCd3YXJuJywgZm9ybWF0LCBhcmdzKTtcbiAgfVxufVxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG5cbiAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9XG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuICcnICsgaXRlbTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbnZhciBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQgPSB7fTtcblxuZnVuY3Rpb24gd2Fybk5vb3AocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcbiAge1xuICAgIHZhciBfY29uc3RydWN0b3IgPSBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IF9jb25zdHJ1Y3RvciAmJiAoX2NvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IF9jb25zdHJ1Y3Rvci5uYW1lKSB8fCAnUmVhY3RDbGFzcyc7XG4gICAgdmFyIHdhcm5pbmdLZXkgPSBjb21wb25lbnROYW1lICsgXCIuXCIgKyBjYWxsZXJOYW1lO1xuXG4gICAgaWYgKGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFt3YXJuaW5nS2V5XSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVycm9yKFwiQ2FuJ3QgY2FsbCAlcyBvbiBhIGNvbXBvbmVudCB0aGF0IGlzIG5vdCB5ZXQgbW91bnRlZC4gXCIgKyAnVGhpcyBpcyBhIG5vLW9wLCBidXQgaXQgbWlnaHQgaW5kaWNhdGUgYSBidWcgaW4geW91ciBhcHBsaWNhdGlvbi4gJyArICdJbnN0ZWFkLCBhc3NpZ24gdG8gYHRoaXMuc3RhdGVgIGRpcmVjdGx5IG9yIGRlZmluZSBhIGBzdGF0ZSA9IHt9O2AgJyArICdjbGFzcyBwcm9wZXJ0eSB3aXRoIHRoZSBkZXNpcmVkIHN0YXRlIGluIHRoZSAlcyBjb21wb25lbnQuJywgY2FsbGVyTmFtZSwgY29tcG9uZW50TmFtZSk7XG5cbiAgICBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbd2FybmluZ0tleV0gPSB0cnVlO1xuICB9XG59XG4vKipcbiAqIFRoaXMgaXMgdGhlIGFic3RyYWN0IEFQSSBmb3IgYW4gdXBkYXRlIHF1ZXVlLlxuICovXG5cblxudmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0ge1xuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB3ZSB3YW50IHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBmaW5hbFxuICAgKi9cbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAgICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAgICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gICAqXG4gICAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAgICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gY2FsbGVyTmFtZSBuYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnZm9yY2VVcGRhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIG9yIGBzZXRTdGF0ZWAgdG8gbXV0YXRlIHN0YXRlLlxuICAgKiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gICAqXG4gICAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gICAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29tcGxldGVTdGF0ZSBOZXh0IHN0YXRlLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IGNhbGxlck5hbWUgbmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNvbXBsZXRlU3RhdGUsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdyZXBsYWNlU3RhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIFRoaXMgb25seSBleGlzdHMgYmVjYXVzZSBfcGVuZGluZ1N0YXRlIGlzXG4gICAqIGludGVybmFsLiBUaGlzIHByb3ZpZGVzIGEgbWVyZ2luZyBzdHJhdGVneSB0aGF0IGlzIG5vdCBhdmFpbGFibGUgdG8gZGVlcFxuICAgKiBwcm9wZXJ0aWVzIHdoaWNoIGlzIGNvbmZ1c2luZy4gVE9ETzogRXhwb3NlIHBlbmRpbmdTdGF0ZSBvciBkb24ndCB1c2UgaXRcbiAgICogZHVyaW5nIHRoZSBtZXJnZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIHN0YXRlLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IE5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3NldFN0YXRlJyk7XG4gIH1cbn07XG5cbnZhciBlbXB0eU9iamVjdCA9IHt9O1xuXG57XG4gIE9iamVjdC5mcmVlemUoZW1wdHlPYmplY3QpO1xufVxuLyoqXG4gKiBCYXNlIGNsYXNzIGhlbHBlcnMgZm9yIHRoZSB1cGRhdGluZyBzdGF0ZSBvZiBhIGNvbXBvbmVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIENvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7IC8vIElmIGEgY29tcG9uZW50IGhhcyBzdHJpbmcgcmVmcywgd2Ugd2lsbCBhc3NpZ24gYSBkaWZmZXJlbnQgb2JqZWN0IGxhdGVyLlxuXG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0OyAvLyBXZSBpbml0aWFsaXplIHRoZSBkZWZhdWx0IHVwZGF0ZXIgYnV0IHRoZSByZWFsIG9uZSBnZXRzIGluamVjdGVkIGJ5IHRoZVxuICAvLyByZW5kZXJlci5cblxuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG5Db21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSB7fTtcbi8qKlxuICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyB0byBtdXRhdGVcbiAqIHN0YXRlLiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgY2FsbHMgdG8gYHNldFN0YXRlYCB3aWxsIHJ1biBzeW5jaHJvbm91c2x5LFxuICogYXMgdGhleSBtYXkgZXZlbnR1YWxseSBiZSBiYXRjaGVkIHRvZ2V0aGVyLiAgWW91IGNhbiBwcm92aWRlIGFuIG9wdGlvbmFsXG4gKiBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiB0aGUgY2FsbCB0byBzZXRTdGF0ZSBpcyBhY3R1YWxseVxuICogY29tcGxldGVkLlxuICpcbiAqIFdoZW4gYSBmdW5jdGlvbiBpcyBwcm92aWRlZCB0byBzZXRTdGF0ZSwgaXQgd2lsbCBiZSBjYWxsZWQgYXQgc29tZSBwb2ludCBpblxuICogdGhlIGZ1dHVyZSAobm90IHN5bmNocm9ub3VzbHkpLiBJdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSB1cCB0byBkYXRlXG4gKiBjb21wb25lbnQgYXJndW1lbnRzIChzdGF0ZSwgcHJvcHMsIGNvbnRleHQpLiBUaGVzZSB2YWx1ZXMgY2FuIGJlIGRpZmZlcmVudFxuICogZnJvbSB0aGlzLiogYmVjYXVzZSB5b3VyIGZ1bmN0aW9uIG1heSBiZSBjYWxsZWQgYWZ0ZXIgcmVjZWl2ZVByb3BzIGJ1dCBiZWZvcmVcbiAqIHNob3VsZENvbXBvbmVudFVwZGF0ZSwgYW5kIHRoaXMgbmV3IHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgd2lsbCBub3QgeWV0IGJlXG4gKiBhc3NpZ25lZCB0byB0aGlzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIG9yIGZ1bmN0aW9uIHRvXG4gKiAgICAgICAgcHJvZHVjZSBuZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggY3VycmVudCBzdGF0ZS5cbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgc3RhdGUgaXMgdXBkYXRlZC5cbiAqIEBmaW5hbFxuICogQHByb3RlY3RlZFxuICovXG5cbkNvbXBvbmVudC5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAocGFydGlhbFN0YXRlLCBjYWxsYmFjaykge1xuICBpZiAoISh0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnZnVuY3Rpb24nIHx8IHBhcnRpYWxTdGF0ZSA9PSBudWxsKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcInNldFN0YXRlKC4uLik6IHRha2VzIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMgdG8gdXBkYXRlIG9yIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzLlwiICk7XG4gICAgfVxuICB9XG5cbiAgdGhpcy51cGRhdGVyLmVucXVldWVTZXRTdGF0ZSh0aGlzLCBwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrLCAnc2V0U3RhdGUnKTtcbn07XG4vKipcbiAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICpcbiAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICpcbiAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gKlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciB1cGRhdGUgaXMgY29tcGxldGUuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuXG5cbkNvbXBvbmVudC5wcm90b3R5cGUuZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgdGhpcy51cGRhdGVyLmVucXVldWVGb3JjZVVwZGF0ZSh0aGlzLCBjYWxsYmFjaywgJ2ZvcmNlVXBkYXRlJyk7XG59O1xuLyoqXG4gKiBEZXByZWNhdGVkIEFQSXMuIFRoZXNlIEFQSXMgdXNlZCB0byBleGlzdCBvbiBjbGFzc2ljIFJlYWN0IGNsYXNzZXMgYnV0IHNpbmNlXG4gKiB3ZSB3b3VsZCBsaWtlIHRvIGRlcHJlY2F0ZSB0aGVtLCB3ZSdyZSBub3QgZ29pbmcgdG8gbW92ZSB0aGVtIG92ZXIgdG8gdGhpc1xuICogbW9kZXJuIGJhc2UgY2xhc3MuIEluc3RlYWQsIHdlIGRlZmluZSBhIGdldHRlciB0aGF0IHdhcm5zIGlmIGl0J3MgYWNjZXNzZWQuXG4gKi9cblxuXG57XG4gIHZhciBkZXByZWNhdGVkQVBJcyA9IHtcbiAgICBpc01vdW50ZWQ6IFsnaXNNb3VudGVkJywgJ0luc3RlYWQsIG1ha2Ugc3VyZSB0byBjbGVhbiB1cCBzdWJzY3JpcHRpb25zIGFuZCBwZW5kaW5nIHJlcXVlc3RzIGluICcgKyAnY29tcG9uZW50V2lsbFVubW91bnQgdG8gcHJldmVudCBtZW1vcnkgbGVha3MuJ10sXG4gICAgcmVwbGFjZVN0YXRlOiBbJ3JlcGxhY2VTdGF0ZScsICdSZWZhY3RvciB5b3VyIGNvZGUgdG8gdXNlIHNldFN0YXRlIGluc3RlYWQgKHNlZSAnICsgJ2h0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMzIzNikuJ11cbiAgfTtcblxuICB2YXIgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUsIGluZm8pIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50LnByb3RvdHlwZSwgbWV0aG9kTmFtZSwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdhcm4oJyVzKC4uLikgaXMgZGVwcmVjYXRlZCBpbiBwbGFpbiBKYXZhU2NyaXB0IFJlYWN0IGNsYXNzZXMuICVzJywgaW5mb1swXSwgaW5mb1sxXSk7XG5cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBmb3IgKHZhciBmbk5hbWUgaW4gZGVwcmVjYXRlZEFQSXMpIHtcbiAgICBpZiAoZGVwcmVjYXRlZEFQSXMuaGFzT3duUHJvcGVydHkoZm5OYW1lKSkge1xuICAgICAgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nKGZuTmFtZSwgZGVwcmVjYXRlZEFQSXNbZm5OYW1lXSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIENvbXBvbmVudER1bW15KCkge31cblxuQ29tcG9uZW50RHVtbXkucHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbi8qKlxuICogQ29udmVuaWVuY2UgY29tcG9uZW50IHdpdGggZGVmYXVsdCBzaGFsbG93IGVxdWFsaXR5IGNoZWNrIGZvciBzQ1UuXG4gKi9cblxuZnVuY3Rpb24gUHVyZUNvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7IC8vIElmIGEgY29tcG9uZW50IGhhcyBzdHJpbmcgcmVmcywgd2Ugd2lsbCBhc3NpZ24gYSBkaWZmZXJlbnQgb2JqZWN0IGxhdGVyLlxuXG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG52YXIgcHVyZUNvbXBvbmVudFByb3RvdHlwZSA9IFB1cmVDb21wb25lbnQucHJvdG90eXBlID0gbmV3IENvbXBvbmVudER1bW15KCk7XG5wdXJlQ29tcG9uZW50UHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUHVyZUNvbXBvbmVudDsgLy8gQXZvaWQgYW4gZXh0cmEgcHJvdG90eXBlIGp1bXAgZm9yIHRoZXNlIG1ldGhvZHMuXG5cbl9hc3NpZ24ocHVyZUNvbXBvbmVudFByb3RvdHlwZSwgQ29tcG9uZW50LnByb3RvdHlwZSk7XG5cbnB1cmVDb21wb25lbnRQcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgPSB0cnVlO1xuXG4vLyBhbiBpbW11dGFibGUgb2JqZWN0IHdpdGggYSBzaW5nbGUgbXV0YWJsZSB2YWx1ZVxuZnVuY3Rpb24gY3JlYXRlUmVmKCkge1xuICB2YXIgcmVmT2JqZWN0ID0ge1xuICAgIGN1cnJlbnQ6IG51bGxcbiAgfTtcblxuICB7XG4gICAgT2JqZWN0LnNlYWwocmVmT2JqZWN0KTtcbiAgfVxuXG4gIHJldHVybiByZWZPYmplY3Q7XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gb3V0ZXJUeXBlLmRpc3BsYXlOYW1lIHx8IChmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWUpO1xufVxuXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0Jztcbn1cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKSB7XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWUoKS4gJyArICdUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIGV4cG9ydHMuRnJhZ21lbnQ6XG4gICAgICByZXR1cm4gJ0ZyYWdtZW50JztcblxuICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICByZXR1cm4gJ1BvcnRhbCc7XG5cbiAgICBjYXNlIGV4cG9ydHMuUHJvZmlsZXI6XG4gICAgICByZXR1cm4gJ1Byb2ZpbGVyJztcblxuICAgIGNhc2UgZXhwb3J0cy5TdHJpY3RNb2RlOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcblxuICAgIGNhc2UgZXhwb3J0cy5TdXNwZW5zZTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUoY29udGV4dCkgKyAnLkNvbnN1bWVyJztcblxuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB2YXIgcHJvdmlkZXIgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldFdyYXBwZWROYW1lKHR5cGUsIHR5cGUucmVuZGVyLCAnRm9yd2FyZFJlZicpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUodHlwZS50eXBlKTtcblxuICAgICAgY2FzZSBSRUFDVF9CTE9DS19UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZSh0eXBlLl9yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIFJFU0VSVkVEX1BST1BTID0ge1xuICBrZXk6IHRydWUsXG4gIHJlZjogdHJ1ZSxcbiAgX19zZWxmOiB0cnVlLFxuICBfX3NvdXJjZTogdHJ1ZVxufTtcbnZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biwgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24sIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XG5cbntcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nUmVmLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZykge1xuICB7XG4gICAgaWYgKHR5cGVvZiBjb25maWcucmVmID09PSAnc3RyaW5nJyAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ICYmIGNvbmZpZy5fX3NlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5zdGF0ZU5vZGUgIT09IGNvbmZpZy5fX3NlbGYpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgY29tcG9uZW50TmFtZSwgY29uZmlnLnJlZik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbnZhciBSZWFjdEVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gIHZhciBlbGVtZW50ID0ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG4gICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5OiBrZXksXG4gICAgcmVmOiByZWYsXG4gICAgcHJvcHM6IHByb3BzLFxuICAgIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGVsZW1lbnQuXG4gICAgX293bmVyOiBvd25lclxuICB9O1xuXG4gIHtcbiAgICAvLyBUaGUgdmFsaWRhdGlvbiBmbGFnIGlzIGN1cnJlbnRseSBtdXRhdGl2ZS4gV2UgcHV0IGl0IG9uXG4gICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cbiAgICAvLyBUaGlzIGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgV2Vha01hcCBvbmNlIHRoZXkgYXJlIGltcGxlbWVudGVkIGluXG4gICAgLy8gY29tbW9ubHkgdXNlZCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXG4gICAgZWxlbWVudC5fc3RvcmUgPSB7fTsgLy8gVG8gbWFrZSBjb21wYXJpbmcgUmVhY3RFbGVtZW50cyBlYXNpZXIgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHdlIG1ha2VcbiAgICAvLyB0aGUgdmFsaWRhdGlvbiBmbGFnIG5vbi1lbnVtZXJhYmxlICh3aGVyZSBwb3NzaWJsZSwgd2hpY2ggc2hvdWxkXG4gICAgLy8gaW5jbHVkZSBldmVyeSBlbnZpcm9ubWVudCB3ZSBydW4gdGVzdHMgaW4pLCBzbyB0aGUgdGVzdCBmcmFtZXdvcmtcbiAgICAvLyBpZ25vcmVzIGl0LlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQuX3N0b3JlLCAndmFsaWRhdGVkJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9KTsgLy8gc2VsZiBhbmQgc291cmNlIGFyZSBERVYgb25seSBwcm9wZXJ0aWVzLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2VsZicsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzZWxmXG4gICAgfSk7IC8vIFR3byBlbGVtZW50cyBjcmVhdGVkIGluIHR3byBkaWZmZXJlbnQgcGxhY2VzIHNob3VsZCBiZSBjb25zaWRlcmVkXG4gICAgLy8gZXF1YWwgZm9yIHRlc3RpbmcgcHVycG9zZXMgYW5kIHRoZXJlZm9yZSB3ZSBoaWRlIGl0IGZyb20gZW51bWVyYXRpb24uXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zb3VyY2UnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc291cmNlXG4gICAgfSk7XG5cbiAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50LnByb3BzKTtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuLyoqXG4gKiBDcmVhdGUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2NyZWF0ZWVsZW1lbnRcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50KHR5cGUsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgdmFyIHByb3BOYW1lOyAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG5cbiAgdmFyIHByb3BzID0ge307XG4gIHZhciBrZXkgPSBudWxsO1xuICB2YXIgcmVmID0gbnVsbDtcbiAgdmFyIHNlbGYgPSBudWxsO1xuICB2YXIgc291cmNlID0gbnVsbDtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgcmVmID0gY29uZmlnLnJlZjtcblxuICAgICAge1xuICAgICAgICB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIHNlbGYgPSBjb25maWcuX19zZWxmID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc2VsZjtcbiAgICBzb3VyY2UgPSBjb25maWcuX19zb3VyY2UgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zb3VyY2U7IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9IC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG5cblxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcblxuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkQXJyYXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHtcbiAgICBpZiAoa2V5IHx8IHJlZikge1xuICAgICAgdmFyIGRpc3BsYXlOYW1lID0gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCAnVW5rbm93bicgOiB0eXBlO1xuXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQsIHByb3BzKTtcbn1cbmZ1bmN0aW9uIGNsb25lQW5kUmVwbGFjZUtleShvbGRFbGVtZW50LCBuZXdLZXkpIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBSZWFjdEVsZW1lbnQob2xkRWxlbWVudC50eXBlLCBuZXdLZXksIG9sZEVsZW1lbnQucmVmLCBvbGRFbGVtZW50Ll9zZWxmLCBvbGRFbGVtZW50Ll9zb3VyY2UsIG9sZEVsZW1lbnQuX293bmVyLCBvbGRFbGVtZW50LnByb3BzKTtcbiAgcmV0dXJuIG5ld0VsZW1lbnQ7XG59XG4vKipcbiAqIENsb25lIGFuZCByZXR1cm4gYSBuZXcgUmVhY3RFbGVtZW50IHVzaW5nIGVsZW1lbnQgYXMgdGhlIHN0YXJ0aW5nIHBvaW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNjbG9uZWVsZW1lbnRcbiAqL1xuXG5mdW5jdGlvbiBjbG9uZUVsZW1lbnQoZWxlbWVudCwgY29uZmlnLCBjaGlsZHJlbikge1xuICBpZiAoISEoZWxlbWVudCA9PT0gbnVsbCB8fCBlbGVtZW50ID09PSB1bmRlZmluZWQpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiUmVhY3QuY2xvbmVFbGVtZW50KC4uLik6IFRoZSBhcmd1bWVudCBtdXN0IGJlIGEgUmVhY3QgZWxlbWVudCwgYnV0IHlvdSBwYXNzZWQgXCIgKyBlbGVtZW50ICsgXCIuXCIgKTtcbiAgICB9XG4gIH1cblxuICB2YXIgcHJvcE5hbWU7IC8vIE9yaWdpbmFsIHByb3BzIGFyZSBjb3BpZWRcblxuICB2YXIgcHJvcHMgPSBfYXNzaWduKHt9LCBlbGVtZW50LnByb3BzKTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG5cbiAgdmFyIGtleSA9IGVsZW1lbnQua2V5O1xuICB2YXIgcmVmID0gZWxlbWVudC5yZWY7IC8vIFNlbGYgaXMgcHJlc2VydmVkIHNpbmNlIHRoZSBvd25lciBpcyBwcmVzZXJ2ZWQuXG5cbiAgdmFyIHNlbGYgPSBlbGVtZW50Ll9zZWxmOyAvLyBTb3VyY2UgaXMgcHJlc2VydmVkIHNpbmNlIGNsb25lRWxlbWVudCBpcyB1bmxpa2VseSB0byBiZSB0YXJnZXRlZCBieSBhXG4gIC8vIHRyYW5zcGlsZXIsIGFuZCB0aGUgb3JpZ2luYWwgc291cmNlIGlzIHByb2JhYmx5IGEgYmV0dGVyIGluZGljYXRvciBvZiB0aGVcbiAgLy8gdHJ1ZSBvd25lci5cblxuICB2YXIgc291cmNlID0gZWxlbWVudC5fc291cmNlOyAvLyBPd25lciB3aWxsIGJlIHByZXNlcnZlZCwgdW5sZXNzIHJlZiBpcyBvdmVycmlkZGVuXG5cbiAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG5cbiAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIC8vIFNpbGVudGx5IHN0ZWFsIHRoZSByZWYgZnJvbSB0aGUgcGFyZW50LlxuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICAgIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH0gLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgb3ZlcnJpZGUgZXhpc3RpbmcgcHJvcHNcblxuXG4gICAgdmFyIGRlZmF1bHRQcm9wcztcblxuICAgIGlmIChlbGVtZW50LnR5cGUgJiYgZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgZGVmYXVsdFByb3BzID0gZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcztcbiAgICB9XG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBpZiAoY29uZmlnW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkICYmIGRlZmF1bHRQcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG5cblxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcblxuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG5cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH1cblxuICByZXR1cm4gUmVhY3RFbGVtZW50KGVsZW1lbnQudHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKTtcbn1cbi8qKlxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjaXN2YWxpZGVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgUmVhY3RFbGVtZW50LlxuICogQGZpbmFsXG4gKi9cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG5cbnZhciBTRVBBUkFUT1IgPSAnLic7XG52YXIgU1VCU0VQQVJBVE9SID0gJzonO1xuLyoqXG4gKiBFc2NhcGUgYW5kIHdyYXAga2V5IHNvIGl0IGlzIHNhZmUgdG8gdXNlIGFzIGEgcmVhY3RpZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdG8gYmUgZXNjYXBlZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIGVzY2FwZWQga2V5LlxuICovXG5cbmZ1bmN0aW9uIGVzY2FwZShrZXkpIHtcbiAgdmFyIGVzY2FwZVJlZ2V4ID0gL1s9Ol0vZztcbiAgdmFyIGVzY2FwZXJMb29rdXAgPSB7XG4gICAgJz0nOiAnPTAnLFxuICAgICc6JzogJz0yJ1xuICB9O1xuICB2YXIgZXNjYXBlZFN0cmluZyA9IGtleS5yZXBsYWNlKGVzY2FwZVJlZ2V4LCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gZXNjYXBlckxvb2t1cFttYXRjaF07XG4gIH0pO1xuICByZXR1cm4gJyQnICsgZXNjYXBlZFN0cmluZztcbn1cbi8qKlxuICogVE9ETzogVGVzdCB0aGF0IGEgc2luZ2xlIGNoaWxkIGFuZCBhbiBhcnJheSB3aXRoIG9uZSBpdGVtIGhhdmUgdGhlIHNhbWUga2V5XG4gKiBwYXR0ZXJuLlxuICovXG5cblxudmFyIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcbnZhciB1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCA9IC9cXC8rL2c7XG5cbmZ1bmN0aW9uIGVzY2FwZVVzZXJQcm92aWRlZEtleSh0ZXh0KSB7XG4gIHJldHVybiB0ZXh0LnJlcGxhY2UodXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXgsICckJi8nKTtcbn1cbi8qKlxuICogR2VuZXJhdGUgYSBrZXkgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyBhIGVsZW1lbnQgd2l0aGluIGEgc2V0LlxuICpcbiAqIEBwYXJhbSB7Kn0gZWxlbWVudCBBIGVsZW1lbnQgdGhhdCBjb3VsZCBjb250YWluIGEgbWFudWFsIGtleS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCB0aGF0IGlzIHVzZWQgaWYgYSBtYW51YWwga2V5IGlzIG5vdCBwcm92aWRlZC5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldEVsZW1lbnRLZXkoZWxlbWVudCwgaW5kZXgpIHtcbiAgLy8gRG8gc29tZSB0eXBlY2hlY2tpbmcgaGVyZSBzaW5jZSB3ZSBjYWxsIHRoaXMgYmxpbmRseS4gV2Ugd2FudCB0byBlbnN1cmVcbiAgLy8gdGhhdCB3ZSBkb24ndCBibG9jayBwb3RlbnRpYWwgZnV0dXJlIEVTIEFQSXMuXG4gIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ29iamVjdCcgJiYgZWxlbWVudCAhPT0gbnVsbCAmJiBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgLy8gRXhwbGljaXQga2V5XG4gICAgcmV0dXJuIGVzY2FwZSgnJyArIGVsZW1lbnQua2V5KTtcbiAgfSAvLyBJbXBsaWNpdCBrZXkgZGV0ZXJtaW5lZCBieSB0aGUgaW5kZXggaW4gdGhlIHNldFxuXG5cbiAgcmV0dXJuIGluZGV4LnRvU3RyaW5nKDM2KTtcbn1cblxuZnVuY3Rpb24gbWFwSW50b0FycmF5KGNoaWxkcmVuLCBhcnJheSwgZXNjYXBlZFByZWZpeCwgbmFtZVNvRmFyLCBjYWxsYmFjaykge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBjaGlsZHJlbjtcblxuICBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgLy8gQWxsIG9mIHRoZSBhYm92ZSBhcmUgcGVyY2VpdmVkIGFzIG51bGwuXG4gICAgY2hpbGRyZW4gPSBudWxsO1xuICB9XG5cbiAgdmFyIGludm9rZUNhbGxiYWNrID0gZmFsc2U7XG5cbiAgaWYgKGNoaWxkcmVuID09PSBudWxsKSB7XG4gICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHN3aXRjaCAoY2hpbGRyZW4uJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICB9XG4gIH1cblxuICBpZiAoaW52b2tlQ2FsbGJhY2spIHtcbiAgICB2YXIgX2NoaWxkID0gY2hpbGRyZW47XG4gICAgdmFyIG1hcHBlZENoaWxkID0gY2FsbGJhY2soX2NoaWxkKTsgLy8gSWYgaXQncyB0aGUgb25seSBjaGlsZCwgdHJlYXQgdGhlIG5hbWUgYXMgaWYgaXQgd2FzIHdyYXBwZWQgaW4gYW4gYXJyYXlcbiAgICAvLyBzbyB0aGF0IGl0J3MgY29uc2lzdGVudCBpZiB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIGdyb3dzOlxuXG4gICAgdmFyIGNoaWxkS2V5ID0gbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiArIGdldEVsZW1lbnRLZXkoX2NoaWxkLCAwKSA6IG5hbWVTb0ZhcjtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KG1hcHBlZENoaWxkKSkge1xuICAgICAgdmFyIGVzY2FwZWRDaGlsZEtleSA9ICcnO1xuXG4gICAgICBpZiAoY2hpbGRLZXkgIT0gbnVsbCkge1xuICAgICAgICBlc2NhcGVkQ2hpbGRLZXkgPSBlc2NhcGVVc2VyUHJvdmlkZWRLZXkoY2hpbGRLZXkpICsgJy8nO1xuICAgICAgfVxuXG4gICAgICBtYXBJbnRvQXJyYXkobWFwcGVkQ2hpbGQsIGFycmF5LCBlc2NhcGVkQ2hpbGRLZXksICcnLCBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gYztcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAobWFwcGVkQ2hpbGQgIT0gbnVsbCkge1xuICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KG1hcHBlZENoaWxkKSkge1xuICAgICAgICBtYXBwZWRDaGlsZCA9IGNsb25lQW5kUmVwbGFjZUtleShtYXBwZWRDaGlsZCwgLy8gS2VlcCBib3RoIHRoZSAobWFwcGVkKSBhbmQgb2xkIGtleXMgaWYgdGhleSBkaWZmZXIsIGp1c3QgYXNcbiAgICAgICAgLy8gdHJhdmVyc2VBbGxDaGlsZHJlbiB1c2VkIHRvIGRvIGZvciBvYmplY3RzIGFzIGNoaWxkcmVuXG4gICAgICAgIGVzY2FwZWRQcmVmaXggKyAoIC8vICRGbG93Rml4TWUgRmxvdyBpbmNvcnJlY3RseSB0aGlua3MgUmVhY3QuUG9ydGFsIGRvZXNuJ3QgaGF2ZSBhIGtleVxuICAgICAgICBtYXBwZWRDaGlsZC5rZXkgJiYgKCFfY2hpbGQgfHwgX2NoaWxkLmtleSAhPT0gbWFwcGVkQ2hpbGQua2V5KSA/IC8vICRGbG93Rml4TWUgRmxvdyBpbmNvcnJlY3RseSB0aGlua3MgZXhpc3RpbmcgZWxlbWVudCdzIGtleSBjYW4gYmUgYSBudW1iZXJcbiAgICAgICAgZXNjYXBlVXNlclByb3ZpZGVkS2V5KCcnICsgbWFwcGVkQ2hpbGQua2V5KSArICcvJyA6ICcnKSArIGNoaWxkS2V5KTtcbiAgICAgIH1cblxuICAgICAgYXJyYXkucHVzaChtYXBwZWRDaGlsZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICB2YXIgY2hpbGQ7XG4gIHZhciBuZXh0TmFtZTtcbiAgdmFyIHN1YnRyZWVDb3VudCA9IDA7IC8vIENvdW50IG9mIGNoaWxkcmVuIGZvdW5kIGluIHRoZSBjdXJyZW50IHN1YnRyZWUuXG5cbiAgdmFyIG5leHROYW1lUHJlZml4ID0gbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiA6IG5hbWVTb0ZhciArIFNVQlNFUEFSQVRPUjtcblxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldEVsZW1lbnRLZXkoY2hpbGQsIGkpO1xuICAgICAgc3VidHJlZUNvdW50ICs9IG1hcEludG9BcnJheShjaGlsZCwgYXJyYXksIGVzY2FwZWRQcmVmaXgsIG5leHROYW1lLCBjYWxsYmFjayk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihjaGlsZHJlbik7XG5cbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBpdGVyYWJsZUNoaWxkcmVuID0gY2hpbGRyZW47XG5cbiAgICAgIHtcbiAgICAgICAgLy8gV2FybiBhYm91dCB1c2luZyBNYXBzIGFzIGNoaWxkcmVuXG4gICAgICAgIGlmIChpdGVyYXRvckZuID09PSBpdGVyYWJsZUNoaWxkcmVuLmVudHJpZXMpIHtcbiAgICAgICAgICBpZiAoIWRpZFdhcm5BYm91dE1hcHMpIHtcbiAgICAgICAgICAgIHdhcm4oJ1VzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgbm90IHN1cHBvcnRlZC4gJyArICdVc2UgYW4gYXJyYXkgb2Yga2V5ZWQgUmVhY3RFbGVtZW50cyBpbnN0ZWFkLicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRpZFdhcm5BYm91dE1hcHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChpdGVyYWJsZUNoaWxkcmVuKTtcbiAgICAgIHZhciBzdGVwO1xuICAgICAgdmFyIGlpID0gMDtcblxuICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICBjaGlsZCA9IHN0ZXAudmFsdWU7XG4gICAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRFbGVtZW50S2V5KGNoaWxkLCBpaSsrKTtcbiAgICAgICAgc3VidHJlZUNvdW50ICs9IG1hcEludG9BcnJheShjaGlsZCwgYXJyYXksIGVzY2FwZWRQcmVmaXgsIG5leHROYW1lLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGNoaWxkcmVuU3RyaW5nID0gJycgKyBjaGlsZHJlbjtcblxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoIFwiT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiBcIiArIChjaGlsZHJlblN0cmluZyA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKGNoaWxkcmVuKS5qb2luKCcsICcpICsgJ30nIDogY2hpbGRyZW5TdHJpbmcpICsgXCIpLiBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5IGluc3RlYWQuXCIgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdWJ0cmVlQ291bnQ7XG59XG5cbi8qKlxuICogTWFwcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVubWFwXG4gKlxuICogVGhlIHByb3ZpZGVkIG1hcEZ1bmN0aW9uKGNoaWxkLCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZ1bmMgVGhlIG1hcCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBDb250ZXh0IGZvciBtYXBGdW5jdGlvbi5cbiAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9yZGVyZWQgbWFwIG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jLCBjb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgY291bnQgPSAwO1xuICBtYXBJbnRvQXJyYXkoY2hpbGRyZW4sIHJlc3VsdCwgJycsICcnLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBjb3VudCsrKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIENvdW50IHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhc1xuICogYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW5jb3VudFxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuLlxuICovXG5cblxuZnVuY3Rpb24gY291bnRDaGlsZHJlbihjaGlsZHJlbikge1xuICB2YXIgbiA9IDA7XG4gIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jdGlvbiAoKSB7XG4gICAgbisrOyAvLyBEb24ndCByZXR1cm4gYW55dGhpbmdcbiAgfSk7XG4gIHJldHVybiBuO1xufVxuXG4vKipcbiAqIEl0ZXJhdGVzIHRocm91Z2ggY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbmZvcmVhY2hcbiAqXG4gKiBUaGUgcHJvdmlkZWQgZm9yRWFjaEZ1bmMoY2hpbGQsIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZm9yRWFjaEZ1bmNcbiAqIEBwYXJhbSB7Kn0gZm9yRWFjaENvbnRleHQgQ29udGV4dCBmb3IgZm9yRWFjaENvbnRleHQuXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2hDaGlsZHJlbihjaGlsZHJlbiwgZm9yRWFjaEZ1bmMsIGZvckVhY2hDb250ZXh0KSB7XG4gIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jdGlvbiAoKSB7XG4gICAgZm9yRWFjaEZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gRG9uJ3QgcmV0dXJuIGFueXRoaW5nLlxuICB9LCBmb3JFYWNoQ29udGV4dCk7XG59XG4vKipcbiAqIEZsYXR0ZW4gYSBjaGlsZHJlbiBvYmplY3QgKHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCkgYW5kXG4gKiByZXR1cm4gYW4gYXJyYXkgd2l0aCBhcHByb3ByaWF0ZWx5IHJlLWtleWVkIGNoaWxkcmVuLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbnRvYXJyYXlcbiAqL1xuXG5cbmZ1bmN0aW9uIHRvQXJyYXkoY2hpbGRyZW4pIHtcbiAgcmV0dXJuIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICByZXR1cm4gY2hpbGQ7XG4gIH0pIHx8IFtdO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBjaGlsZCBpbiBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4gYW5kIHZlcmlmaWVzIHRoYXQgdGhlcmVcbiAqIGlzIG9ubHkgb25lIGNoaWxkIGluIHRoZSBjb2xsZWN0aW9uLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbm9ubHlcbiAqXG4gKiBUaGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCBhIHNpbmdsZSBjaGlsZCBnZXRzXG4gKiBwYXNzZWQgd2l0aG91dCBhIHdyYXBwZXIsIGJ1dCB0aGUgcHVycG9zZSBvZiB0aGlzIGhlbHBlciBmdW5jdGlvbiBpcyB0b1xuICogYWJzdHJhY3QgYXdheSB0aGUgcGFydGljdWxhciBzdHJ1Y3R1cmUgb2YgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBjaGlsZHJlbiBDaGlsZCBjb2xsZWN0aW9uIHN0cnVjdHVyZS5cbiAqIEByZXR1cm4ge1JlYWN0RWxlbWVudH0gVGhlIGZpcnN0IGFuZCBvbmx5IGBSZWFjdEVsZW1lbnRgIGNvbnRhaW5lZCBpbiB0aGVcbiAqIHN0cnVjdHVyZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIG9ubHlDaGlsZChjaGlsZHJlbikge1xuICBpZiAoIWlzVmFsaWRFbGVtZW50KGNoaWxkcmVuKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIlJlYWN0LkNoaWxkcmVuLm9ubHkgZXhwZWN0ZWQgdG8gcmVjZWl2ZSBhIHNpbmdsZSBSZWFjdCBlbGVtZW50IGNoaWxkLlwiICk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb250ZXh0KGRlZmF1bHRWYWx1ZSwgY2FsY3VsYXRlQ2hhbmdlZEJpdHMpIHtcbiAgaWYgKGNhbGN1bGF0ZUNoYW5nZWRCaXRzID09PSB1bmRlZmluZWQpIHtcbiAgICBjYWxjdWxhdGVDaGFuZ2VkQml0cyA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAge1xuICAgICAgaWYgKGNhbGN1bGF0ZUNoYW5nZWRCaXRzICE9PSBudWxsICYmIHR5cGVvZiBjYWxjdWxhdGVDaGFuZ2VkQml0cyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBlcnJvcignY3JlYXRlQ29udGV4dDogRXhwZWN0ZWQgdGhlIG9wdGlvbmFsIHNlY29uZCBhcmd1bWVudCB0byBiZSBhICcgKyAnZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzJywgY2FsY3VsYXRlQ2hhbmdlZEJpdHMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBjb250ZXh0ID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9DT05URVhUX1RZUEUsXG4gICAgX2NhbGN1bGF0ZUNoYW5nZWRCaXRzOiBjYWxjdWxhdGVDaGFuZ2VkQml0cyxcbiAgICAvLyBBcyBhIHdvcmthcm91bmQgdG8gc3VwcG9ydCBtdWx0aXBsZSBjb25jdXJyZW50IHJlbmRlcmVycywgd2UgY2F0ZWdvcml6ZVxuICAgIC8vIHNvbWUgcmVuZGVyZXJzIGFzIHByaW1hcnkgYW5kIG90aGVycyBhcyBzZWNvbmRhcnkuIFdlIG9ubHkgZXhwZWN0XG4gICAgLy8gdGhlcmUgdG8gYmUgdHdvIGNvbmN1cnJlbnQgcmVuZGVyZXJzIGF0IG1vc3Q6IFJlYWN0IE5hdGl2ZSAocHJpbWFyeSkgYW5kXG4gICAgLy8gRmFicmljIChzZWNvbmRhcnkpOyBSZWFjdCBET00gKHByaW1hcnkpIGFuZCBSZWFjdCBBUlQgKHNlY29uZGFyeSkuXG4gICAgLy8gU2Vjb25kYXJ5IHJlbmRlcmVycyBzdG9yZSB0aGVpciBjb250ZXh0IHZhbHVlcyBvbiBzZXBhcmF0ZSBmaWVsZHMuXG4gICAgX2N1cnJlbnRWYWx1ZTogZGVmYXVsdFZhbHVlLFxuICAgIF9jdXJyZW50VmFsdWUyOiBkZWZhdWx0VmFsdWUsXG4gICAgLy8gVXNlZCB0byB0cmFjayBob3cgbWFueSBjb25jdXJyZW50IHJlbmRlcmVycyB0aGlzIGNvbnRleHQgY3VycmVudGx5XG4gICAgLy8gc3VwcG9ydHMgd2l0aGluIGluIGEgc2luZ2xlIHJlbmRlcmVyLiBTdWNoIGFzIHBhcmFsbGVsIHNlcnZlciByZW5kZXJpbmcuXG4gICAgX3RocmVhZENvdW50OiAwLFxuICAgIC8vIFRoZXNlIGFyZSBjaXJjdWxhclxuICAgIFByb3ZpZGVyOiBudWxsLFxuICAgIENvbnN1bWVyOiBudWxsXG4gIH07XG4gIGNvbnRleHQuUHJvdmlkZXIgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX1BST1ZJREVSX1RZUEUsXG4gICAgX2NvbnRleHQ6IGNvbnRleHRcbiAgfTtcbiAgdmFyIGhhc1dhcm5lZEFib3V0VXNpbmdOZXN0ZWRDb250ZXh0Q29uc3VtZXJzID0gZmFsc2U7XG4gIHZhciBoYXNXYXJuZWRBYm91dFVzaW5nQ29uc3VtZXJQcm92aWRlciA9IGZhbHNlO1xuICB2YXIgaGFzV2FybmVkQWJvdXREaXNwbGF5TmFtZU9uQ29uc3VtZXIgPSBmYWxzZTtcblxuICB7XG4gICAgLy8gQSBzZXBhcmF0ZSBvYmplY3QsIGJ1dCBwcm94aWVzIGJhY2sgdG8gdGhlIG9yaWdpbmFsIGNvbnRleHQgb2JqZWN0IGZvclxuICAgIC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LiBJdCBoYXMgYSBkaWZmZXJlbnQgJCR0eXBlb2YsIHNvIHdlIGNhbiBwcm9wZXJseVxuICAgIC8vIHdhcm4gZm9yIHRoZSBpbmNvcnJlY3QgdXNhZ2Ugb2YgQ29udGV4dCBhcyBhIENvbnN1bWVyLlxuICAgIHZhciBDb25zdW1lciA9IHtcbiAgICAgICQkdHlwZW9mOiBSRUFDVF9DT05URVhUX1RZUEUsXG4gICAgICBfY29udGV4dDogY29udGV4dCxcbiAgICAgIF9jYWxjdWxhdGVDaGFuZ2VkQml0czogY29udGV4dC5fY2FsY3VsYXRlQ2hhbmdlZEJpdHNcbiAgICB9OyAvLyAkRmxvd0ZpeE1lOiBGbG93IGNvbXBsYWlucyBhYm91dCBub3Qgc2V0dGluZyBhIHZhbHVlLCB3aGljaCBpcyBpbnRlbnRpb25hbCBoZXJlXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhDb25zdW1lciwge1xuICAgICAgUHJvdmlkZXI6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKCFoYXNXYXJuZWRBYm91dFVzaW5nQ29uc3VtZXJQcm92aWRlcikge1xuICAgICAgICAgICAgaGFzV2FybmVkQWJvdXRVc2luZ0NvbnN1bWVyUHJvdmlkZXIgPSB0cnVlO1xuXG4gICAgICAgICAgICBlcnJvcignUmVuZGVyaW5nIDxDb250ZXh0LkNvbnN1bWVyLlByb3ZpZGVyPiBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gJyArICdhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBEaWQgeW91IG1lYW4gdG8gcmVuZGVyIDxDb250ZXh0LlByb3ZpZGVyPiBpbnN0ZWFkPycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjb250ZXh0LlByb3ZpZGVyO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChfUHJvdmlkZXIpIHtcbiAgICAgICAgICBjb250ZXh0LlByb3ZpZGVyID0gX1Byb3ZpZGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX2N1cnJlbnRWYWx1ZToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5fY3VycmVudFZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChfY3VycmVudFZhbHVlKSB7XG4gICAgICAgICAgY29udGV4dC5fY3VycmVudFZhbHVlID0gX2N1cnJlbnRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF9jdXJyZW50VmFsdWUyOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0Ll9jdXJyZW50VmFsdWUyO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChfY3VycmVudFZhbHVlMikge1xuICAgICAgICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTIgPSBfY3VycmVudFZhbHVlMjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF90aHJlYWRDb3VudDoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5fdGhyZWFkQ291bnQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKF90aHJlYWRDb3VudCkge1xuICAgICAgICAgIGNvbnRleHQuX3RocmVhZENvdW50ID0gX3RocmVhZENvdW50O1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgQ29uc3VtZXI6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKCFoYXNXYXJuZWRBYm91dFVzaW5nTmVzdGVkQ29udGV4dENvbnN1bWVycykge1xuICAgICAgICAgICAgaGFzV2FybmVkQWJvdXRVc2luZ05lc3RlZENvbnRleHRDb25zdW1lcnMgPSB0cnVlO1xuXG4gICAgICAgICAgICBlcnJvcignUmVuZGVyaW5nIDxDb250ZXh0LkNvbnN1bWVyLkNvbnN1bWVyPiBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gJyArICdhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBEaWQgeW91IG1lYW4gdG8gcmVuZGVyIDxDb250ZXh0LkNvbnN1bWVyPiBpbnN0ZWFkPycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjb250ZXh0LkNvbnN1bWVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGlzcGxheU5hbWU6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuZGlzcGxheU5hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKGRpc3BsYXlOYW1lKSB7XG4gICAgICAgICAgaWYgKCFoYXNXYXJuZWRBYm91dERpc3BsYXlOYW1lT25Db25zdW1lcikge1xuICAgICAgICAgICAgd2FybignU2V0dGluZyBgZGlzcGxheU5hbWVgIG9uIENvbnRleHQuQ29uc3VtZXIgaGFzIG5vIGVmZmVjdC4gJyArIFwiWW91IHNob3VsZCBzZXQgaXQgZGlyZWN0bHkgb24gdGhlIGNvbnRleHQgd2l0aCBDb250ZXh0LmRpc3BsYXlOYW1lID0gJyVzJy5cIiwgZGlzcGxheU5hbWUpO1xuXG4gICAgICAgICAgICBoYXNXYXJuZWRBYm91dERpc3BsYXlOYW1lT25Db25zdW1lciA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7IC8vICRGbG93Rml4TWU6IEZsb3cgY29tcGxhaW5zIGFib3V0IG1pc3NpbmcgcHJvcGVydGllcyBiZWNhdXNlIGl0IGRvZXNuJ3QgdW5kZXJzdGFuZCBkZWZpbmVQcm9wZXJ0eVxuXG4gICAgY29udGV4dC5Db25zdW1lciA9IENvbnN1bWVyO1xuICB9XG5cbiAge1xuICAgIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciA9IG51bGw7XG4gICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyMiA9IG51bGw7XG4gIH1cblxuICByZXR1cm4gY29udGV4dDtcbn1cblxudmFyIFVuaW5pdGlhbGl6ZWQgPSAtMTtcbnZhciBQZW5kaW5nID0gMDtcbnZhciBSZXNvbHZlZCA9IDE7XG52YXIgUmVqZWN0ZWQgPSAyO1xuXG5mdW5jdGlvbiBsYXp5SW5pdGlhbGl6ZXIocGF5bG9hZCkge1xuICBpZiAocGF5bG9hZC5fc3RhdHVzID09PSBVbmluaXRpYWxpemVkKSB7XG4gICAgdmFyIGN0b3IgPSBwYXlsb2FkLl9yZXN1bHQ7XG4gICAgdmFyIHRoZW5hYmxlID0gY3RvcigpOyAvLyBUcmFuc2l0aW9uIHRvIHRoZSBuZXh0IHN0YXRlLlxuXG4gICAgdmFyIHBlbmRpbmcgPSBwYXlsb2FkO1xuICAgIHBlbmRpbmcuX3N0YXR1cyA9IFBlbmRpbmc7XG4gICAgcGVuZGluZy5fcmVzdWx0ID0gdGhlbmFibGU7XG4gICAgdGhlbmFibGUudGhlbihmdW5jdGlvbiAobW9kdWxlT2JqZWN0KSB7XG4gICAgICBpZiAocGF5bG9hZC5fc3RhdHVzID09PSBQZW5kaW5nKSB7XG4gICAgICAgIHZhciBkZWZhdWx0RXhwb3J0ID0gbW9kdWxlT2JqZWN0LmRlZmF1bHQ7XG5cbiAgICAgICAge1xuICAgICAgICAgIGlmIChkZWZhdWx0RXhwb3J0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVycm9yKCdsYXp5OiBFeHBlY3RlZCB0aGUgcmVzdWx0IG9mIGEgZHluYW1pYyBpbXBvcnQoKSBjYWxsLiAnICsgJ0luc3RlYWQgcmVjZWl2ZWQ6ICVzXFxuXFxuWW91ciBjb2RlIHNob3VsZCBsb29rIGxpa2U6IFxcbiAgJyArIC8vIEJyZWFrIHVwIGltcG9ydHMgdG8gYXZvaWQgYWNjaWRlbnRhbGx5IHBhcnNpbmcgdGhlbSBhcyBkZXBlbmRlbmNpZXMuXG4gICAgICAgICAgICAnY29uc3QgTXlDb21wb25lbnQgPSBsYXp5KCgpID0+IGltcCcgKyBcIm9ydCgnLi9NeUNvbXBvbmVudCcpKVwiLCBtb2R1bGVPYmplY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBUcmFuc2l0aW9uIHRvIHRoZSBuZXh0IHN0YXRlLlxuXG5cbiAgICAgICAgdmFyIHJlc29sdmVkID0gcGF5bG9hZDtcbiAgICAgICAgcmVzb2x2ZWQuX3N0YXR1cyA9IFJlc29sdmVkO1xuICAgICAgICByZXNvbHZlZC5fcmVzdWx0ID0gZGVmYXVsdEV4cG9ydDtcbiAgICAgIH1cbiAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIGlmIChwYXlsb2FkLl9zdGF0dXMgPT09IFBlbmRpbmcpIHtcbiAgICAgICAgLy8gVHJhbnNpdGlvbiB0byB0aGUgbmV4dCBzdGF0ZS5cbiAgICAgICAgdmFyIHJlamVjdGVkID0gcGF5bG9hZDtcbiAgICAgICAgcmVqZWN0ZWQuX3N0YXR1cyA9IFJlamVjdGVkO1xuICAgICAgICByZWplY3RlZC5fcmVzdWx0ID0gZXJyb3I7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAocGF5bG9hZC5fc3RhdHVzID09PSBSZXNvbHZlZCkge1xuICAgIHJldHVybiBwYXlsb2FkLl9yZXN1bHQ7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgcGF5bG9hZC5fcmVzdWx0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGxhenkoY3Rvcikge1xuICB2YXIgcGF5bG9hZCA9IHtcbiAgICAvLyBXZSB1c2UgdGhlc2UgZmllbGRzIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gICAgX3N0YXR1czogLTEsXG4gICAgX3Jlc3VsdDogY3RvclxuICB9O1xuICB2YXIgbGF6eVR5cGUgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0xBWllfVFlQRSxcbiAgICBfcGF5bG9hZDogcGF5bG9hZCxcbiAgICBfaW5pdDogbGF6eUluaXRpYWxpemVyXG4gIH07XG5cbiAge1xuICAgIC8vIEluIHByb2R1Y3Rpb24sIHRoaXMgd291bGQganVzdCBzZXQgaXQgb24gdGhlIG9iamVjdC5cbiAgICB2YXIgZGVmYXVsdFByb3BzO1xuICAgIHZhciBwcm9wVHlwZXM7IC8vICRGbG93Rml4TWVcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGxhenlUeXBlLCB7XG4gICAgICBkZWZhdWx0UHJvcHM6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gZGVmYXVsdFByb3BzO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXdEZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgICBlcnJvcignUmVhY3QubGF6eSguLi4pOiBJdCBpcyBub3Qgc3VwcG9ydGVkIHRvIGFzc2lnbiBgZGVmYXVsdFByb3BzYCB0byAnICsgJ2EgbGF6eSBjb21wb25lbnQgaW1wb3J0LiBFaXRoZXIgc3BlY2lmeSB0aGVtIHdoZXJlIHRoZSBjb21wb25lbnQgJyArICdpcyBkZWZpbmVkLCBvciBjcmVhdGUgYSB3cmFwcGluZyBjb21wb25lbnQgYXJvdW5kIGl0LicpO1xuXG4gICAgICAgICAgZGVmYXVsdFByb3BzID0gbmV3RGVmYXVsdFByb3BzOyAvLyBNYXRjaCBwcm9kdWN0aW9uIGJlaGF2aW9yIG1vcmUgY2xvc2VseTpcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobGF6eVR5cGUsICdkZWZhdWx0UHJvcHMnLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwcm9wVHlwZXM6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcFR5cGVzO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXdQcm9wVHlwZXMpIHtcbiAgICAgICAgICBlcnJvcignUmVhY3QubGF6eSguLi4pOiBJdCBpcyBub3Qgc3VwcG9ydGVkIHRvIGFzc2lnbiBgcHJvcFR5cGVzYCB0byAnICsgJ2EgbGF6eSBjb21wb25lbnQgaW1wb3J0LiBFaXRoZXIgc3BlY2lmeSB0aGVtIHdoZXJlIHRoZSBjb21wb25lbnQgJyArICdpcyBkZWZpbmVkLCBvciBjcmVhdGUgYSB3cmFwcGluZyBjb21wb25lbnQgYXJvdW5kIGl0LicpO1xuXG4gICAgICAgICAgcHJvcFR5cGVzID0gbmV3UHJvcFR5cGVzOyAvLyBNYXRjaCBwcm9kdWN0aW9uIGJlaGF2aW9yIG1vcmUgY2xvc2VseTpcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobGF6eVR5cGUsICdwcm9wVHlwZXMnLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBsYXp5VHlwZTtcbn1cblxuZnVuY3Rpb24gZm9yd2FyZFJlZihyZW5kZXIpIHtcbiAge1xuICAgIGlmIChyZW5kZXIgIT0gbnVsbCAmJiByZW5kZXIuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkge1xuICAgICAgZXJyb3IoJ2ZvcndhcmRSZWYgcmVxdWlyZXMgYSByZW5kZXIgZnVuY3Rpb24gYnV0IHJlY2VpdmVkIGEgYG1lbW9gICcgKyAnY29tcG9uZW50LiBJbnN0ZWFkIG9mIGZvcndhcmRSZWYobWVtbyguLi4pKSwgdXNlICcgKyAnbWVtbyhmb3J3YXJkUmVmKC4uLikpLicpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlbmRlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJ2ZvcndhcmRSZWYgcmVxdWlyZXMgYSByZW5kZXIgZnVuY3Rpb24gYnV0IHdhcyBnaXZlbiAlcy4nLCByZW5kZXIgPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2YgcmVuZGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHJlbmRlci5sZW5ndGggIT09IDAgJiYgcmVuZGVyLmxlbmd0aCAhPT0gMikge1xuICAgICAgICBlcnJvcignZm9yd2FyZFJlZiByZW5kZXIgZnVuY3Rpb25zIGFjY2VwdCBleGFjdGx5IHR3byBwYXJhbWV0ZXJzOiBwcm9wcyBhbmQgcmVmLiAlcycsIHJlbmRlci5sZW5ndGggPT09IDEgPyAnRGlkIHlvdSBmb3JnZXQgdG8gdXNlIHRoZSByZWYgcGFyYW1ldGVyPycgOiAnQW55IGFkZGl0aW9uYWwgcGFyYW1ldGVyIHdpbGwgYmUgdW5kZWZpbmVkLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZW5kZXIgIT0gbnVsbCkge1xuICAgICAgaWYgKHJlbmRlci5kZWZhdWx0UHJvcHMgIT0gbnVsbCB8fCByZW5kZXIucHJvcFR5cGVzICE9IG51bGwpIHtcbiAgICAgICAgZXJyb3IoJ2ZvcndhcmRSZWYgcmVuZGVyIGZ1bmN0aW9ucyBkbyBub3Qgc3VwcG9ydCBwcm9wVHlwZXMgb3IgZGVmYXVsdFByb3BzLiAnICsgJ0RpZCB5b3UgYWNjaWRlbnRhbGx5IHBhc3MgYSBSZWFjdCBjb21wb25lbnQ/Jyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGVsZW1lbnRUeXBlID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFLFxuICAgIHJlbmRlcjogcmVuZGVyXG4gIH07XG5cbiAge1xuICAgIHZhciBvd25OYW1lO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50VHlwZSwgJ2Rpc3BsYXlOYW1lJywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG93bk5hbWU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBvd25OYW1lID0gbmFtZTtcblxuICAgICAgICBpZiAocmVuZGVyLmRpc3BsYXlOYW1lID09IG51bGwpIHtcbiAgICAgICAgICByZW5kZXIuZGlzcGxheU5hbWUgPSBuYW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudFR5cGU7XG59XG5cbi8vIEZpbHRlciBjZXJ0YWluIERPTSBhdHRyaWJ1dGVzIChlLmcuIHNyYywgaHJlZikgaWYgdGhlaXIgdmFsdWVzIGFyZSBlbXB0eSBzdHJpbmdzLlxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gTm90ZTogdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgKGUuZy4gaWYgaXQncyBhIHBvbHlmaWxsKS5cblxuXG4gIGlmICh0eXBlID09PSBleHBvcnRzLkZyYWdtZW50IHx8IHR5cGUgPT09IGV4cG9ydHMuUHJvZmlsZXIgfHwgdHlwZSA9PT0gUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgfHwgdHlwZSA9PT0gZXhwb3J0cy5TdHJpY3RNb2RlIHx8IHR5cGUgPT09IGV4cG9ydHMuU3VzcGVuc2UgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSB8fCBlbmFibGVTY29wZUFQSSApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9CTE9DS19UWVBFIHx8IHR5cGVbMF0gPT09IFJFQUNUX1NFUlZFUl9CTE9DS19UWVBFKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG1lbW8odHlwZSwgY29tcGFyZSkge1xuICB7XG4gICAgaWYgKCFpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkpIHtcbiAgICAgIGVycm9yKCdtZW1vOiBUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIGNvbXBvbmVudC4gSW5zdGVhZCAnICsgJ3JlY2VpdmVkOiAlcycsIHR5cGUgPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2YgdHlwZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGVsZW1lbnRUeXBlID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9NRU1PX1RZUEUsXG4gICAgdHlwZTogdHlwZSxcbiAgICBjb21wYXJlOiBjb21wYXJlID09PSB1bmRlZmluZWQgPyBudWxsIDogY29tcGFyZVxuICB9O1xuXG4gIHtcbiAgICB2YXIgb3duTmFtZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudFR5cGUsICdkaXNwbGF5TmFtZScsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBvd25OYW1lO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgb3duTmFtZSA9IG5hbWU7XG5cbiAgICAgICAgaWYgKHR5cGUuZGlzcGxheU5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgIHR5cGUuZGlzcGxheU5hbWUgPSBuYW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudFR5cGU7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVEaXNwYXRjaGVyKCkge1xuICB2YXIgZGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDtcblxuICBpZiAoIShkaXNwYXRjaGVyICE9PSBudWxsKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIkludmFsaWQgaG9vayBjYWxsLiBIb29rcyBjYW4gb25seSBiZSBjYWxsZWQgaW5zaWRlIG9mIHRoZSBib2R5IG9mIGEgZnVuY3Rpb24gY29tcG9uZW50LiBUaGlzIGNvdWxkIGhhcHBlbiBmb3Igb25lIG9mIHRoZSBmb2xsb3dpbmcgcmVhc29uczpcXG4xLiBZb3UgbWlnaHQgaGF2ZSBtaXNtYXRjaGluZyB2ZXJzaW9ucyBvZiBSZWFjdCBhbmQgdGhlIHJlbmRlcmVyIChzdWNoIGFzIFJlYWN0IERPTSlcXG4yLiBZb3UgbWlnaHQgYmUgYnJlYWtpbmcgdGhlIFJ1bGVzIG9mIEhvb2tzXFxuMy4gWW91IG1pZ2h0IGhhdmUgbW9yZSB0aGFuIG9uZSBjb3B5IG9mIFJlYWN0IGluIHRoZSBzYW1lIGFwcFxcblNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvaW52YWxpZC1ob29rLWNhbGwgZm9yIHRpcHMgYWJvdXQgaG93IHRvIGRlYnVnIGFuZCBmaXggdGhpcyBwcm9ibGVtLlwiICk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRpc3BhdGNoZXI7XG59XG5cbmZ1bmN0aW9uIHVzZUNvbnRleHQoQ29udGV4dCwgdW5zdGFibGVfb2JzZXJ2ZWRCaXRzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcblxuICB7XG4gICAgaWYgKHVuc3RhYmxlX29ic2VydmVkQml0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvcigndXNlQ29udGV4dCgpIHNlY29uZCBhcmd1bWVudCBpcyByZXNlcnZlZCBmb3IgZnV0dXJlICcgKyAndXNlIGluIFJlYWN0LiBQYXNzaW5nIGl0IGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnWW91IHBhc3NlZDogJXMuJXMnLCB1bnN0YWJsZV9vYnNlcnZlZEJpdHMsIHR5cGVvZiB1bnN0YWJsZV9vYnNlcnZlZEJpdHMgPT09ICdudW1iZXInICYmIEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzJdKSA/ICdcXG5cXG5EaWQgeW91IGNhbGwgYXJyYXkubWFwKHVzZUNvbnRleHQpPyAnICsgJ0NhbGxpbmcgSG9va3MgaW5zaWRlIGEgbG9vcCBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ0xlYXJuIG1vcmUgYXQgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3J1bGVzLW9mLWhvb2tzJyA6ICcnKTtcbiAgICB9IC8vIFRPRE86IGFkZCBhIG1vcmUgZ2VuZXJpYyB3YXJuaW5nIGZvciBpbnZhbGlkIHZhbHVlcy5cblxuXG4gICAgaWYgKENvbnRleHQuX2NvbnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIHJlYWxDb250ZXh0ID0gQ29udGV4dC5fY29udGV4dDsgLy8gRG9uJ3QgZGVkdXBsaWNhdGUgYmVjYXVzZSB0aGlzIGxlZ2l0aW1hdGVseSBjYXVzZXMgYnVnc1xuICAgICAgLy8gYW5kIG5vYm9keSBzaG91bGQgYmUgdXNpbmcgdGhpcyBpbiBleGlzdGluZyBjb2RlLlxuXG4gICAgICBpZiAocmVhbENvbnRleHQuQ29uc3VtZXIgPT09IENvbnRleHQpIHtcbiAgICAgICAgZXJyb3IoJ0NhbGxpbmcgdXNlQ29udGV4dChDb250ZXh0LkNvbnN1bWVyKSBpcyBub3Qgc3VwcG9ydGVkLCBtYXkgY2F1c2UgYnVncywgYW5kIHdpbGwgYmUgJyArICdyZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuIERpZCB5b3UgbWVhbiB0byBjYWxsIHVzZUNvbnRleHQoQ29udGV4dCkgaW5zdGVhZD8nKTtcbiAgICAgIH0gZWxzZSBpZiAocmVhbENvbnRleHQuUHJvdmlkZXIgPT09IENvbnRleHQpIHtcbiAgICAgICAgZXJyb3IoJ0NhbGxpbmcgdXNlQ29udGV4dChDb250ZXh0LlByb3ZpZGVyKSBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ0RpZCB5b3UgbWVhbiB0byBjYWxsIHVzZUNvbnRleHQoQ29udGV4dCkgaW5zdGVhZD8nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGlzcGF0Y2hlci51c2VDb250ZXh0KENvbnRleHQsIHVuc3RhYmxlX29ic2VydmVkQml0cyk7XG59XG5mdW5jdGlvbiB1c2VTdGF0ZShpbml0aWFsU3RhdGUpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VTdGF0ZShpbml0aWFsU3RhdGUpO1xufVxuZnVuY3Rpb24gdXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbn1cbmZ1bmN0aW9uIHVzZVJlZihpbml0aWFsVmFsdWUpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VSZWYoaW5pdGlhbFZhbHVlKTtcbn1cbmZ1bmN0aW9uIHVzZUVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xufVxuZnVuY3Rpb24gdXNlTWVtbyhjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VNZW1vKGNyZWF0ZSwgZGVwcyk7XG59XG5mdW5jdGlvbiB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG59XG5mdW5jdGlvbiB1c2VEZWJ1Z1ZhbHVlKHZhbHVlLCBmb3JtYXR0ZXJGbikge1xuICB7XG4gICAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICAgIHJldHVybiBkaXNwYXRjaGVyLnVzZURlYnVnVmFsdWUodmFsdWUsIGZvcm1hdHRlckZuKTtcbiAgfVxufVxuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgIGxvZzogcHJvcHMsXG4gICAgICAgIHdhcm46IHByb3BzLFxuICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgIGdyb3VwOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBkaXNhYmxlZERlcHRoKys7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAge1xuICAgIGRpc2FibGVkRGVwdGgtLTtcblxuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZJbmZvXG4gICAgICAgIH0pLFxuICAgICAgICB3YXJuOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRyb2w7XG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7IC8vIFNldCB0aGUgZGlzcGF0Y2hlciBpbiBERVYgYmVjYXVzZSB0aGlzIG1pZ2h0IGJlIGNhbGwgaW4gdGhlIHJlbmRlciBmdW5jdGlvblxuICAgIC8vIGZvciB3YXJuaW5ncy5cblxuICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIHNob3VsZCB0aHJvdy5cbiAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfTsgLy8gJEZsb3dGaXhNZVxuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICB9XG5cbiAgICAgIGZuKCk7XG4gICAgfVxuICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAvLyBUaGlzIGlzIGlubGluZWQgbWFudWFsbHkgYmVjYXVzZSBjbG9zdXJlIGRvZXNuJ3QgZG8gaXQgZm9yIHVzLlxuICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gVGhpcyBleHRyYWN0cyB0aGUgZmlyc3QgZnJhbWUgZnJvbSB0aGUgc2FtcGxlIHRoYXQgaXNuJ3QgYWxzbyBpbiB0aGUgY29udHJvbC5cbiAgICAgIC8vIFNraXBwaW5nIG9uZSBmcmFtZSB0aGF0IHdlIGFzc3VtZSBpcyB0aGUgZnJhbWUgdGhhdCBjYWxscyB0aGUgdHdvLlxuICAgICAgdmFyIHNhbXBsZUxpbmVzID0gc2FtcGxlLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgLy8gV2UgZXhwZWN0IGF0IGxlYXN0IG9uZSBzdGFjayBmcmFtZSB0byBiZSBzaGFyZWQuXG4gICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgLy8gZWFybGllciB0aGFuIHRoZSBvdGhlci4gV2UgYXNzdW1lIHRoYXQgdGhlIHNhbXBsZSBpcyBsb25nZXIgb3IgdGhlIHNhbWVcbiAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgIGMtLTtcbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7XG5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gUmV0dXJuIHRoZSBsaW5lIHdlIGZvdW5kLlxuXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChzID49IDEgJiYgYyA+PSAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICByZWVudHJ5ID0gZmFsc2U7XG5cbiAgICB7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIGV4cG9ydHMuU3VzcGVuc2U6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfQkxPQ0tfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLl9yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIExhenkgbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGluaXQocGF5bG9hZCksIHNvdXJjZSwgb3duZXJGbik7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50KSB7XG4gIHtcbiAgICAvLyAkRmxvd0ZpeE1lIFRoaXMgaXMgb2theSBidXQgRmxvdyBkb2Vzbid0IGtub3cgaXQuXG4gICAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcblxuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvciQxID0gdm9pZCAwOyAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMnICsgJyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IkMSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvciQxLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yJDEubWVzc2FnZV0gPSB0cnVlO1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd247XG5cbntcbiAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpO1xuXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHNvdXJjZSkge1xuICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZmlsZU5hbWUgPSBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpO1xuICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgcmV0dXJuICdcXG5cXG5DaGVjayB5b3VyIGNvZGUgYXQgJyArIGZpbGVOYW1lICsgJzonICsgbGluZU51bWJlciArICcuJztcbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW1Gb3JQcm9wcyhlbGVtZW50UHJvcHMpIHtcbiAgaWYgKGVsZW1lbnRQcm9wcyAhPT0gbnVsbCAmJiBlbGVtZW50UHJvcHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShlbGVtZW50UHJvcHMuX19zb3VyY2UpO1xuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cblxuXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB2YXIgaW5mbyA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuXG4gIGlmICghaW5mbykge1xuICAgIHZhciBwYXJlbnROYW1lID0gdHlwZW9mIHBhcmVudFR5cGUgPT09ICdzdHJpbmcnID8gcGFyZW50VHlwZSA6IHBhcmVudFR5cGUuZGlzcGxheU5hbWUgfHwgcGFyZW50VHlwZS5uYW1lO1xuXG4gICAgaWYgKHBhcmVudE5hbWUpIHtcbiAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW5mbztcbn1cbi8qKlxuICogV2FybiBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQga2V5IGFzc2lnbmVkIHRvIGl0LlxuICogVGhpcyBlbGVtZW50IGlzIGluIGFuIGFycmF5LiBUaGUgYXJyYXkgY291bGQgZ3JvdyBhbmQgc2hyaW5rIG9yIGJlXG4gKiByZW9yZGVyZWQuIEFsbCBjaGlsZHJlbiB0aGF0IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIHZhbGlkYXRlZCBhcmUgcmVxdWlyZWQgdG9cbiAqIGhhdmUgYSBcImtleVwiIHByb3BlcnR5IGFzc2lnbmVkIHRvIGl0LiBFcnJvciBzdGF0dXNlcyBhcmUgY2FjaGVkIHNvIGEgd2FybmluZ1xuICogd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRoYXQgcmVxdWlyZXMgYSBrZXkuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgZWxlbWVudCdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUV4cGxpY2l0S2V5KGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcbiAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKTtcblxuICBpZiAob3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTsgLy8gVXN1YWxseSB0aGUgY3VycmVudCBvd25lciBpcyB0aGUgb2ZmZW5kZXIsIGJ1dCBpZiBpdCBhY2NlcHRzIGNoaWxkcmVuIGFzIGFcbiAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAvLyBhc3NpZ25pbmcgaXQgYSBrZXkuXG5cbiAgdmFyIGNoaWxkT3duZXIgPSAnJztcblxuICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgIC8vIEdpdmUgdGhlIGNvbXBvbmVudCB0aGF0IG9yaWdpbmFsbHkgY3JlYXRlZCB0aGlzIGNoaWxkLlxuICAgIGNoaWxkT3duZXIgPSBcIiBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSBcIiArIGdldENvbXBvbmVudE5hbWUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgfVxuXG4gIHtcbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuXG4gICAgZXJyb3IoJ0VhY2ggY2hpbGQgaW4gYSBsaXN0IHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4nICsgJyVzJXMgU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgY3VycmVudENvbXBvbmVudEVycm9ySW5mbywgY2hpbGRPd25lcik7XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICB9XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGV2ZXJ5IGVsZW1lbnQgZWl0aGVyIGlzIHBhc3NlZCBpbiBhIHN0YXRpYyBsb2NhdGlvbiwgaW4gYW5cbiAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxuICogd2l0aCB2YWxpZCBrZXkgcHJvcGVydHkuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZSBTdGF0aWNhbGx5IHBhc3NlZCBjaGlsZCBvZiBhbnkgdHlwZS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBub2RlJ3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgaWYgKG5vZGUuX3N0b3JlKSB7XG4gICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChub2RlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwcm9wVHlwZXM7XG5cbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIE5vdGU6IE1lbW8gb25seSBjaGVja3Mgb3V0ZXIgcHJvcHMgaGVyZS5cbiAgICAvLyBJbm5lciBwcm9wcyBhcmUgY2hlY2tlZCBpbiB0aGUgcmVjb25jaWxlci5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUpKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9wVHlwZXMpIHtcbiAgICAgIC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUodHlwZSk7XG4gICAgICBjaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIGVsZW1lbnQucHJvcHMsICdwcm9wJywgbmFtZSwgZWxlbWVudCk7XG4gICAgfSBlbHNlIGlmICh0eXBlLlByb3BUeXBlcyAhPT0gdW5kZWZpbmVkICYmICFwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bikge1xuICAgICAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSB0cnVlOyAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuXG4gICAgICB2YXIgX25hbWUgPSBnZXRDb21wb25lbnROYW1lKHR5cGUpO1xuXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShmcmFnbWVudCk7XG5cbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgcHJvcCBgJXNgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuICcgKyAnUmVhY3QuRnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBga2V5YCBhbmQgYGNoaWxkcmVuYCBwcm9wcy4nLCBrZXkpO1xuXG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgLy8gc3VjY2VlZCBhbmQgdGhlcmUgd2lsbCBsaWtlbHkgYmUgZXJyb3JzIGluIHJlbmRlci5cblxuICBpZiAoIXZhbGlkVHlwZSkge1xuICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICB9XG5cbiAgICB2YXIgc291cmNlSW5mbyA9IGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtRm9yUHJvcHMocHJvcHMpO1xuXG4gICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgIGluZm8gKz0gc291cmNlSW5mbztcbiAgICB9IGVsc2Uge1xuICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICB9XG5cbiAgICB2YXIgdHlwZVN0cmluZztcblxuICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICB0eXBlU3RyaW5nID0gJ251bGwnO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgfSBlbHNlIGlmICh0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgICB0eXBlU3RyaW5nID0gXCI8XCIgKyAoZ2V0Q29tcG9uZW50TmFtZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgaW5mbyA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD8nO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgfVxuXG4gICAge1xuICAgICAgZXJyb3IoJ1JlYWN0LmNyZWF0ZUVsZW1lbnQ6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGVsZW1lbnQgPSBjcmVhdGVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IC8vIFRoZSByZXN1bHQgY2FuIGJlIG51bGxpc2ggaWYgYSBtb2NrIG9yIGEgY3VzdG9tIGZ1bmN0aW9uIGlzIHVzZWQuXG4gIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cblxuICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmcgZXJyb3JzLlxuICAvLyBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kIHByb2QuXG4gIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gIC8vIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcblxuXG4gIGlmICh2YWxpZFR5cGUpIHtcbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCB0eXBlKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZSA9PT0gZXhwb3J0cy5GcmFnbWVudCkge1xuICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgfSBlbHNlIHtcbiAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufVxudmFyIGRpZFdhcm5BYm91dERlcHJlY2F0ZWRDcmVhdGVGYWN0b3J5ID0gZmFsc2U7XG5mdW5jdGlvbiBjcmVhdGVGYWN0b3J5V2l0aFZhbGlkYXRpb24odHlwZSkge1xuICB2YXIgdmFsaWRhdGVkRmFjdG9yeSA9IGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbi5iaW5kKG51bGwsIHR5cGUpO1xuICB2YWxpZGF0ZWRGYWN0b3J5LnR5cGUgPSB0eXBlO1xuXG4gIHtcbiAgICBpZiAoIWRpZFdhcm5BYm91dERlcHJlY2F0ZWRDcmVhdGVGYWN0b3J5KSB7XG4gICAgICBkaWRXYXJuQWJvdXREZXByZWNhdGVkQ3JlYXRlRmFjdG9yeSA9IHRydWU7XG5cbiAgICAgIHdhcm4oJ1JlYWN0LmNyZWF0ZUZhY3RvcnkoKSBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gJyArICdhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBDb25zaWRlciB1c2luZyBKU1ggJyArICdvciB1c2UgUmVhY3QuY3JlYXRlRWxlbWVudCgpIGRpcmVjdGx5IGluc3RlYWQuJyk7XG4gICAgfSAvLyBMZWdhY3kgaG9vazogcmVtb3ZlIGl0XG5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWxpZGF0ZWRGYWN0b3J5LCAndHlwZScsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdhcm4oJ0ZhY3RvcnkudHlwZSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdGhlIGNsYXNzIGRpcmVjdGx5ICcgKyAnYmVmb3JlIHBhc3NpbmcgaXQgdG8gY3JlYXRlRmFjdG9yeS4nKTtcblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3R5cGUnLCB7XG4gICAgICAgICAgdmFsdWU6IHR5cGVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHZhbGlkYXRlZEZhY3Rvcnk7XG59XG5mdW5jdGlvbiBjbG9uZUVsZW1lbnRXaXRoVmFsaWRhdGlvbihlbGVtZW50LCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBjbG9uZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgbmV3RWxlbWVudC50eXBlKTtcbiAgfVxuXG4gIHZhbGlkYXRlUHJvcFR5cGVzKG5ld0VsZW1lbnQpO1xuICByZXR1cm4gbmV3RWxlbWVudDtcbn1cblxue1xuXG4gIHRyeSB7XG4gICAgdmFyIGZyb3plbk9iamVjdCA9IE9iamVjdC5mcmVlemUoe30pO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLW5ldyAqL1xuXG4gICAgbmV3IE1hcChbW2Zyb3plbk9iamVjdCwgbnVsbF1dKTtcbiAgICBuZXcgU2V0KFtmcm96ZW5PYmplY3RdKTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLW5ldyAqL1xuICB9IGNhdGNoIChlKSB7XG4gIH1cbn1cblxudmFyIGNyZWF0ZUVsZW1lbnQkMSA9ICBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24gO1xudmFyIGNsb25lRWxlbWVudCQxID0gIGNsb25lRWxlbWVudFdpdGhWYWxpZGF0aW9uIDtcbnZhciBjcmVhdGVGYWN0b3J5ID0gIGNyZWF0ZUZhY3RvcnlXaXRoVmFsaWRhdGlvbiA7XG52YXIgQ2hpbGRyZW4gPSB7XG4gIG1hcDogbWFwQ2hpbGRyZW4sXG4gIGZvckVhY2g6IGZvckVhY2hDaGlsZHJlbixcbiAgY291bnQ6IGNvdW50Q2hpbGRyZW4sXG4gIHRvQXJyYXk6IHRvQXJyYXksXG4gIG9ubHk6IG9ubHlDaGlsZFxufTtcblxuZXhwb3J0cy5DaGlsZHJlbiA9IENoaWxkcmVuO1xuZXhwb3J0cy5Db21wb25lbnQgPSBDb21wb25lbnQ7XG5leHBvcnRzLlB1cmVDb21wb25lbnQgPSBQdXJlQ29tcG9uZW50O1xuZXhwb3J0cy5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzO1xuZXhwb3J0cy5jbG9uZUVsZW1lbnQgPSBjbG9uZUVsZW1lbnQkMTtcbmV4cG9ydHMuY3JlYXRlQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ7XG5leHBvcnRzLmNyZWF0ZUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50JDE7XG5leHBvcnRzLmNyZWF0ZUZhY3RvcnkgPSBjcmVhdGVGYWN0b3J5O1xuZXhwb3J0cy5jcmVhdGVSZWYgPSBjcmVhdGVSZWY7XG5leHBvcnRzLmZvcndhcmRSZWYgPSBmb3J3YXJkUmVmO1xuZXhwb3J0cy5pc1ZhbGlkRWxlbWVudCA9IGlzVmFsaWRFbGVtZW50O1xuZXhwb3J0cy5sYXp5ID0gbGF6eTtcbmV4cG9ydHMubWVtbyA9IG1lbW87XG5leHBvcnRzLnVzZUNhbGxiYWNrID0gdXNlQ2FsbGJhY2s7XG5leHBvcnRzLnVzZUNvbnRleHQgPSB1c2VDb250ZXh0O1xuZXhwb3J0cy51c2VEZWJ1Z1ZhbHVlID0gdXNlRGVidWdWYWx1ZTtcbmV4cG9ydHMudXNlRWZmZWN0ID0gdXNlRWZmZWN0O1xuZXhwb3J0cy51c2VJbXBlcmF0aXZlSGFuZGxlID0gdXNlSW1wZXJhdGl2ZUhhbmRsZTtcbmV4cG9ydHMudXNlTGF5b3V0RWZmZWN0ID0gdXNlTGF5b3V0RWZmZWN0O1xuZXhwb3J0cy51c2VNZW1vID0gdXNlTWVtbztcbmV4cG9ydHMudXNlUmVkdWNlciA9IHVzZVJlZHVjZXI7XG5leHBvcnRzLnVzZVJlZiA9IHVzZVJlZjtcbmV4cG9ydHMudXNlU3RhdGUgPSB1c2VTdGF0ZTtcbmV4cG9ydHMudmVyc2lvbiA9IFJlYWN0VmVyc2lvbjtcbiAgfSkoKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qcycpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiIsIi8vSU1QT1JUU1xyXG4vL2ltcG9ydCBIZWFkIGZyb20gJ0Bjb21wb25lbnRzL0hlYWQvSGVhZCdcclxuaW1wb3J0IEhlYWQgZnJvbSAnbmV4dC9oZWFkJ1xyXG5pbXBvcnQgSGVhZGVyIGZyb20gJ0Bjb21wb25lbnRzL1RlbXBsYXRlL0hlYWRlci9IZWFkZXInXHJcbmltcG9ydCBDb250YWluZXIgZnJvbSAnQGNvbXBvbmVudHMvVGVtcGxhdGUvQ29udGFpbmVyL0NvbnRhaW5lcidcclxuaW1wb3J0IFNhbmRib3ggZnJvbSAnQGNvbXBvbmVudHMvVGVtcGxhdGUvU2FuZGJveC9TYW5kYm94J1xyXG5pbXBvcnQgQ29tcG9uZW50TWV0YSBmcm9tICdAY29tcG9uZW50cy9UZW1wbGF0ZS9Db21wb25lbnRNZXRhL0NvbXBvbmVudE1ldGEnXHJcbmltcG9ydCBGb290ZXIgZnJvbSAnQGNvbXBvbmVudHMvVGVtcGxhdGUvRm9vdGVyL0Zvb3RlcidcclxuXHJcbmltcG9ydCBGaWxtR3JhaW5GaWx0ZXIgZnJvbSAnQGNvbXBvbmVudHMvRmlsbUdyYWluRmlsdGVyL0ZpbG1HcmFpbkZpbHRlcidcclxuXHJcbi8vVkFSU1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0U3RhdGljUHJvcHMoKSB7XHJcbiAgXHJcbiAgLy9HZW5lcmFsIFBhZ2UgVkFSU1xyXG5cdCAgbGV0IHRpdGxlID0gXCJGaWxtR3JhaW5GaWx0ZXJcIlxyXG5cdCAgbGV0IGF1dGhvciA9IFwiQWxlYyBSZWltZWxcIlxyXG5cdCAgbGV0IGF1dGhvclRlYW0gPSBcIlBsYW5ldCBDYXJhdmFuIFN0dWRpb3NcIlxyXG5cdCAgbGV0IGRlc2NyaXB0aW9uID1cIlxcXHJcblx0ICBcdFx0XHRcdFx0XHRPdmVybGF5IGZpbHRlciBiYXNlZCBvbiBWSFMgZmlsbSBncmFpbi5cXFxyXG5cdCAgXHRcdFx0XHRcdFwiXHJcblx0ICBsZXQgY29udGVudFByb3BzID0gJ04vQSdcclxuXHQgIGxldCBsaWJyYXJpZXMgPSBcIk4vQVwiXHJcblx0ICBcclxuXHQgIGxldCBmb290ZXJNZXNzYWdlID0gXCJDcmVhdGVkIGJ5IFBsYW5ldCBDYXJhdmFuIFN0dWRpb3NcIlxyXG4gIFxyXG4gIC8vQ29tcG9uZW50IENvbnRlbnRcclxuICBcdGxldCBwb3N0RGF0YVVybCA9IFwidGVzdC5jb21cIlxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHByb3BzOiB7XHJcbiAgICAgICAgdGl0bGUsXHJcbiAgICAgICAgYXV0aG9yLFxyXG4gICAgICAgIGF1dGhvclRlYW0sXHJcbiAgICAgICAgZGVzY3JpcHRpb24sXHJcbiAgICAgICAgY29udGVudFByb3BzLFxyXG4gICAgICAgIGxpYnJhcmllcyxcclxuICAgICAgICBmb290ZXJNZXNzYWdlLFxyXG4gICAgICB9LCAvLyB3aWxsIGJlIHBhc3NlZCB0byB0aGUgcGFnZSBjb21wb25lbnQgYXMgcHJvcHNcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEhvbWUocHJvcHMpIHtcclxuICByZXR1cm4gKFxyXG4gICAgPD5cclxuICAgICAgPEhlYWQ+XHJcbiAgICAgICAgPHRpdGxlPk5lY3JvIEN1bHQgWmluZSBDb21wb25lbnQ8L3RpdGxlPlxyXG4gICAgICA8L0hlYWQ+XHJcblxyXG4gICAgICA8RmlsbUdyYWluRmlsdGVyLz5cclxuXHJcbiAgICAgIDxtYWluPlxyXG4gICAgICAgIDxIZWFkZXIgdGl0bGU9XCJOZWNybyBDdWx0IFppbmUgQ29tcG9uZW50IERlbW9cIiAvPlxyXG4gICAgICAgIDxDb250YWluZXI+XHJcbiAgICAgICAgICA8Q29tcG9uZW50TWV0YVxyXG4gICAgICAgICAgICB0aXRsZT17cHJvcHMudGl0bGV9XHJcbiAgICAgICAgICAgIGF1dGhvcj17cHJvcHMuYXV0aG9yfVxyXG4gICAgICAgICAgICBhdXRob3JUZWFtPXtwcm9wcy5hdXRob3JUZWFtfVxyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17cHJvcHMuZGVzY3JpcHRpb259XHJcbiAgICAgICAgICAgIGNvbnRlbnRQcm9wcz17cHJvcHMuY29udGVudFByb3BzfVxyXG4gICAgICAgICAgICBsaWJyYXJpZXM9e3Byb3BzLmxpYnJhcmllc31cclxuICAgICAgICAgIC8+XHJcbiAgICAgICAgPC9Db250YWluZXI+XHJcbiAgICAgICAgXHJcbiAgICAgICAgPFNhbmRib3g+XHJcbiAgICAgICAgXHRUaGlzIGNvbXBvbmVudCBzaG91bGQgYmUgYSB0b3AtbGV2ZWwgZWxlbWVudC4gXHJcbiAgICAgICAgXHQ8YnIvPjxici8+XHJcbiAgICAgICAgXHRJdCBzaG91bGQgc2l0IG91dHNpZGUgb2YgYW55IHByaW1hcnkgY29udGVudC5cclxuICAgICAgICA8L1NhbmRib3g+XHJcbiAgICAgICAgXHJcbiAgICAgIDwvbWFpbj5cclxuXHJcbiAgICAgIDxGb290ZXIgZm9vdGVyTWVzc2FnZT17cHJvcHMuZm9vdGVyTWVzc2FnZX0gLz5cclxuICAgIDwvPlxyXG4gIClcclxufVxyXG4iXSwic291cmNlUm9vdCI6IiJ9